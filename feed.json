{
    "version": "https://jsonfeed.org/version/1",
    "title": "世上无难事,只要肯放弃",
    "subtitle": "",
    "icon": "http://oreki.world/images/favicon.ico",
    "description": "",
    "home_page_url": "http://oreki.world",
    "items": [
        {
            "id": "http://oreki.world/Rabbitmq%E7%9F%A5%E8%AF%86%E7%82%B9/",
            "url": "http://oreki.world/Rabbitmq%E7%9F%A5%E8%AF%86%E7%82%B9/",
            "title": "Rabbitmq知识点",
            "date_published": "2022-06-28T13:03:14.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": []
        },
        {
            "id": "http://oreki.world/computer-science/golang/go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/",
            "url": "http://oreki.world/computer-science/golang/go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/",
            "title": "Go面试题汇总",
            "date_published": "2022-04-01T14:16:00.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"golang面试问题汇总\"><a class=\"anchor\" href=\"#golang面试问题汇总\">#</a> Golang 面试问题汇总</h2><p>通常我们去面试肯定会有些不错的 Golang 的面试题目的，所以总结下，让其他 Golang 开发者也可以查看到，同时也用来检测自己的能力和提醒自己的不足之处，欢迎大家补充和提交新的面试题目.</p><p>Golang 面试问题汇总，这里主要分为 Golang, Mysql, Redis, Network Protocol (网络协议), Linux, 以及 Algorithm 和 Structrues.</p><h3 id=\"golang基础\"><a class=\"anchor\" href=\"#golang基础\">#</a> Golang 基础</h3><p>| 题号 | 题目 |<br>|-----------------------------|---------------------------------------------------------------------------------------------------------|<br>| 1 | <a href=\"#Golang%E4%B8%AD%E9%99%A4%E4%BA%86%E5%8A%A0Mutex%E9%94%81%E4%BB%A5%E5%A4%96%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%AE%89%E5%85%A8%E8%AF%BB%E5%86%99%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F\">Golang 中除了加 Mutex 锁以外还有哪些方式安全读写共享变量</a> |<br>| 2 | <a href=\"#%E6%97%A0%E7%BC%93%E5%86%B2Chan%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%98%AF%E5%90%A6%E5%90%8C%E6%AD%A5\">无缓冲 Chan 的发送和接收是否同步</a> |<br>| 3 | <a href=\"#Golang%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%83%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B\">Golang 并发机制以及它所使用的 CSP 并发模型</a> |<br>| 4 | <a href=\"#Golang%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B\">Golang 中常用的并发模型</a> |<br>| 5 | <a href=\"#Go%E4%B8%AD%E5%AF%B9nil%E7%9A%84Slice%E5%92%8C%E7%A9%BASlice%E7%9A%84%E5%A4%84%E7%90%86%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%E5%90%97\">Go 中对 nil 的 Slice 和空 Slice 的处理是一致的吗</a> |<br>| 6 | <a href=\"#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\">协程和线程和进程的区别</a> |<br>| 7 | <a href=\"#Golang%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%A4%9A%E4%BA%86%E4%BC%9A%E9%80%A0%E6%88%90gc%E5%8E%8B%E5%8A%9B\">Golang 的内存模型中为什么小对象多了会造成 GC 压力</a> |<br>| 8 | <a href=\"#Go%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3\">Go 中数据竞争问题怎么解决</a> |<br>| 9 | <a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFchannel%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\">什么是 channel，为什么它可以做到线程安全</a> |<br>| 10 | <a href=\"#Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\">Golang 垃圾回收算法</a> |<br>| 11 | <a href=\"#GC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6\">GC 的触发条件</a> |<br>| 12 | <a href=\"#Go%E7%9A%84GPM%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6\">Go 的 GPM 如何调度</a> |<br>| 13 | <a href=\"#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88\">并发编程概念是什么</a> |<br>| 14 | <a href=\"#Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A0%88%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84\">Go 语言的栈空间管理是怎么样的</a> |<br>| 15 | <a href=\"#Goroutine%E5%92%8CChannel%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\">Goroutine 和 Channel 的作用分别是什么</a> |<br>| 16 | <a href=\"#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8BGoroutine%E7%9A%84%E6%95%B0%E9%87%8F\">怎么查看 Goroutine 的数量</a> |<br>| 17 | <a href=\"#Go%E4%B8%AD%E7%9A%84%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B\">Go 中的锁有哪些</a> |<br>| 18 | <a href=\"#%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6Goroutine%E7%9A%84%E6%95%B0%E9%87%8F\">怎么限制 Goroutine 的数量</a> |<br>| 19 | <a href=\"#Channel%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84\">Channel 是同步的还是异步的</a> |<br>| 20 | <a href=\"#Goroutine%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\">Goroutine 和线程的区别</a> |<br>| 21 | <a href=\"#Go%E7%9A%84Struct%E8%83%BD%E4%B8%8D%E8%83%BD%E6%AF%94%E8%BE%83\">Go 的 Struct 能不能比较</a> |<br>| 22 | <a href=\"#Go%E7%9A%84defer%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\">Go 的 defer 原理是什么</a> |<br>| 23 | <a href=\"#Go%E7%9A%84select%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88\">Go 的 select 可以用于什么</a> |<br>| 24 | <a href=\"#Go%E7%9A%84Context%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88\">Go 的 Context 包的用途是什么</a> |<br>| 25 | <a href=\"#Go%E4%B8%BB%E5%8D%8F%E7%A8%8B%E5%A6%82%E4%BD%95%E7%AD%89%E5%85%B6%E4%BD%99%E5%8D%8F%E7%A8%8B%E5%AE%8C%E5%86%8D%E6%93%8D%E4%BD%9C\">Go 主协程如何等其余协程完再操作</a> |<br>| 26 | <a href=\"#Go%E7%9A%84Slice%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9\">Go 的 Slice 如何扩容</a> |<br>| 27 | <a href=\"#Go%E4%B8%AD%E7%9A%84map%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96\">Go 中的 map 如何实现顺序读取</a> |<br>| 28 | <a href=\"#Go%E4%B8%ADCAS%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B\">Go 中 CAS 是怎么回事</a> |<br>| 29 | <a href=\"#Go%E4%B8%AD%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%98%AF%E4%BB%80%E4%B9%88\">Go 中的逃逸分析是什么</a> |<br>| 30 | <a href=\"#Go%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB\">Go 值接收者和指针接收者的区别</a> |<br>| 31 | <a href=\"#Go%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E6%80%8E%E6%A0%B7%E5%88%86%E9%85%8D%E7%9A%84\">Go 的对象在内存中是怎样分配的</a> |<br>| 32 | <a href=\"#%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%9A%84\">栈的内存是怎么分配的</a> |<br>| 33 | <a href=\"#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D%E7%9A%84\">堆内存管理怎么分配的</a> |<br>| 34 | <a href=\"#Go%E4%B8%AD%E7%9A%84defer%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88\">Go 中的 defer 函数使用下面的两种情况下结果是什么</a> |<br>| 35 | <a href=\"#%E5%9C%A8Go%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2\">在 Go 函数中为什么会发生内存泄露</a> |<br>| 36 | <a href=\"#Go%E4%B8%ADnew%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB\">Go 中 new 和 make 的区别</a> |<br>| 37 | <a href=\"#G0%E7%9A%84%E4%BD%9C%E7%94%A8\">G0 的作用</a> |<br>| 38 | <a href=\"#Go%E4%B8%AD%E7%9A%84%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0\">Go 中的锁如何实现</a> |<br>| 39 | <a href=\"#Go%E4%B8%AD%E7%9A%84channel%E7%9A%84%E5%AE%9E%E7%8E%B0\">Go 中的 channel 的实现</a> |<br>| 40 | <a href=\"#Go%E4%B8%AD%E7%9A%84map%E7%9A%84%E5%AE%9E%E7%8E%B0\">Go 中的 map 的实现</a> |<br>| 41 | <a href=\"#Go%E4%B8%AD%E7%9A%84http%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">Go 中的 http 包的实现原理</a> |<br>| 42 | <a href=\"#Goroutine%E5%8F%91%E7%94%9F%E4%BA%86%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B\">Goroutine 发生了泄漏如何检测</a> |<br>| 43 | <a href=\"#Go%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8\">Go 函数返回局部变量的指针是否安全</a> |<br>| 44 | <a href=\"#Go%E4%B8%AD%E4%B8%A4%E4%B8%AANil%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%90%97\">Go 中两个 Nil 可能不相等吗</a> |<br>| 45 | <a href=\"#Goroutine%E5%92%8CKernelThread%E4%B9%8B%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB\">Goroutine 和 KernelThread 之间是什么关系</a> |<br>| 46 | <a href=\"#%E4%B8%BA%E4%BD%95GPM%E8%B0%83%E5%BA%A6%E8%A6%81%E6%9C%89P\">为何 GPM 调度要有 P</a> |<br>| 47 | <a href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8goroutine%E6%89%A7%E8%A1%8C%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%E5%8D%8F%E7%A8%8B\">如何在 goroutine 执行一半就退出协程</a> |</p><h3 id=\"mysql基础\"><a class=\"anchor\" href=\"#mysql基础\">#</a> Mysql 基础</h3><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#Mysql%E7%B4%A2%E5%BC%95%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E7%AE%97%E6%B3%95\">Mysql 索引用的是什么算法</a></td></tr><tr><td>2</td><td><a href=\"#Mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0\">Mysql 事务的基本要素</a></td></tr><tr><td>3</td><td><a href=\"#Mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\">Mysql 的存储引擎</a></td></tr><tr><td>4</td><td><a href=\"#Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\">Mysql 事务隔离级别</a></td></tr><tr><td>5</td><td><a href=\"#Mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B\">Mysql 高可用方案有哪些</a></td></tr><tr><td>6</td><td><a href=\"#Mysql%E4%B8%ADutf8%E5%92%8Cutf8mb4%E5%8C%BA%E5%88%AB\">Mysql 中 utf8 和 utf8mb4 区别</a></td></tr><tr><td>7</td><td><a href=\"#Mysql%E4%B8%AD%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E5%8C%BA%E5%88%AB\">Mysql 中乐观锁和悲观锁区别</a></td></tr><tr><td>8</td><td><a href=\"#Mysql%E7%B4%A2%E5%BC%95%E4%B8%BB%E8%A6%81%E6%98%AF%E5%93%AA%E4%BA%9B\">Mysql 索引主要是哪些</a></td></tr><tr><td>9</td><td><a href=\"#Mysql%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99\">Mysql 联合索引最左匹配原则</a></td></tr><tr><td>10</td><td><a href=\"#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB\">聚簇索引和非聚簇索引区别</a></td></tr><tr><td>11</td><td><a href=\"#%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%98%AF%E5%90%A6%E5%91%BD%E4%B8%AD%E4%BA%86%E7%B4%A2%E5%BC%95\">如何查询一个字段是否命中了索引</a></td></tr><tr><td>12</td><td><a href=\"#Mysql%E4%B8%AD%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E4%BC%9A%E5%91%BD%E4%B8%AD%E7%B4%A2%E5%BC%95\">Mysql 中查询数据什么情况下不会命中索引</a></td></tr><tr><td>13</td><td><a href=\"#Mysql%E4%B8%AD%E7%9A%84MVCC%E6%98%AF%E4%BB%80%E4%B9%88\">Mysql 中的 MVCC 是什么</a></td></tr><tr><td>14</td><td><a href=\"#Mvcc%E5%92%8CRedolog%E5%92%8CUndolog%E4%BB%A5%E5%8F%8ABinlog%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C\">Mvcc 和 Redolog 和 Undolog 以及 Binlog 有什么不同</a></td></tr><tr><td>15</td><td><a href=\"#Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%BB%A5%E5%8F%8A%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5\">Mysql 读写分离以及主从同步</a></td></tr><tr><td>16</td><td><a href=\"#InnoDB%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7\">InnoDB 的关键特性</a></td></tr><tr><td>17</td><td><a href=\"#Mysql%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7\">Mysql 如何保证一致性和持久性</a></td></tr><tr><td>18</td><td><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B+%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84\">为什么选择 B + 树作为索引结构</a></td></tr><tr><td>19</td><td><a href=\"#InnoDB%E7%9A%84%E8%A1%8C%E9%94%81%E6%A8%A1%E5%BC%8F\">InnoDB 的行锁模式</a></td></tr><tr><td>20</td><td><a href=\"#%E5%93%88%E5%B8%8C(hash)%E6%AF%94%E6%A0%91(tree)%E6%9B%B4%E5%BF%AB%EF%BC%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E6%A0%91%E5%9E%8B\">哈希 (hash) 比树 (tree) 更快，索引结构为什么要设计成树型</a></td></tr><tr><td>21</td><td><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%9A%84key%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E5%A4%AA%E9%95%BF\">为什么索引的 key 长度不能太长</a></td></tr><tr><td>22</td><td><a href=\"#Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E5%88%B0%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E7%82%B9\">Mysql 的数据如何恢复到任意时间点</a></td></tr><tr><td>23</td><td><a href=\"#Mysql%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0%E4%BA%86%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2\">Mysql 为什么加了索引可以加快查询</a></td></tr><tr><td>24</td><td><a href=\"#Explain%E5%91%BD%E4%BB%A4%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\">Explain 命令有什么用</a></td></tr></tbody></table><h3 id=\"redis基础\"><a class=\"anchor\" href=\"#redis基础\">#</a> Redis 基础</h3><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">Redis 的数据结构及使用场景</a></td></tr><tr><td>2</td><td><a href=\"#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\">Redis 持久化的几种方式</a></td></tr><tr><td>3</td><td><a href=\"#Redis%E7%9A%84LRU%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\">Redis 的 LRU 具体实现</a></td></tr><tr><td>4</td><td><a href=\"#%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB\">单线程的 Redis 为什么快</a></td></tr><tr><td>5</td><td><a href=\"#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5\">Redis 的数据过期策略</a></td></tr><tr><td>6</td><td><a href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98\">如何解决 Redis 缓存雪崩问题</a></td></tr><tr><td>7</td><td><a href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98\">如何解决 Redis 缓存穿透问题</a></td></tr><tr><td>8</td><td><a href=\"#Redis%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89key%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3\">Redis 并发竞争 key 如何解决</a></td></tr><tr><td>9</td><td><a href=\"#Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB\">Redis 的主从模式和哨兵模式和集群模式区别</a></td></tr><tr><td>10</td><td><a href=\"#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84\">Redis 有序集合 zset 底层怎么实现的</a></td></tr><tr><td>11</td><td><a href=\"#%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8F%92%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\">跳表的查询过程是怎么样的，查询和插入的时间复杂度</a></td></tr><tr><td>12</td><td><a href=\"#redis%E5%A6%82%E4%BD%95%E5%88%86%E7%89%87\">redis 如何分片</a></td></tr></tbody></table><h3 id=\"网络协议基础\"><a class=\"anchor\" href=\"#网络协议基础\">#</a> 网络协议基础</h3><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#TCP%E5%92%8CUDP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">TCP 和 UDP 有什么区别</a></td></tr><tr><td>2</td><td><a href=\"#TCP%E4%B8%AD%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\">TCP 中三次握手和四次挥手</a></td></tr><tr><td>3</td><td><a href=\"#TCP%E7%9A%84LISTEN%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88\">TCP 的 LISTEN 状态是什么</a></td></tr><tr><td>4</td><td><a href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B\">常见的 HTTP 状态码有哪些</a></td></tr><tr><td>5</td><td><a href=\"#301%E5%92%8C302%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">301 和 302 有什么区别</a></td></tr><tr><td>6</td><td><a href=\"#504%E5%92%8C500%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">504 和 500 有什么区别</a></td></tr><tr><td>7</td><td><a href=\"#HTTPS%E5%92%8CHTTP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">HTTPS 和 HTTP 有什么区别</a></td></tr><tr><td>8</td><td><a href=\"#Quic%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E7%9B%B8%E6%AF%94Http2\">Quic 有什么优点相比 Http2</a></td></tr><tr><td>9</td><td><a href=\"#Grpc%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">Grpc 的优缺点</a></td></tr><tr><td>10</td><td><a href=\"#Get%E5%92%8CPost%E5%8C%BA%E5%88%AB\">Get 和 Post 区别</a></td></tr><tr><td>11</td><td><a href=\"#Unicode%E5%92%8CASCII%E4%BB%A5%E5%8F%8AUtf8%E7%9A%84%E5%8C%BA%E5%88%AB\">Unicode 和 ASCII 以及 Utf8 的区别</a></td></tr><tr><td>12</td><td><a href=\"#Cookie%E4%B8%8ESession%E5%BC%82%E5%90%8C\">Cookie 与 Session 异同</a></td></tr><tr><td>13</td><td><a href=\"#Client%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5\">Client 如何实现长连接</a></td></tr><tr><td>14</td><td><a href=\"#Http1%E5%92%8CHttp2%E5%92%8CGrpc%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88\">Http1 和 Http2 和 Grpc 之间的区别是什么</a></td></tr><tr><td>15</td><td><a href=\"#Tcp%E4%B8%AD%E7%9A%84%E6%8B%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B\">Tcp 中的拆包和粘包是怎么回事</a></td></tr><tr><td>16</td><td><a href=\"#TFO%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\">TFO 的原理是什么</a></td></tr><tr><td>17</td><td><a href=\"#TIME_WAIT%E7%9A%84%E4%BD%9C%E7%94%A8\">TIME_WAIT 的作用</a></td></tr><tr><td>18</td><td><a href=\"#%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%9C%89%E5%93%AA%E4%BA%9B\">网络的性能指标有哪些</a></td></tr></tbody></table><h3 id=\"linux基础\"><a class=\"anchor\" href=\"#linux基础\">#</a> Linux 基础</h3><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#%E5%BC%82%E6%AD%A5%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB\">异步和非阻塞的区别</a></td></tr><tr><td>2</td><td><a href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\">虚拟内存作用是什么</a></td></tr><tr><td>3</td><td><a href=\"#Linux%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E5%92%8Ccpu%E8%B4%9F%E8%BD%BD\">Linux 查看端口占用和 cpu 负载</a></td></tr><tr><td>4</td><td><a href=\"#Linux%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B\">Linux 如何发送信号给一个进程</a></td></tr><tr><td>5</td><td><a href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81\">如何避免死锁</a></td></tr><tr><td>6</td><td><a href=\"#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%8C%BA%E5%88%AB\">孤儿进程和僵尸进程区别</a></td></tr><tr><td>7</td><td><a href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8\">滑动窗口的概念以及应用</a></td></tr><tr><td>8</td><td><a href=\"#Epoll%E5%92%8CSelect%E7%9A%84%E5%8C%BA%E5%88%AB\">Epoll 和 Select 的区别</a></td></tr><tr><td>9</td><td><a href=\"#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E5%91%A2\">进程之间为什么要进行通信呢</a></td></tr><tr><td>10</td><td><a href=\"#%E8%BE%93%E5%85%A5PingIP%E5%90%8E%E6%95%B2%E5%9B%9E%E8%BD%A6,%E5%8F%91%E5%8C%85%E5%89%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88\">输入 PingIP 后敲回车，发包前会发生什么</a></td></tr><tr><td>11</td><td><a href=\"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB%E5%92%8C%E4%B8%8D%E5%90%8C\">进程和进程间的通信方式区别和不同</a></td></tr><tr><td>12</td><td><a href=\"#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93\">如何查看二进制可执行文件引用的动态链接库</a></td></tr></tbody></table><h3 id=\"algorithm和structrues\"><a class=\"anchor\" href=\"#algorithm和structrues\">#</a> Algorithm 和 Structrues</h3><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#%E5%93%AA%E4%BA%9B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%98%AF%E7%A8%B3%E5%AE%9A%E7%9A%84\">哪些排序算法是稳定的</a></td></tr><tr><td>2</td><td><a href=\"#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91,%E5%88%A4%E6%96%AD%E5%85%B6%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91\">给定一个二叉树，判断其是否是一个有效的二叉搜索树</a></td></tr><tr><td>3</td><td><a href=\"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\">排序算法</a></td></tr><tr><td>4</td><td><a href=\"#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8\">如何通过递归反转单链表</a></td></tr><tr><td>5</td><td><a href=\"#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9\">链表和数组相比有什么优缺点</a></td></tr><tr><td>6</td><td><a href=\"#%E9%80%9A%E5%B8%B8%E4%B8%80%E8%88%AC%E4%BC%9A%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\">通常一般会用到哪些数据结构</a></td></tr></tbody></table><h4 id=\"云原生\"><a class=\"anchor\" href=\"#云原生\">#</a> 云原生</h4><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#prometheus%E6%9E%B6%E6%9E%84%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%90%84%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8\">prometheus 架构中有哪些组件以及各个组件有什么用</a></td></tr></tbody></table><h3 id=\"其他基础\"><a class=\"anchor\" href=\"#其他基础\">#</a> 其他基础</h3><table><thead><tr><th>题号</th><th>题目</th></tr></thead><tbody><tr><td>1</td><td><a href=\"#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86\">中间件原理</a></td></tr><tr><td>2</td><td><a href=\"#Hash%E5%86%B2%E7%AA%81%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\">Hash 冲突有什么解决办法</a></td></tr><tr><td>3</td><td><a href=\"#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84\">微服务架构是什么样子的</a></td></tr><tr><td>4</td><td><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0\">分布式锁实现</a></td></tr><tr><td>5</td><td><a href=\"#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\">负载均衡原理是什么</a></td></tr><tr><td>6</td><td><a href=\"#%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3\">互斥锁和读写锁和死锁问题是怎么解决</a></td></tr><tr><td>7</td><td><a href=\"#Etcd%E4%B8%AD%E7%9A%84Raft%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\">Etcd 中的 Raft 一致性算法原理</a></td></tr><tr><td>8</td><td><a href=\"#Git%E7%9A%84merge%E8%B7%9Frebase%E7%9A%84%E5%8C%BA%E5%88%AB\">Git 的 merge 跟 rebase 的区别</a></td></tr><tr><td>9</td><td><a href=\"#%E5%A6%82%E4%BD%95%E5%AF%B9%E4%B8%80%E4%B8%AA20GB%E7%9A%84%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F\">如何对一个 20GB 的文件进行排序</a></td></tr><tr><td>10</td><td><a href=\"#LVS%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\">LVS 原理是什么</a></td></tr><tr><td>11</td><td><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\">为什么需要消息队列</a></td></tr><tr><td>12</td><td><a href=\"#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0\">高并发系统的设计与实现</a></td></tr><tr><td>13</td><td><a href=\"#Kafka%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6\">Kafka 的文件存储机制</a></td></tr><tr><td>14</td><td><a href=\"#Kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7\">Kafka 如何保证可靠性</a></td></tr><tr><td>15</td><td><a href=\"#Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%90%9E%E5%90%90%E7%8E%87%E7%9A%84\">Kafka 是如何实现高吞吐率的</a></td></tr><tr><td>16</td><td><a href=\"#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D\">分布式事务有哪几种</a></td></tr></tbody></table><h2 id=\"golang基础模块信息\"><a class=\"anchor\" href=\"#golang基础模块信息\">#</a> Golang 基础模块信息</h2><ol><li><h4 id=\"golang中除了加mutex锁以外还有哪些方式安全读写共享变量\"><a class=\"anchor\" href=\"#golang中除了加mutex锁以外还有哪些方式安全读写共享变量\">#</a> Golang 中除了加 Mutex 锁以外还有哪些方式安全读写共享变量</h4></li></ol><p>Golang 中 Goroutine 可以通过 Channel 进行安全读写共享变量，还可以通过原子性操作进行.</p><ol start=\"2\"><li><h4 id=\"无缓冲chan的发送和接收是否同步\"><a class=\"anchor\" href=\"#无缓冲chan的发送和接收是否同步\">#</a> 无缓冲 Chan 的发送和接收是否同步</h4></li></ol><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>  无缓冲的channel由于没有缓冲发送和接收需要同步<span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> 有缓冲channel不要求发送和接收操作同步<span class=\"token punctuation\">.</span></pre></td></tr></table></figure><ul><li>channel 无缓冲时，无缓冲 chan 是指在接收前没有能力保存任何值得通道。</li></ul><p>这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。</p><ul><li>channel 有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。</li></ul><ol start=\"3\"><li><h4 id=\"golang并发机制以及它所使用的csp并发模型\"><a class=\"anchor\" href=\"#golang并发机制以及它所使用的csp并发模型\">#</a> Golang 并发机制以及它所使用的 CSP 并发模型．</h4></li></ol><p>在计算机科学中，通信顺序过程（communicating sequential processes，CSP）是一种描述并发系统中交互模式的正式语言，它是并发数学理论家族中的一个成员，被称为过程算法（process algebras），或者说过程计算（process calculate），是基于消息的通道传递的数学理论。</p><p>CSP 模型是上个世纪七十年代提出的，不同于传统的多线程通过共享内存来通信，CSP 讲究的是 “以通信的方式来共享内存”。用于描述两个独立的并发实体通过共享的通讯 channel (管道) 进行通信的并发模型。 CSP 中 channel 是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的 channel。</p><p>Golang 中 channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 <code>boss-worker</code> 模式的，一个实体通过将消息发送到 channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的，在实现原理上其实类似一个阻塞的消息队列。</p><p>Goroutine 是 Golang 实际并发执行的实体，它底层是使用协程 (coroutine) 实现并发，coroutine 是一种运行在用户态的用户线程，类似于 greenthread，go 底层选择使用 coroutine 的出发点是因为，</p><p>它具有以下特点:</p><ul><li>用户空间 避免了内核态和用户态的切换导致的成本.</li><li>可以由语言和框架层进行调度.</li><li>更小的栈空间允许创建大量的实例.</li></ul><p>Golang 中的 Goroutine 的特性:</p><p>Golang 内部有三个对象: P 对象 (processor) 代表上下文（或者可以认为是 cpu），M (work thread) 代表工作线程，G 对象 (goroutine).</p><p>正常情况下一个 CPU 对象启一个工作线程对象，线程去检查并执行 goroutine 对象。碰到 goroutine 对象阻塞的时候，会启动一个新的工作线程，以充分利用 cpu 资源。所以有时候线程对象会比处理器对象多很多.</p><p>我们用如下图分别表示 P、M、G:</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/59.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ul><li><p>G（Goroutine）: 我们所说的协程，为用户级的轻量级线程，每个 Goroutine 对象中的 sched 保存着其上下文信息。</p></li><li><p>M（Machine）: 对 OS 内核级线程的封装，数量对应真实的 CPU 数 (真正干活的对象).</p></li><li><p>P (Processor): 逻辑处理器，即为 G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系，其数量可通过 <code>GOMAXPROCS()</code> 来设置，默认为核心数。</p></li></ul><p>在单核情况下，所有 Goroutine 运行在同一个线程（M0）中，每一个线程维护一个上下文（P），任何时刻，一个上下文中只有一个 Goroutine，其他 Goroutine 在 runqueue 中等待。</p><p>一个 Goroutine 运行完自己的时间片后，让出上下文，自己回到 runqueue 中（如下图所示）。</p><p>当正在运行的 G0 阻塞的时候（可以需要 IO），会再创建一个线程（M1），P 转到新的线程中去运行。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/60.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>当 M0 返回时，它会尝试从其他线程中 “偷” 一个上下文过来，如果没有偷到，会把 Goroutine 放到 <code>Global runqueue</code> 中去，然后把自己放入线程缓存中。</p><p>上下文会定时检查 <code>Global runqueue</code> 。</p><p>Golang 是为并发而生的语言，Go 语言是为数不多的在语言层面实现并发的语言；也正是 Go 语言的并发特性，吸引了全球无数的开发者。</p><p>Golang 的 CSP 并发模型，是通过 Goroutine 和 Channel 来实现的。</p><p>Goroutine 是 Go 语言中并发的执行单位。有点抽象，其实就是和传统概念上的” 线程 “类似，可以理解为” 线程 “。Channel 是 Go 语言中各个并发结构体 (Goroutine) 之前的通信机制。通常 Channel，是各个 Goroutine 之间通信的” 管道 “，有点类似于 Linux 中的管道。</p><p>通信机制 channel 也很方便，传数据用 <code>channel &lt;- data</code> ，取数据用 <code>&lt;-channel</code> 。</p><p>在通信过程中，传数据 <code>channel &lt;- data</code> 和取数据 <code>&lt;-channel</code> 必然会成对出现，因为这边传，那边取，两个 goroutine 之间才会实现通信。而且不管是传还是取，肯定阻塞，直到另外的 goroutine 传或者取为止。因此 GPM 的简要概括即为：事件循环，线程池，工作队列。</p><ol start=\"4\"><li><h4 id=\"golang中常用的并发模型\"><a class=\"anchor\" href=\"#golang中常用的并发模型\">#</a> Golang 中常用的并发模型</h4></li></ol><p>Golang 中常用的并发模型有三种:</p><ul><li>通过 channel 通知实现并发控制</li></ul><p>无缓冲的通道指的是通道的大小为 0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。</p><p>从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    ch <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"start working\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second <span class=\"token operator\">*</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        ch <span class=\"token operator\">&lt;-</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token operator\">&lt;-</span>ch</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"finished\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当主 goroutine 运行到 <code>&lt;-ch</code> 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制</p><ul><li>通过 sync 包中的 WaitGroup 实现并发控制</li></ul><p>Goroutine 是异步执行的，有的时候为了防止在结束 main 函数的时候结束掉 Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup 了，在 Sync 包中，提供了 WaitGroup, 它会等待它收集的所有 goroutine 任务全部完成。</p><p>在 WaitGroup 里主要有三个方法:</p><ul><li>Add, 可以添加或减少 goroutine 的数量.</li><li>Done, 相当于 Add (-1).</li><li>Wait, 执行后会堵塞主线程，直到 WaitGroup 里的值减至 0.</li></ul><p>在主 goroutine 中 Add (delta int) 索要等待 goroutine 的数量。在每一个 goroutine 完成后 Done () 表示这一个 goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">var</span> urls <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token string\">\"http://www.golang.org/\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token string\">\"http://www.google.com/\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> url <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> urls <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>url <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">defer</span> wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            http<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 Golang 官网中对于 WaitGroup 介绍是 <code>A WaitGroup must not be copied after first use</code> , 在 WaitGroup 第一次使用后，不能被拷贝。</p><p>应用示例:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> wg <span class=\"token operator\">:=</span> sync<span class=\"token punctuation\">.</span>WaitGroup<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>wg sync<span class=\"token punctuation\">.</span>WaitGroup<span class=\"token punctuation\">,</span> i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"i:%d\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>wg<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"exit\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>i<span class=\"token punctuation\">:</span><span class=\"token number\">1i</span><span class=\"token punctuation\">:</span><span class=\"token number\">3i</span><span class=\"token punctuation\">:</span><span class=\"token number\">2i</span><span class=\"token punctuation\">:</span><span class=\"token number\">0i</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span>fatal <span class=\"token builtin\">error</span><span class=\"token punctuation\">:</span> all goroutines are asleep <span class=\"token operator\">-</span> deadlock<span class=\"token operator\">!</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>goroutine <span class=\"token number\">1</span> <span class=\"token punctuation\">[</span>semacquire<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>sync<span class=\"token punctuation\">.</span><span class=\"token function\">runtime_Semacquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xc000094018</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>runtime<span class=\"token operator\">/</span>sema<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">56</span> <span class=\"token operator\">+</span><span class=\"token number\">0x39</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>sync<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>WaitGroup<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xc000094010</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>sync<span class=\"token operator\">/</span>waitgroup<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">130</span> <span class=\"token operator\">+</span><span class=\"token number\">0x64</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>main<span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>Test<span class=\"token operator\">/</span>wait<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">17</span> <span class=\"token operator\">+</span><span class=\"token number\">0xab</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>exit status <span class=\"token number\">2</span></pre></td></tr></table></figure><p>它提示所有的 <code>goroutine</code> 都已经睡眠了，出现了死锁。这是因为 wg 给拷贝传递到了 goroutine 中，导致只有 Add 操作，其实 Done 操作是在 wg 的副本执行的。</p><p>因此 Wait 就会死锁。</p><p>这个第一个修改方式：将匿名函数中 wg 的传入类型改为 <code>*sync.WaitGroup</code> , 这样就能引用到正确的 <code>WaitGroup</code> 了。</p><p>这个第二个修改方式：将匿名函数中的 wg 的传入参数去掉，因为 Go 支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量.</p><ul><li>在 Go 1.7 以后引进的强大的 Context 上下文，实现并发控制.</li></ul><p>通常，在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 <code>channel</code> 和 <code>WaitGroup</code> 显得有些力不从心了。</p><p>比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和 RPC 服务。</p><p>所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是 Go 语言为我们提供的 Context，称之为上下文非常贴切，它就是 goroutine 的上下文。</p><p>它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常 Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。</p><p>context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。</p><p>context 包的核心是 struct Context，接口声明如下：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// A Context carries a deadline, cancelation signal, and request-scoped values</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// goroutines.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">type</span> Context <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// Done returns a channel that is closed when this `Context` is canceled</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// or times out.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// Done () 返回一个只能接受数据的 channel 类型，当该 context 关闭或者超时时间到了的时候，该 channel 就会有一个取消信号</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// Err indicates why this Context was canceled, after the Done channel</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// is closed.</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// Err () 在 Done () 之后，返回 context 取消的原因。</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">Err</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// Deadline returns the time when this Context will be canceled, if any.</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// Deadline () 设置该 context cancel 的时间点</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">Deadline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>deadline time<span class=\"token punctuation\">.</span>Time<span class=\"token punctuation\">,</span> ok <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// Value returns the value associated with key or nil if none.</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// Value () 方法允许 Context 对象携带 request 作用域的数据，该数据必须是线程安全的。</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">Value</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行取消操作时，所有 goroutine 都会接收到取消信号。</p><p>一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。</p><p>典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。</p><ol start=\"5\"><li><h4 id=\"go中对nil的slice和空slice的处理是一致的吗\"><a class=\"anchor\" href=\"#go中对nil的slice和空slice的处理是一致的吗\">#</a> Go 中对 nil 的 Slice 和空 Slice 的处理是一致的吗</h4></li></ol><p>首先 Go 的 JSON 标准库对 <code>nil slice</code> 和 空 <code>slice</code> 的处理是不一致.</p><p>通常错误的用法，会报数组越界的错误，因为只是声明了 slice，却没有给实例化的对象。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">var</span> slice <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>slice<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr></table></figure><p>此时 slice 的值是 nil，这种情况可以用于需要返回 slice 的函数，当函数出现异常的时候，保证函数依然会有 nil 的返回值。</p><p><code>empty slice</code> 是指 slice 不为 nil，但是 slice 没有值，slice 的底层的空间是空的，此时的定义如下：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>slice <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span>）</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>slice <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。</p><p>总之， <code>nil slice</code> 和 <code>empty slice</code> 是不同的东西，需要我们加以区分的.</p><ol start=\"6\"><li><h4 id=\"协程和线程和进程的区别\"><a class=\"anchor\" href=\"#协程和线程和进程的区别\">#</a> 协程和线程和进程的区别</h4></li></ol><ul><li>进程</li></ul><p>进程是程序的一次执行过程，是程序在执行过程中的分配和管理资源的基本单位，每个进程都有自己的地址空间，进程是系统进行资源分配和调度的一个独立单位。</p><p>每个进程都有自己的独立内存空间，不同进程通过 IPC（Inter-Process Communication）进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><ul><li>线程</li></ul><p>线程是进程的一个实体，线程是内核态，而且是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源 (如程序计数器，一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><ul><li>协程</li></ul><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。</p><p>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><ol start=\"7\"><li><h4 id=\"golang的内存模型中为什么小对象多了会造成gc压力\"><a class=\"anchor\" href=\"#golang的内存模型中为什么小对象多了会造成gc压力\">#</a> Golang 的内存模型中为什么小对象多了会造成 GC 压力</h4></li></ol><p>通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配.</p><ol start=\"8\"><li><h4 id=\"go中数据竞争问题怎么解决\"><a class=\"anchor\" href=\"#go中数据竞争问题怎么解决\">#</a> Go 中数据竞争问题怎么解决</h4></li></ol><p><code>Data Race</code> 问题可以使用互斥锁 <code>sync.Mutex</code> , 或者也可以通过 CAS 无锁并发解决。其中使用同步访问共享数据或者 CAS 无锁并发是处理数据竞争的一种有效的方法.</p><p>golang 在 1.1 之后引入了竞争检测机制，可以使用 <code>go run -race</code> 或者 <code>go build -race</code> 来进行静态检测。 其在内部的实现是，开启多个协程执行同一个命令， 并且记录下每个变量的状态.<br>竞争检测器基于 C/C++ 的 <code>ThreadSanitizer</code> 运行时库，该库在 Google 内部代码基地和 Chromium 找到许多错误。这个技术在 2012 年九月集成到 Go 中，从那时开始，它已经在标准库中检测到 42 个竞争条件。现在，它已经是我们持续构建过程的一部分，当竞争条件出现时，它会继续捕捉到这些错误。<br>竞争检测器已经完全集成到 Go 工具链中，仅仅添加 - race 标志到命令行就使用了检测器。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ <span class=\"token keyword\">go</span> test <span class=\"token operator\">-</span>race mypkg    <span class=\"token comment\">// 测试包</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>$ <span class=\"token keyword\">go</span> run <span class=\"token operator\">-</span>race mysrc<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span>  <span class=\"token comment\">// 编译和运行程序</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>$ <span class=\"token keyword\">go</span> build <span class=\"token operator\">-</span>race mycmd   <span class=\"token comment\">// 构建程序</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>$ <span class=\"token keyword\">go</span> install <span class=\"token operator\">-</span>race mypkg <span class=\"token comment\">// 安装程序</span></pre></td></tr></table></figure><p>要想解决数据竞争的问题可以使用互斥锁 <code>sync.Mutex</code> , 解决数据竞争 (Data race), 也可以使用管道解决，使用管道的效率要比互斥锁高.</p><ol start=\"9\"><li><h4 id=\"什么是channel为什么它可以做到线程安全\"><a class=\"anchor\" href=\"#什么是channel为什么它可以做到线程安全\">#</a> 什么是 channel，为什么它可以做到线程安全</h4></li></ol><p>Channel 是 Go 中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯 (communication),Channel 也可以理解是一个先进先出的队列，通过管道进行通信。</p><p>Golang 的 Channel, 发送一个数据到 Channel 和从 Channel 接收一个数据都是原子性的。</p><p>Go 的设计思想就是，不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是 Channel。也就是说，设计 Channel 的主要目的就是在多任务间传递数据的，本身就是安全的。</p><ol start=\"10\"><li><h4 id=\"golang垃圾回收算法\"><a class=\"anchor\" href=\"#golang垃圾回收算法\">#</a> Golang 垃圾回收算法</h4></li></ol><p>首先我们先来了解下什么是垃圾回收。</p><p>什么是垃圾回收？</p><p>内存管理是程序员开发应用的一大难题。传统的系统级编程语言（主要指 C/C++）中，程序开发者必须对内存小心的进行管理操作，控制内存的申请及释放。因为稍有不慎，就可能产生内存泄露问题，这种问题不易发现并且难以定位，一直成为困扰程序开发者的噩梦。</p><p>如何解决这个头疼的问题呢？</p><p>过去一般采用两种办法:</p><ul><li><p>内存泄露检测工具。这种工具的原理一般是静态代码扫描，通过扫描程序检测可能出现内存泄露的代码段。然而检测工具难免有疏漏和不足，只能起到辅助作用。</p></li><li><p>智能指针。这是 c++ 中引入的自动内存管理方法，通过拥有自动内存管理功能的指针对象来引用对象，是程序员不用太关注内存的释放，而达到内存自动释放的目的。这种方法是采用最广泛的做法，但是对程序开发者有一定的学习成本（并非语言层面的原生支持），而且一旦有忘记使用的场景依然无法避免内存泄露。</p></li></ul><p>为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php 等等）都引入了语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。</p><p>常用的垃圾回收的方法:</p><ul><li>引用计数（reference counting）</li></ul><p>这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为 0 时则立即回收对象。</p><p>这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如 <code>ios cocoa</code> 框架，php，python 等。</p><p>但是简单引用计数算法也有明显的缺点：</p><ol><li>频繁更新引用计数降低了性能。</li></ol><p>一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到 0 时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。</p><ol start=\"2\"><li>循环引用。</li></ol><p>当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如 cocoa 引入了 strong 指针和 weak 指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。</p><ul><li>标记 - 清除（mark and sweep）</li></ul><p>标记 - 清除（mark and sweep）分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为 “被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。</p><p>这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收时，系统响应能力大大降低！当然后续也出现了很多 <code>mark&amp;sweep</code> 算法的变种（如三色标记法）优化了这个问题。</p><ul><li>分代搜集（generation）</li></ul><p>java 的 jvm 就使用的分代回收的思路。在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为代（generation）的空间。<br>新创建的对象存放在称为新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被提升（promotion）到老年代中（这里用到了一个分类的思路，这个是也是科学思考的一个基本思路）。</p><p>因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。</p><p>Golang GC 时会发生什么？</p><p><code>Golang 1.5</code> 后，采取的是 “非分代的、非移动的、并发的、三色的” 标记清除垃圾回收算法。</p><p>golang 中的 gc 基本上是标记清除的过程：</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0tlS2UtTGkvRm9yLWxlYXJuaW5nLUdvLVR1dG9yaWFsL2Jsb2IvbWFzdGVyL3NyYy9pbWFnZXMvMi5qcGc=\">https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/images/2.jpg</span>&quot; /&gt;<br>&lt;/p&gt;</p><p>golang 的垃圾回收是基于标记清扫算法，这种算法需要进行 STW（stop the world)，这个过程就会导致程序是卡顿的，频繁的 GC 会严重影响程序性能.</p><p>golang 在此基础上进行了改进，通过三色标记清扫法与写屏障来减少 STW 的时间.</p><p>gc 的过程一共分为四个阶段：</p><ol><li>栈扫描（开始时 STW），所有对象最开始都是白色.</li><li>从 root 开始找到所有可达对象（所有可以找到的对象)，标记为灰色，放入待处理队列。</li><li>遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色。</li><li>清除（并发） 循环步骤 3 直到灰色队列为空为止，此时所有引用对象都被标记为黑色，所有不可达的对象依然为白色，白色的就是需要进行回收的对象。<br>三色标记法相对于普通标记清扫，减少了 STW 时间。这主要得益于标记过程是 &quot;on-the-fly&quot; 的，在标记过程中是不需要 STW 的，它与程序是并发执行的，这就大大缩短了 STW 的时间.</li></ol><p>Golang gc 优化的核心就是尽量使得 STW (Stop The World) 的时间越来越短。</p><p>详细的 Golang 的 GC 介绍可以参看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0tlS2UtTGkvRm9yLWxlYXJuaW5nLUdvLVR1dG9yaWFsL2Jsb2IvbWFzdGVyL3NyYy9zcGVjLzAyLjAubWQ=\"> Golang 垃圾回收</span>.</p><p>写屏障:</p><p>当标记和程序是并发执行的，这就会造成一个问题。在标记过程中，有新的引用产生，可能会导致误清扫.</p><p>清扫开始前，标记为黑色的对象引用了一个新申请的对象，它肯定是白色的，而黑色对象不会被再次扫描，那么这个白色对象无法被扫描变成灰色、黑色，它就会最终被清扫，而实际它不应该被清扫.</p><p>这就需要用到屏障技术，golang 采用了写屏障，其作用就是为了避免这类误清扫问题。写屏障即在内存写操作前，维护一个约束，从而确保清扫开始前，黑色的对象不能引用白色对象.</p><ol start=\"11\"><li><h4 id=\"gc的触发条件\"><a class=\"anchor\" href=\"#gc的触发条件\">#</a> GC 的触发条件</h4></li></ol><p>Go 中对 GC 的触发时机存在两种形式：</p><ul><li>主动触发 (手动触发)，通过调用 <code>runtime.GC</code> 来触发 <code>GC</code> ，此调用阻塞式地等待当前 <code>GC</code> 运行完毕.</li><li>被动触发，分为两种方式：<br>a. 使用系统监控，当超过两分钟没有产生任何 <code>GC</code> 时，强制触发 <code>GC</code> .<br>b. 使用步调（Pacing）算法，其核心思想是控制内存增长的比例，当前内存分配达到一定比例则触发.</li></ul><ol start=\"12\"><li><h4 id=\"go的gpm如何调度\"><a class=\"anchor\" href=\"#go的gpm如何调度\">#</a> Go 的 GPM 如何调度</h4></li></ol><p>Goroutine 协程:</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。<br>因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p><p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine 也是协程。</p><p>groutine 能拥有强大的并发实现是通过 GPM 调度模型实现.</p><p>Go 的调度器内部有四个重要的结构：M，P，S，Sched，如上图所示（Sched 未给出）.</p><ul><li>M: M 代表内核级线程，一个 M 就是一个线程，goroutine 就是跑在 M 之上的；M 是一个很大的结构，里面维护小对象内存 cache（mcache）、当前执行的 goroutine、随机数发生器等等非常多的信息.</li><li>G: 代表一个 goroutine，它有自己的栈，instruction pointer 和其他信息（正在等待的 channel 等等），用于调度.</li><li>P: P 全称是 Processor，逻辑处理器，它的主要用途就是用来执行 goroutine 的，所以它也维护了一个 goroutine 队列，里面存储了所有需要它来执行的 goroutine.</li><li>Sched：代表调度器，它维护有存储 M 和 G 的队列以及调度器的一些状态信息等.</li></ul><p>Go 中的 GPM 调度:</p><p>新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中，最终等待被逻辑处理器 P 执行即可。</p><p>在 M 与 P 绑定后，M 会不断从 P 的 Local 队列中无锁地取出 G，并切换到 G 的堆栈执行，当 P 的 Local 队列中没有 G 时，再从 Global 队列中获取一个 G，当 Global 队列中也没有待运行的 G 时，则尝试从其它的 P 窃取部分 G 来执行相当于 P 之间的负载均衡。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/65.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>从上图中可以看到，有 2 个物理线程 M，每一个 M 都拥有一个处理器 P，每一个也都有一个正在运行的 goroutine。P 的数量可以通过 GOMAXPROCS () 来设置，它其实也就代表了真正的并发度，即有多少个 goroutine 可以同时运行。</p><p>图中灰色的那些 goroutine 并没有运行，而是出于 ready 的就绪态，正在等待被调度。P 维护着这个队列（称之为 runqueue），Go 语言里，启动一个 goroutine 很容易：go function 就行，所以每有一个 go 语句被执行，runqueue 队列就在其末尾加入一个 goroutine，在下一个调度点，就从 runqueue 中取出（如何决定取哪个 goroutine？）一个 goroutine 执行。</p><p>当一个 OS 线程 M0 陷入阻塞时，P 转而在运行 M1，图中的 M1 可能是正被创建，或者从线程缓存中取出。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/60.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>当 M0 返回时，它必须尝试取得一个 P 来运行 goroutine，一般情况下，它会从其他的 OS 线程那里拿一个 P 过来，如果没有拿到的话，它就把 goroutine 放在一个 <code>global runqueue</code> 里，然后自己睡眠（放入线程缓存里）。所有的 P 也会周期性的检查 <code>global runqueue</code> 并运行其中的 goroutine，否则 <code>global runqueue</code> 上的 goroutine 永远无法执行。</p><p>另一种情况是 P 所分配的任务 G 很快就执行完了（分配不均），这就导致了这个处理器 P 处于空闲的状态，但是此时其他的 P 还有任务，此时如果 global runqueue 没有任务 G 了，那么这个 P 就会从其他的 P 里偷取一些 G 来执行。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/64.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>通常来说，如果 P 从其他的 P 那里要拿任务的话，一般就拿 <code>run queue</code> 的一半，这就确保了每个 OS 线程都能充分的使用。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/129.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ol start=\"13\"><li><h4 id=\"并发编程概念是什么\"><a class=\"anchor\" href=\"#并发编程概念是什么\">#</a> 并发编程概念是什么</h4></li></ol><p>并行是指两个或者多个事件在同一时刻发生；并发是指两个或多个事件在同一时间间隔发生。</p><p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。在一台处理器上 “同时” 处理多个任务，在多台处理器上同时处理多个任务。如 hadoop 分布式集群</p><p>并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的 “同时执行”。</p><p>并发编程是指在一台处理器上 “同时” 处理多个任务。并发是在同一实体上的多个事件。多个事件在同一时间间隔发生。并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><ol start=\"14\"><li><h4 id=\"go语言的栈空间管理是怎么样的\"><a class=\"anchor\" href=\"#go语言的栈空间管理是怎么样的\">#</a> Go 语言的栈空间管理是怎么样的</h4></li></ol><p>Go 语言的运行环境（runtime）会在 goroutine 需要的时候动态地分配栈空间，而不是给每个 goroutine 分配固定大小的内存空间。这样就避免了需要程序员来决定栈的大小。</p><p>分块式的栈是最初 Go 语言组织栈的方式。当创建一个 goroutine 的时候，它会分配一个 8KB 的内存空间来给 goroutine 的栈使用。我们可能会考虑当这 8KB 的栈空间被用完的时候该怎么办？</p><p>为了处理这种情况，每个 Go 函数的开头都有一小段检测代码。这段代码会检查我们是否已经用完了分配的栈空间。如果是的话，它会调用 <code>morestack</code> 函数。 <code>morestack</code> 函数分配一块新的内存作为栈空间，并且在这块栈空间的底部填入各种信息（包括之前的那块栈地址）。在分配了这块新的栈空间之后，它会重试刚才造成栈空间不足的函数。这个过程叫做栈分裂（stack split）。</p><p>在新分配的栈底部，还插入了一个叫做 <code>lessstack</code> 的函数指针。这个函数还没有被调用。这样设置是为了从刚才造成栈空间不足的那个函数返回时做准备的。当我们从那个函数返回时，它会跳转到 <code>lessstack</code> 。 <code>lessstack</code> 函数会查看在栈底部存放的数据结构里的信息，然后调整栈指针（stack pointer）。这样就完成了从新的栈块到老的栈块的跳转。接下来，新分配的这个块栈空间就可以被释放掉了。</p><p><code>分块式的栈</code> 让我们能够按照需求来扩展和收缩栈的大小。 Go 开发者不需要花精力去估计 goroutine 会用到多大的栈。创建一个新的 goroutine 的开销也不大。当 Go 开发者不知道栈会扩展到多少大时，它也能很好的处理这种情况。</p><p>这一直是之前 Go 语言管理栈的的方法。但这个方法有一个问题。缩减栈空间是一个开销相对较大的操作。如果在一个循环里有栈分裂，那么它的开销就变得不可忽略了。一个函数会扩展，然后分裂栈。当它返回的时候又会释放之前分配的内存块。如果这些都发生在一个循环里的话，代价是相当大的。</p><p>这就是所谓的热分裂问题（hot split problem）。它是 Go 语言开发者选择新的栈管理方法的主要原因。新的方法叫做 <code>栈复制法（stack copying）</code> 。</p><p>栈复制法一开始和分块式的栈很像。当 goroutine 运行并用完栈空间的时候，与之前的方法一样，栈溢出检查会被触发。但是，不像之前的方法那样分配一个新的内存块并链接到老的栈内存块，新的方法会分配一个两倍大的内存块并把老的内存块内容复制到新的内存块里。这样做意味着当栈缩减回之前大小时，我们不需要做任何事情。栈的缩减没有任何代价。而且，当栈再次扩展时，运行环境也不需要再做任何事。它可以重用之前分配的空间。</p><p>栈的复制听起来很容易，但实际操作并非那么简单。存储在栈上的变量的地址可能已经被使用到。也就是说程序使用到了一些指向栈的指针。当移动栈的时候，所有指向栈里内容的指针都会变得无效。然而，指向栈内容的指针自身也必定是保存在栈上的。这是为了保证内存安全的必要条件。否则一个程序就有可能访问一段已经无效的栈空间了。</p><p>因为垃圾回收的需要，我们必须知道栈的哪些部分是被用作指针了。当我们移动栈的时候，我们可以更新栈里的指针让它们指向新的地址。所有相关的指针都会被更新。我们使用了垃圾回收的信息来复制栈，但并不是任何使用栈的函数都有这些信息。因为很大一部分运行环境是用 C 语言写的，很多被调用的运行环境里的函数并没有指针的信息，所以也就不能够被复制了。当遇到这种情况时，我们只能退回到分块式的栈并支付相应的开销。</p><p>这也是为什么现在运行环境的开发者正在用 Go 语言重写运行环境的大部分代码。无法用 Go 语言重写的部分（比如调度器的核心代码和垃圾回收器）会在特殊的栈上运行。这个特殊栈的大小由运行环境的开发者设置。</p><p>这些改变除了使栈复制成为可能，它也允许我们在将来实现并行垃圾回收。</p><p>另外一种不同的栈处理方式就是在虚拟内存中分配大内存段。由于物理内存只是在真正使用时才会被分配，因此看起来好似你可以分配一个大内存段并让操 作系统处理它。下面是这种方法的一些问题</p><p>首先，32 位系统只能支持 4G 字节虚拟内存，并且应用只能用到其中的 3G 空间。由于同时运行百万 goroutines 的情况并不少见，因此你很可 能用光虚拟内存，即便我们假设每个 goroutine 的 stack 只有 8K。</p><p>第二，然而我们可以在 64 位系统中分配大内存，它依赖于过量内存使用。所谓过量使用是指当你分配的内存大小超出物理内存大小时，依赖操作系统保证 在需要时能够分配出物理内存。然而，允许过量使用可能会导致一些风险。由于一些进程分配了超出机器物理内存大小的内存，如果这些进程使用更多内存 时，操作系统将不得不为它们补充分配内存。这会导致操作系统将一些内存段放入磁盘缓存，这常常会增加不可预测的处理延迟。正是考虑到这个原因，一 些新系统关闭了对过量使用的支持。</p><ol start=\"15\"><li><h4 id=\"goroutine和channel的作用分别是什么\"><a class=\"anchor\" href=\"#goroutine和channel的作用分别是什么\">#</a> Goroutine 和 Channel 的作用分别是什么</h4></li></ol><p>进程是内存资源管理和 cpu 调度的执行单元。为了有效利用多核处理器的优势，将进程进一步细分，允许一个进程里存在多个线程，这多个线程还是共享同一片内存空间，但 cpu 调度的最小单元变成了线程。</p><p>那协程又是什么呢，以及与线程的差异性？</p><p>协程，可以看作是轻量级的线程。但与线程不同的是，线程的切换是由操作系统控制的，而协程的切换则是由用户控制的。</p><p>最早支持协程的程序语言应该是 lisp 方言 scheme 里的 continuation（续延）, 续延允许 scheme 保存任意函数调用的现场，保存起来并重新执行。Lua,C#,python 等语言也有自己的协程实现。</p><p>Go 中的 goroutinue 就是协程，可以实现并行，多个协程可以在多个处理器同时跑。而协程同一时刻只能在一个处理器上跑（可以把宿主语言想象成单线程的就好了）。<br>然而，多个 goroutine 之间的通信是通过 channel，而协程的通信是通过 yield 和 resume () 操作。</p><p>goroutine 非常简单，只需要在函数的调用前面加关键字 go 即可，例如:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">go</span> <span class=\"token function\">elegance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>我们也可以启动 5 个 goroutines 分别打印索引:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre> <span class=\"token comment\">// 停歇 5s，保证打印全部结束</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre> time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token operator\">*</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在分析 goroutine 执行的随机性和并发性，启动了 5 个 goroutine，再加上 main 函数的主 goroutine，总共有 6 个 goroutines。由于 goroutine 类似于” 守护线程 “，异步执行的，如果主 goroutine 不等待片刻，可能程序就没有输出打印了。</p><p>在 Golang 中 channel 则是 goroutinues 之间进行通信的渠道。</p><p>可以把 channel 形象比喻为工厂里的传送带，一头的生产者 goroutine 往传输带放东西，另一头的消费者 goroutinue 则从输送带取东西。channel 实际上是一个有类型的消息队列，遵循先进先出的特点。</p><ol><li>channel 的操作符号</li></ol><p><code>ch &lt;- data</code> 表示 data 被发送给 <code>channel ch</code> ；</p><p><code>data &lt;- ch</code> 表示从 <code>channel ch</code> 取一个值，然后赋给 data。</p><ol start=\"2\"><li>阻塞式 channel</li></ol><p>channel 默认是没有缓冲区的，也就是说，通信是阻塞的。send 操作必须等到有消费者 accept 才算完成。</p><p>应用示例:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> ch1 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> <span class=\"token keyword\">go</span> <span class=\"token function\">pump</span><span class=\"token punctuation\">(</span>ch1<span class=\"token punctuation\">)</span> <span class=\"token comment\">// pump hangs</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;-</span>ch1<span class=\"token punctuation\">)</span> <span class=\"token comment\">// prints only 1</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">pump</span><span class=\"token punctuation\">(</span>ch <span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre> <span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    ch <span class=\"token operator\">&lt;-</span> i</pre></td></tr><tr><td data-num=\"10\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在函数 <code>pump()</code> 里的 channel 在接受到第一个元素后就被阻塞了，直到主 goroutinue 取走了数据。最终 channel 阻塞在接受第二个元素，程序只打印 1。</p><p>没有缓冲 (buffer) 的 channel 只能容纳一个元素，而带有缓冲 (buffer) channel 则可以非阻塞容纳 N 个元素。发送数据到缓冲 (buffer) channel 不会被阻塞，除非 channel 已满；同样的，从缓冲 (buffer) channel 取数据也不会被阻塞，除非 channel 空了。</p><ol start=\"16\"><li><h4 id=\"怎么查看goroutine的数量\"><a class=\"anchor\" href=\"#怎么查看goroutine的数量\">#</a> 怎么查看 Goroutine 的数量</h4></li></ol><p>在 Golang 中， <code>GOMAXPROCS</code> 中控制的是未被阻塞的所有 Goroutine, 可以被 <code>Multiplex</code> 到多少个线程上运行，通过 <code>GOMAXPROCS</code> 可以查看 Goroutine 的数量。</p><ol start=\"17\"><li><h4 id=\"go中的锁有哪些\"><a class=\"anchor\" href=\"#go中的锁有哪些\">#</a> Go 中的锁有哪些</h4></li></ol><p>Go 中的三种锁包括：互斥锁，读写锁， <code>sync.Map</code> 的安全的锁.</p><ul><li>互斥锁</li></ul><p>Go 并发程序对共享资源进行访问控制的主要手段，由标准库代码包中 sync 中的 Mutex 结构体表示。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// Mutex 是互斥锁， 零值是解锁的互斥锁， 首次使用后不得复制互斥锁。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">type</span> Mutex <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    state <span class=\"token builtin\">int32</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    sema  <span class=\"token builtin\">uint32</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>sync.Mutex 包中的类型只有两个公开的指针方法 Lock 和 Unlock。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// Locker 表示可以锁定和解锁的对象。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">type</span> Locker <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 锁定当前的互斥量</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 如果锁已被使用，则调用 goroutine</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 阻塞直到互斥锁可用。</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// 对当前互斥量进行解锁</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 如果在进入解锁时未锁定 m，则为运行时错误。</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">// 锁定的互斥锁与特定的 goroutine 无关。</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">// 允许一个 goroutine 锁定 Mutex 然后安排另一个 goroutine 来解锁它。</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>声明一个互斥锁：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">var</span> mutex sync<span class=\"token punctuation\">.</span>Mutex</pre></td></tr></table></figure><p>不像 C 或 Java 的锁类工具，我们可能会犯一个错误：忘记及时解开已被锁住的锁，从而导致流程异常。但 Go 由于存在 defer，所以此类问题出现的概率极低。关于 defer 解锁的方式如下：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">var</span> mutex sync<span class=\"token punctuation\">.</span>Mutex</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">Write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   mutex<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token keyword\">defer</span> mutex<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果对一个已经上锁的对象再次上锁，那么就会导致该锁定操作被阻塞，直到该互斥锁回到被解锁状态.</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>fpackage main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token string\">\"time\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">var</span> mutex sync<span class=\"token punctuation\">.</span>Mutex</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"begin lock\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get locked\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"begin lock \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\tmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get locked \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Unlock the lock\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\tmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get unlocked\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们在 for 循环之前开始加锁，然后在每一次循环中创建一个协程，并对其加锁，但是由于之前已经加锁了，所以这个 for 循环中的加锁会陷入阻塞直到 main 中的锁被解锁， time.Sleep (time.Second) 是为了能让系统有足够的时间运行 for 循环，输出结果如下：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token keyword\">go</span> run mutex<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>begin lock</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>get locked</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>begin lock  <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>begin lock  <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>begin lock  <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>Unlock the lock</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>get unlocked</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>get locked  <span class=\"token number\">3</span></pre></td></tr></table></figure><p>这里可以看到解锁后，三个协程会重新抢夺互斥锁权，最终协程 3 获胜。</p><p>互斥锁锁定操作的逆操作并不会导致协程阻塞，但是有可能导致引发一个无法恢复的运行时的 panic，比如对一个未锁定的互斥锁进行解锁时就会发生 panic。避免这种情况的最有效方式就是使用 defer。</p><p>我们知道如果遇到 panic，可以使用 recover 方法进行恢复，但是如果对重复解锁互斥锁引发的 panic 却是无用的（Go 1.8 及以后）。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Try to recover the panic\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> p <span class=\"token operator\">:=</span> <span class=\"token function\">recover</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> p <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"recover the panic : \"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token keyword\">var</span> mutex sync<span class=\"token punctuation\">.</span>Mutex</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"begin lock\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\tmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get locked\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unlock lock\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\tmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lock is unlocked\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unlock lock again\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\tmutex<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token keyword\">go</span> run mutex<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>begin lock</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>get locked</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>unlock lock</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>lock is unlocked</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>unlock lock again</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>fatal <span class=\"token builtin\">error</span><span class=\"token punctuation\">:</span> sync<span class=\"token punctuation\">:</span> unlock of unlocked mutex</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>goroutine <span class=\"token number\">1</span> <span class=\"token punctuation\">[</span>running<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>runtime<span class=\"token punctuation\">.</span><span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x4bc1a8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x1e</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>runtime<span class=\"token operator\">/</span><span class=\"token builtin\">panic</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">617</span> <span class=\"token operator\">+</span><span class=\"token number\">0x72</span> fp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084ea8</span> sp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084e78</span> pc<span class=\"token operator\">=</span><span class=\"token number\">0x427ba2</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>sync<span class=\"token punctuation\">.</span><span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x4bc1a8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0x1e</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>runtime<span class=\"token operator\">/</span><span class=\"token builtin\">panic</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">603</span> <span class=\"token operator\">+</span><span class=\"token number\">0x35</span> fp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084ec8</span> sp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084ea8</span> pc<span class=\"token operator\">=</span><span class=\"token number\">0x427b25</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>sync<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xc00001a0c8</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>     <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>sync<span class=\"token operator\">/</span>mutex<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">184</span> <span class=\"token operator\">+</span><span class=\"token number\">0xc1</span> fp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084ef0</span> sp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084ec8</span> pc<span class=\"token operator\">=</span><span class=\"token number\">0x45f821</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>main<span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>Test<span class=\"token operator\">/</span>mutex<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">25</span> <span class=\"token operator\">+</span><span class=\"token number\">0x25f</span> fp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084f98</span> sp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084ef0</span> pc<span class=\"token operator\">=</span><span class=\"token number\">0x486c1f</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>runtime<span class=\"token punctuation\">.</span><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>runtime<span class=\"token operator\">/</span>proc<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span> <span class=\"token operator\">+</span><span class=\"token number\">0x20c</span> fp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084fe0</span> sp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084f98</span> pc<span class=\"token operator\">=</span><span class=\"token number\">0x4294ec</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>runtime<span class=\"token punctuation\">.</span><span class=\"token function\">goexit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>     <span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>keke<span class=\"token operator\">/</span>soft<span class=\"token operator\">/</span><span class=\"token keyword\">go</span><span class=\"token operator\">/</span>src<span class=\"token operator\">/</span>runtime<span class=\"token operator\">/</span>asm_amd64<span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">:</span><span class=\"token number\">1337</span> <span class=\"token operator\">+</span><span class=\"token number\">0x1</span> fp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084fe8</span> sp<span class=\"token operator\">=</span><span class=\"token number\">0xc000084fe0</span> pc<span class=\"token operator\">=</span><span class=\"token number\">0x450ad1</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>exit status <span class=\"token number\">2</span></pre></td></tr></table></figure><p>这里试图对重复解锁引发的 panic 进行 recover，但是我们发现操作失败，虽然互斥锁可以被多个协程共享，但还是建议将对同一个互斥锁的加锁解锁操作放在同一个层次的代码中。</p><ul><li>读写锁</li></ul><p>读写锁是针对读写操作的互斥锁，可以分别针对读操作与写操作进行锁定和解锁操作 。</p><p>读写锁的访问控制规则如下：</p><ol><li>多个写操作之间是互斥的.</li><li>写操作与读操作之间也是互斥的.</li><li>多个读操作之间不是互斥的.</li></ol><p>在这样的控制规则下，读写锁可以大大降低性能损耗。</p><p>在 Go 的标准库代码包中 sync 中的 RWMutex 结构体表示为:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// RWMutex 是一个读 / 写互斥锁，可以由任意数量的读操作或单个写操作持有。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// RWMutex 的零值是未锁定的互斥锁。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 首次使用后，不得复制 RWMutex。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 如果 goroutine 持有 RWMutex 进行读取而另一个 goroutine 可能会调用 Lock，那么在释放初始读锁之前，goroutine 不应该期望能够获取读锁定。 </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 特别是，这种禁止递归读锁定。 这是为了确保锁最终变得可用；阻止的锁定会阻止新读操作获取锁定。</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">type</span> RWMutex <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     w           Mutex  <span class=\"token comment\">// 如果有待处理的写操作就持有</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     writerSem   <span class=\"token builtin\">uint32</span> <span class=\"token comment\">// 写操作等待读操作完成的信号量</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     readerSem   <span class=\"token builtin\">uint32</span> <span class=\"token comment\">// 读操作等待写操作完成的信号量</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     readerCount <span class=\"token builtin\">int32</span>  <span class=\"token comment\">// 待处理的读操作数量</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     readerWait  <span class=\"token builtin\">int32</span>  <span class=\"token comment\">// number of departing readers</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>sync 中的 RWMutex 有以下几种方法：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 对读操作的锁定</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 对读操作的解锁</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 对写操作的锁定</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 对写操作的解锁</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">// 返回一个实现了 sync.Locker 接口类型的值，实际上是回调 rw.RLock and rw.RUnlock.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RLocker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Locker</pre></td></tr></table></figure><p>Unlock 方法会试图唤醒所有想进行读锁定而被阻塞的协程，而 RUnlock 方法只会在已无任何读锁定的情况下，试图唤醒一个因欲进行写锁定而被阻塞的协程。</p><p>若对一个未被写锁定的读写锁进行写解锁，就会引发一个不可恢复的 panic，同理对一个未被读锁定的读写锁进行读写锁也会如此。</p><p>由于读写锁控制下的多个读操作之间不是互斥的，因此对于读解锁更容易被忽视。对于同一个读写锁，添加多少个读锁定，就必要有等量的读解锁，这样才能其他协程有机会进行操作。</p><p>因此 Go 中读写锁，在多个读线程可以同时访问共享数据，写线程必须等待所有读线程都释放锁以后，才能取得锁。同样的，读线程必须等待写线程释放锁后，才能取得锁，也就是说读写锁要确保的是如下互斥关系，可以同时读，但是读 - 写，写 - 写都是互斥的。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token string\">\"time\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">var</span> rwm sync<span class=\"token punctuation\">.</span>RWMutex</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"try to lock read \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        rwm<span class=\"token punctuation\">.</span><span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get locked \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"try to unlock for reading \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        rwm<span class=\"token punctuation\">.</span><span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unlocked for reading \"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre> time<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Millisecond <span class=\"token operator\">*</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"try to lock for writing\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre> rwm<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"locked for writing\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token keyword\">go</span> run rwmutex<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>try to lock read  <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>get locked  <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>try to lock read  <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>get locked  <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>try to lock read  <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>get locked  <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>try to lock read  <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>get locked  <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>try to lock read  <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>get locked  <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>try to lock <span class=\"token keyword\">for</span> writing</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>try to unlock <span class=\"token keyword\">for</span> reading  <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>unlocked <span class=\"token keyword\">for</span> reading  <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>try to unlock <span class=\"token keyword\">for</span> reading  <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>unlocked <span class=\"token keyword\">for</span> reading  <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>try to unlock <span class=\"token keyword\">for</span> reading  <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>unlocked <span class=\"token keyword\">for</span> reading  <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>try to unlock <span class=\"token keyword\">for</span> reading  <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>unlocked <span class=\"token keyword\">for</span> reading  <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>try to unlock <span class=\"token keyword\">for</span> reading  <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>unlocked <span class=\"token keyword\">for</span> reading  <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>locked <span class=\"token keyword\">for</span> writing</pre></td></tr></table></figure><p>这里可以看到创建了五个协程用于对读写锁的读锁定与读解锁操作。在 <code>rwm.Lock()</code> 种会对 main 中协程进行写锁定，但是 for 循环中的读解锁尚未完成，因此会造成 main 中的协程阻塞。当 for 循环中的读解锁操作都完成后就会试图唤醒 main 中阻塞的协程，main 中的写锁定才会完成。</p><ul><li>sync.Map 安全锁</li></ul><p>golang 中的 <code>sync.Map</code> 是并发安全的，其实也就是 sync 包中 golang 自定义的一个名叫 Map 的结构体。</p><p>应用示例:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre> <span class=\"token comment\">// 开箱即用</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre> <span class=\"token keyword\">var</span> sm sync<span class=\"token punctuation\">.</span>Map</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre> <span class=\"token comment\">//store 方法，添加元素</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre> sm<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre> <span class=\"token comment\">// Load 方法，获得 value</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre> <span class=\"token keyword\">if</span> v<span class=\"token punctuation\">,</span>ok<span class=\"token operator\">:=</span>sm<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>ok<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre> <span class=\"token comment\">// LoadOrStore 方法，获取或者保存</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre> <span class=\"token comment\">// 参数是一对 key：value，如果该 key 存在且没有被标记删除则返回原先的 value（不更新）和 true；不存在则 store，返回该 value 和 false</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre> <span class=\"token keyword\">if</span> vv<span class=\"token punctuation\">,</span>ok<span class=\"token operator\">:=</span>sm<span class=\"token punctuation\">.</span><span class=\"token function\">LoadOrStore</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>ok<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>vv<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre> </pre></td></tr><tr><td data-num=\"27\"></td><td><pre> <span class=\"token keyword\">if</span> vv<span class=\"token punctuation\">,</span>ok<span class=\"token operator\">:=</span>sm<span class=\"token punctuation\">.</span><span class=\"token function\">LoadOrStore</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">!</span>ok<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>vv<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre> <span class=\"token comment\">// 遍历该 map，参数是个函数，该函数参的两个参数是遍历获得的 key 和 value，返回一个 bool 值，当返回 false 时，遍历立刻结束。</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre> sm<span class=\"token punctuation\">.</span><span class=\"token function\">Range</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">,</span>v <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>     fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>     <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行 :</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>a</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>c</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>a</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">2</span><span class=\"token punctuation\">:</span>c</pre></td></tr></table></figure><p>sync.Map 的数据结构:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> Map <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token comment\">// 该锁用来保护 dirty</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> mu Mutex</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token comment\">// 存读的数据，因为是 atomic.value 类型，只读类型，所以它的读是并发安全的</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> read atomic<span class=\"token punctuation\">.</span>Value <span class=\"token comment\">// readOnly</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token comment\">// 包含最新的写入的数据，并且在写的时候，会把 read 中未被删除的数据拷贝到该 dirty 中，因为是普通的 map 存在并发安全问题，需要用到上面的 mu 字段。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre> dirty <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>entry</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> <span class=\"token comment\">// 从 read 读数据的时候，会将该字段 + 1，当等于 len（dirty）的时候，会将 dirty 拷贝到 read 中（从而提升读的性能）。</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre> misses <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>read 的数据结构是：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> readOnly <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  m  <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>entry</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token comment\">// 如果 Map.dirty 的数据和 m 中的数据不一样是为 true</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  amended <span class=\"token builtin\">bool</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>entry 的数据结构：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> entry <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token comment\">// 可见 value 是个指针类型，虽然 read 和 dirty 存在冗余情况（amended=false），但是由于是指针类型，存储的空间应该不是问题</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> p unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\">// *interface&#123;&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>Delete 方法:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Delete</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token comment\">// 如果 read 中没有，并且 dirty 中有新元素，那么就去 dirty 中去找</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token operator\">&amp;&amp;</span> read<span class=\"token punctuation\">.</span>amended <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     m<span class=\"token punctuation\">.</span>mu<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     <span class=\"token comment\">// 这是双检查（上面的 if 判断和锁不是一个原子性操作）</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">=</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token operator\">&amp;&amp;</span> read<span class=\"token punctuation\">.</span>amended <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>         <span class=\"token comment\">// 直接删除</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>         <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>     m<span class=\"token punctuation\">.</span>mu<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre> <span class=\"token keyword\">if</span> ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre> <span class=\"token comment\">// 如果 read 中存在该 key，则将该 value 赋值 nil（采用标记的方式删除！）</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     e<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>entry<span class=\"token punctuation\">)</span> <span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>hadValue <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>     p <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>     <span class=\"token keyword\">if</span> p <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> p <span class=\"token operator\">==</span> expunged <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>         <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>     <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>Store 方法:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Store</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token comment\">// 如果 m.read 存在这个 key，并且没有被标记删除，则尝试更新。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token keyword\">if</span> e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> ok <span class=\"token operator\">&amp;&amp;</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">tryStore</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre> <span class=\"token comment\">// 如果 read 不存在或者已经被标记删除</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre> m<span class=\"token punctuation\">.</span>mu<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre> read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre> <span class=\"token keyword\">if</span> e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre> <span class=\"token comment\">// 如果 entry 被标记 expunge，则表明 dirty 没有 key，可添加入 dirty，并更新 entry</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     <span class=\"token keyword\">if</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">unexpungeLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>         <span class=\"token comment\">// 加入 dirty 中</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>         m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     <span class=\"token comment\">// 更新 value 值</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>     e<span class=\"token punctuation\">.</span><span class=\"token function\">storeLocked</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>value<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"19\"></td><td><pre>     <span class=\"token comment\">//dirty 存在该 key，更新</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre> <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> ok <span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"21\"></td><td><pre>     e<span class=\"token punctuation\">.</span><span class=\"token function\">storeLocked</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>value<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>     <span class=\"token comment\">//read 和 dirty 都没有，新添加一条</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre> <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  <span class=\"token comment\">//dirty 中没有新的数据，往 dirty 中增加第一个新键</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>     <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>read<span class=\"token punctuation\">.</span>amended <span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"26\"></td><td><pre>         <span class=\"token comment\">// 将 read 中未删除的数据加入到 dirty 中</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>         m<span class=\"token punctuation\">.</span><span class=\"token function\">dirtyLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"28\"></td><td><pre>         m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">&#123;</span>m<span class=\"token punctuation\">:</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">,</span> amended<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>     m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">newEntry</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"31\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre> m<span class=\"token punctuation\">.</span>mu<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token comment\">// 将 read 中未删除的数据加入到 dirty 中</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">dirtyLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre> <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>     <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre> read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre> m<span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>entry<span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre> <span class=\"token comment\">//read 如果较大的话，可能影响性能</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre> <span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span> e <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> read<span class=\"token punctuation\">.</span>m <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre> <span class=\"token comment\">// 通过此次操作，dirty 中的元素都是未被删除的，可见 expunge 的元素不在 dirty 中</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>     <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>e<span class=\"token punctuation\">.</span><span class=\"token function\">tryExpungeLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>         m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e</pre></td></tr><tr><td data-num=\"47\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre><span class=\"token comment\">// 判断 entry 是否被标记删除，并且将标记为 nil 的 entry 更新标记为 expunge</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>entry<span class=\"token punctuation\">)</span> <span class=\"token function\">tryExpungeLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>isExpunged <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre> p <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre> <span class=\"token keyword\">for</span> p <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>     <span class=\"token comment\">// 将已经删除标记为 nil 的数据标记为 expunged</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>     <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> expunged<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>     p <span class=\"token operator\">=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre> <span class=\"token keyword\">return</span> p <span class=\"token operator\">==</span> expunged</pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\">// 对 entry 尝试更新</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>entry<span class=\"token punctuation\">)</span> <span class=\"token function\">tryStore</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">*</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre> p <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre> <span class=\"token keyword\">if</span> p <span class=\"token operator\">==</span> expunged <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>     <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre> </pre></td></tr><tr><td data-num=\"71\"></td><td><pre> <span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>     <span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>         <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>     p <span class=\"token operator\">=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">LoadPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>     <span class=\"token keyword\">if</span> p <span class=\"token operator\">==</span> expunged <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>         <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre></pre></td></tr><tr><td data-num=\"82\"></td><td><pre><span class=\"token comment\">//read 里 将标记为 expunge 的更新为 nil</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>entry<span class=\"token punctuation\">)</span> <span class=\"token function\">unexpungeLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>wasExpunged <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre> <span class=\"token keyword\">return</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapPointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">,</span> expunged<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre></pre></td></tr><tr><td data-num=\"87\"></td><td><pre><span class=\"token comment\">// 更新 entry</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">*</span>entry<span class=\"token punctuation\">)</span> <span class=\"token function\">storeLocked</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">*</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">StorePointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>e<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">,</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>因此，每次操作先检查 read，因为 read 并发安全，性能好些；read 不满足，则加锁检查 dirty，一旦是新的键值，dirty 会被 read 更新。</p><p>Load 方法:</p><p>Load 方法是一个加载方法，查找 key。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> ok <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token comment\">// 因 read 只读，线程安全，先查看是否满足条件</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre> read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token comment\">// 如果 read 没有，并且 dirty 有新数据，那从 dirty 中查找，由于 dirty 是普通 map，线程不安全，这个时候用到互斥锁了</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token operator\">&amp;&amp;</span> read<span class=\"token punctuation\">.</span>amended <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     m<span class=\"token punctuation\">.</span>mu<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     <span class=\"token comment\">// 双重检查</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     read<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">=</span> read<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     <span class=\"token comment\">// 如果 read 中还是不存在，并且 dirty 中有新数据</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token operator\">&amp;&amp;</span> read<span class=\"token punctuation\">.</span>amended <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>         e<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>         <span class=\"token comment\">//mssLocked（）函数是性能是 sync.Map 性能得以保证的重要函数，目的讲有锁的 dirty 数据，替换到只读线程安全的 read 里</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>         m<span class=\"token punctuation\">.</span><span class=\"token function\">missLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     m<span class=\"token punctuation\">.</span>mu<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre> <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>     <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre> <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token comment\">//dirty 提升至 read 关键函数，当 misses 经过多次因为 load 之后，大小等于 len（dirty）时候，讲 dirty 替换到 read 里，以此达到性能提升。</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Map<span class=\"token punctuation\">)</span> <span class=\"token function\">missLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>  misses<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">.</span>misses <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>      <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>  <span class=\"token comment\">// 原子操作，耗时很小</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>  m<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span>readOnly<span class=\"token punctuation\">&#123;</span>m<span class=\"token punctuation\">:</span> m<span class=\"token punctuation\">.</span>dirty<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  m<span class=\"token punctuation\">.</span>dirty <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  m<span class=\"token punctuation\">.</span>misses <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>sync.Map 是通过冗余的两个数据结构 (read、dirty), 实现性能的提升。</p><p>为了提升性能，load、delete、store 等操作尽量使用只读的 read；为了提高 read 的 key 击中概率，采用动态调整，将 dirty 数据提升为 read；对于数据的删除，采用延迟标记删除法，只有在提升 dirty 的时候才删除。</p><ol start=\"18\"><li><h4 id=\"怎么限制goroutine的数量\"><a class=\"anchor\" href=\"#怎么限制goroutine的数量\">#</a> 怎么限制 Goroutine 的数量</h4></li></ol><p>在 Golang 中，Goroutine 虽然很好，但是数量太多了，往往会带来很多麻烦，比如耗尽系统资源导致程序崩溃，或者 CPU 使用率过高导致系统忙不过来。</p><p>所以我们可以限制下 Goroutine 的数量，这样就需要在每一次执行 go 之前判断 goroutine 的数量，如果数量超了，就要阻塞 go 的执行。</p><p>所以通常我们第一时间想到的就是使用通道。每次执行的 go 之前向通道写入值，直到通道满的时候就阻塞了，</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">var</span> ch <span class=\"token keyword\">chan</span>  <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">elegance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token operator\">&lt;-</span>ch</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the ch value receive\"</span><span class=\"token punctuation\">,</span>ch<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tch <span class=\"token operator\">=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\tch <span class=\"token operator\">&lt;-</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the ch value send\"</span><span class=\"token punctuation\">,</span>ch<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">elegance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the result i\"</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token keyword\">go</span> run goroutine<span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>the result i <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>the result i <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>the result i <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>the result i <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>the result i <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>the result i <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>the result i <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>the result i <span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>the result i <span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>the result i <span class=\"token number\">9</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>the result i <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>the result i <span class=\"token number\">11</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>the result i <span class=\"token number\">12</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>the result i <span class=\"token number\">13</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>the ch value send <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>the result i <span class=\"token number\">14</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>the ch value receive <span class=\"token number\">0xc00009c000</span></pre></td></tr></table></figure><pre><code>&gt; go run goroutine.go \nthe ch value send 0xc00007e000\nthe result i 0\nthe ch value send 0xc00007e000\nthe result i 1\nthe ch value send 0xc00007e000\nthe result i 2\nthe ch value send 0xc00007e000\nthe result i 3\nthe ch value send 0xc00007e000\nthe ch value receive 0xc00007e000\nthe result i 4\nthe ch value send 0xc00007e000\nthe ch value receive 0xc00007e000\nthe result i 5\nthe ch value send 0xc00007e000\nthe ch value receive 0xc00007e000\nthe result i 6\nthe ch value send 0xc00007e000\nthe result i 7\nthe ch value send 0xc00007e000\nthe ch value receive 0xc00007e000\nthe ch value receive 0xc00007e000\nthe ch value receive 0xc00007e000\nthe result i 8\nthe ch value send 0xc00007e000\nthe result i 9\n</code></pre><p>这样每次同时运行的 goroutine 就被限制为 5 个了。但是新的问题于是就出现了，因为并不是所有的 goroutine 都执行完了，在 main 函数退出之后，还有一些 goroutine 没有执行完就被强制结束了。这个时候我们就需要用到 sync.WaitGroup。使用 WaitGroup 等待所有的 goroutine 退出。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token string\">\"runtime\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token string\">\"time\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// Pool Goroutine Pool</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">type</span> Pool <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tqueue <span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\twg <span class=\"token operator\">*</span>sync<span class=\"token punctuation\">.</span>WaitGroup</pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">// New 新建一个协程池</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">NewPool</span><span class=\"token punctuation\">(</span>size <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Pool<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">if</span> size <span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\tsize <span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>Pool<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\tqueue<span class=\"token punctuation\">:</span><span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\twg<span class=\"token punctuation\">:</span><span class=\"token operator\">&amp;</span>sync<span class=\"token punctuation\">.</span>WaitGroup<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">// Add 新增一个执行</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Pool<span class=\"token punctuation\">)</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>delta <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t<span class=\"token comment\">//delta 为正数就添加</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>delta<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\tp<span class=\"token punctuation\">.</span>queue <span class=\"token operator\">&lt;-</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token comment\">//delta 为负数就减少</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t<span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">></span>delta<span class=\"token punctuation\">;</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t<span class=\"token operator\">&lt;-</span>p<span class=\"token punctuation\">.</span>queue</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>delta<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token comment\">// Done 执行完成减一</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Pool<span class=\"token punctuation\">)</span> <span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t<span class=\"token operator\">&lt;-</span>p<span class=\"token punctuation\">.</span>queue</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token comment\">// Wait 等待 Goroutine 执行完毕</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Pool<span class=\"token punctuation\">)</span> <span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\tp<span class=\"token punctuation\">.</span>wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>\t<span class=\"token comment\">// 这里限制 5 个并发</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>\tpool <span class=\"token operator\">:=</span> <span class=\"token function\">NewPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the NumGoroutine begin is:\"</span><span class=\"token punctuation\">,</span>runtime<span class=\"token punctuation\">.</span><span class=\"token function\">NumGoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>\t<span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>\t\tpool<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>\t\t\ttime<span class=\"token punctuation\">.</span><span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>Second<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the NumGoroutine continue is:\"</span><span class=\"token punctuation\">,</span>runtime<span class=\"token punctuation\">.</span><span class=\"token function\">NumGoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>\t\t\tpool<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>\tpool<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the NumGoroutine done is:\"</span><span class=\"token punctuation\">,</span>runtime<span class=\"token punctuation\">.</span><span class=\"token function\">NumGoroutine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>the NumGoroutine begin is<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>the NumGoroutine <span class=\"token keyword\">continue</span> is<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>the NumGoroutine done is<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></pre></td></tr></table></figure><p>其中，Go 的 <code>GOMAXPROCS</code> 默认值已经设置为 CPU 的核数， 这里允许我们的 Go 程序充分使用机器的每一个 CPU, 最大程度的提高我们程序的并发性能。 <code>runtime.NumGoroutine</code> 函数在被调用后，会返回系统中的处于特定状态的 Goroutine 的数量。这里的特指是指 <code>Grunnable\\Gruning\\Gsyscall\\Gwaition</code> 。处于这些状态的 Groutine 即被看做是活跃的或者说正在被调度。</p><p>这里需要注意下：垃圾回收所在 Groutine 的状态也处于这个范围内的话，也会被纳入该计数器。</p><ol start=\"19\"><li><h4 id=\"channel是同步的还是异步的\"><a class=\"anchor\" href=\"#channel是同步的还是异步的\">#</a> Channel 是同步的还是异步的</h4></li></ol><p>Channel 是异步进行的，channel 存在 3 种状态：</p><ul><li>nil，未初始化的状态，只进行了声明，或者手动赋值为 nil</li><li>active，正常的 channel，可读或者可写</li><li>closed，已关闭，千万不要误认为关闭 channel 后，channel 的值是 nil</li></ul><p>下面我们对 channel 的三种操作解析:</p><ol><li>零值（nil）通道；</li><li>非零值但已关闭的通道；</li><li>非零值并且尚未关闭的通道。</li></ol><table><thead><tr><th>操作</th><th>一个零值 nil 通道</th><th>一个非零值但已关闭的通道</th><th>一个非零值且尚未关闭的通道</th></tr></thead><tbody><tr><td>关闭</td><td>产生恐慌</td><td>产生恐慌</td><td>成功关闭</td></tr><tr><td>发送数据</td><td>永久阻塞</td><td>产生恐慌</td><td>阻塞或者成功发送</td></tr><tr><td>接收数据</td><td>永久阻塞</td><td>永不阻塞</td><td>阻塞或者成功接收</td></tr></tbody></table><ol start=\"20\"><li><h4 id=\"goroutine和线程的区别\"><a class=\"anchor\" href=\"#goroutine和线程的区别\">#</a> Goroutine 和线程的区别</h4></li></ol><p>从调度上看，goroutine 的调度开销远远小于线程调度开销。</p><p>OS 的线程由 OS 内核调度，每隔几毫秒，一个硬件时钟中断发到 CPU，CPU 调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。</p><p>Go 运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个 M:N 调度技术，m 个 goroutine 到 n 个 os 线程（可以用 GOMAXPROCS 来控制 n 的数量），Go 的调度器不是由硬件时钟来定期触发的，而是由特定的 go 语言结构来触发的，他不需要切换到内核语境，所以调度一个 goroutine 比调度一个线程的成本低很多。</p><p>从栈空间上，goroutine 的栈空间更加动态灵活。</p><p>每个 OS 的线程都有一个固定大小的栈内存，通常是 2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于 goroutine 来说，可能是一种巨大的浪费。作为对比 goroutine 在生命周期开始只有一个很小的栈，典型情况是 2KB, 在 go 程序中，一次创建十万左右的 goroutine 也不罕见（2KB*100,000=200MB）。而且 goroutine 的栈不是固定大小，它可以按需增大和缩小，最大限制可以到 1GB。</p><p>goroutine 没有一个特定的标识。</p><p>在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的 map，以线程的标识作为键，这样每个线程可以独立使用这个 map 存储和获取值，不受其他线程干扰。</p><p>goroutine 中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。</p><ol start=\"21\"><li><h4 id=\"go的struct能不能比较\"><a class=\"anchor\" href=\"#go的struct能不能比较\">#</a> Go 的 Struct 能不能比较</h4></li></ol><ul><li><p>相同 struct 类型的可以比较</p></li><li><p>不同 struct 类型的不可以比较，编译都不过，类型不匹配</p></li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">type</span> A <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        a <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">type</span> B <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        a <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    a <span class=\"token operator\">:=</span> A<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">//b := A&#123;1&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    b <span class=\"token operator\">:=</span> B<span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">if</span> a <span class=\"token operator\">==</span> b <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a == b\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a != b\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span> </pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>output<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token operator\">></span> command<span class=\"token operator\">-</span>line<span class=\"token operator\">-</span>arguments <span class=\"token punctuation\">[</span>command<span class=\"token operator\">-</span>line<span class=\"token operator\">-</span>arguments<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">go</span><span class=\"token punctuation\">:</span><span class=\"token number\">14</span><span class=\"token punctuation\">:</span><span class=\"token number\">7</span><span class=\"token punctuation\">:</span> invalid operation<span class=\"token punctuation\">:</span> a <span class=\"token operator\">==</span> b <span class=\"token punctuation\">(</span>mismatched types A and B<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ol start=\"22\"><li><h4 id=\"go的defer原理是什么\"><a class=\"anchor\" href=\"#go的defer原理是什么\">#</a> Go 的 defer 原理是什么</h4></li></ol><p>什么是 defer？如何理解 defer 关键字？Go 中使用 defer 的一些坑。</p><p>defer 意为延迟，在 golang 中用于延迟执行一个函数。它可以帮助我们处理容易忽略的问题，如资源释放、连接关闭等。但在实际使用过程中，有一些需要注意的地方.</p><ol><li>若函数中有多个 defer，其执行顺序为 先进后出，可以理解为栈。</li></ol><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr></table></figure><ol start=\"2\"><li>return 会做什么呢？</li></ol><p>Go 的函数返回值是通过堆栈返回的，return 语句不是原子操作，而是被拆成了两步.</p><ul><li>给返回值赋值 (rval)</li><li>调用 defer 表达式</li><li>返回给调用函数 (ret)</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">increase</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">increase</span><span class=\"token punctuation\">(</span>d <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>ret <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    ret<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token keyword\">return</span> d</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行输出:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr></table></figure><ol start=\"3\"><li>若 defer 表达式有返回值，将会被丢弃。</li></ol><p>闭包与匿名函数.</p><ul><li>匿名函数：没有函数名的函数。</li><li>闭包：可以使用另外一个函数作用域中的变量的函数。</li></ul><p>在实际开发中，defer 的使用经常伴随着闭包与匿名函数的使用。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行输出:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr></table></figure><p>之所以这样是因为，defer 表达式中的 i 是对 for 循环中 i 的引用。到最后，i 加到 5，故最后全部打印 5。</p><p>如果将 i 作为参数传入 defer 表达式中，在传入最初就会进行求值保存，只是没有执行延迟函数而已。</p><p>应用示例:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>result <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        result<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    t <span class=\"token operator\">:=</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    t <span class=\"token operator\">=</span> t <span class=\"token operator\">+</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token keyword\">return</span> t</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">f3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        r <span class=\"token operator\">=</span> r <span class=\"token operator\">+</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> Test <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Max <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>Test<span class=\"token punctuation\">)</span> <span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>Max<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">deferExec</span><span class=\"token punctuation\">(</span>f <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">var</span> t <span class=\"token operator\">*</span>Test</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">defer</span> <span class=\"token function\">deferExec</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>Println<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    t <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Test<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有没有得出结果？例 1 的答案不是 0，例 2 的答案不是 10，例 3 的答案也不是 6。</p><p>defer 是在 return 之前执行的。这个在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb2xhbmcub3JnL3JlZi9zcGVjI2RlZmVyX3N0YXRlbWVudHM=\">官方文档</span>中是明确说明了的。要使用 defer 时不踩坑，最重要的一点就是要明白， <code>return xxx</code> 这一条语句并不是一条原子指令！</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>defer表达式可能会在设置函数返回值之后，在返回到调用函数之前，修改返回值，使最终的函数返回值与你想象的不一致。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>返回值 = xxx</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>调用defer函数</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>空的return</pre></td></tr></table></figure><p>f1: 比较简单，参考结论 2，将 0 赋给 result，defer 延迟函数修改 result，最后返回给调用函数。正确答案是 1。</p><p>f1 可以修改成长这样的:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>result <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     result <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\">//return 语句不是一条原子调用，return xxx 其实是赋值＋ret 指令</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//defer 被插入到 return 之前执行，也就是赋返回值和 ret 指令之间</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>         result<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所以这个返回值是 1。</p><p>f2: defer 是在 t 赋值给 r 之后执行的，而 defer 延迟函数只改变了 t 的值，r 不变。正确答案 5。</p><p>f2 可以修改成这样的:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     t <span class=\"token operator\">:=</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     r <span class=\"token operator\">=</span> t <span class=\"token comment\">// 赋值指令</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>        <span class=\"token comment\">//defer 被插入到赋值与返回之间执行，这个例子中返回值 r 没被修改过</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>         t <span class=\"token operator\">=</span> t <span class=\"token operator\">+</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     <span class=\"token keyword\">return</span>        <span class=\"token comment\">// 空的 return 指令</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所以这个的结果是 5。</p><p>f3: 这里将 r 作为参数传入了 defer 表达式。故 func (r int) 中的 r 非 func f () (r int) 中的 r，只是参数命名相同而已。正确答案 1。</p><p>f3 可以修改成这样的:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>     r <span class=\"token operator\">=</span> <span class=\"token number\">1</span>  <span class=\"token comment\">// 给返回值赋值</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>        <span class=\"token comment\">// 这里改的 r 是传值传进去的 r，不会改变要返回的那个 r 值</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>          r <span class=\"token operator\">=</span> r <span class=\"token operator\">+</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     <span class=\"token keyword\">return</span>        <span class=\"token comment\">// 空的 return</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所以这个例子的结果是 1。</p><p>f4: 这里将发生 panic。将方法传给 deferExec，实际上在传的过程中对方法求了值。而此时的 t 任然为 nil。</p><p>因此，defer 确实是在 return 之前调用的。但表现形式上却可能不像。根本原因是 <code>return xxx</code> 语句并不是一条原子指令，defer 被插入到了赋值 与 ret 之间，因此可能有机会改变最终的返回值。</p><p>defer 关键字的实现跟 go 关键字很类似，不同的是它调用的是 <code>runtime.deferproc</code> 而不是 <code>runtime.newproc</code> 。</p><p>在 defer 出现的地方，插入了指令 <code>call runtime.deferproc</code> ，然后在函数返回之前的地方，插入指令 <code>call runtime.deferreturn</code> 。</p><p>普通的函数返回时，汇编代码类似:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>add xx SP</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">return</span></pre></td></tr></table></figure><p>如果其中包含了 defer 语句，则汇编代码是：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>call runtime<span class=\"token punctuation\">.</span>deferreturn，</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>add xx SP</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">return</span></pre></td></tr></table></figure><p>goroutine 的控制结构中，有一张表记录 defer，调用 <code>runtime.deferproc</code> 时会将需要 defer 的表达式记录在表中，而在调用 <code>runtime.deferreturn</code> 的时候，则会依次从 defer 表中出栈并执行。</p><ol start=\"23\"><li><h4 id=\"go的select可以用于什么\"><a class=\"anchor\" href=\"#go的select可以用于什么\">#</a> Go 的 select 可以用于什么</h4></li></ol><p>Golang 的 select 机制可以理解为是在语言层面实现了和 select, poll, epoll 相似的功能：监听多个描述符的读 / 写等事件，一旦某个描述符就绪（一般是读或者写事件发生了），就能够将发生的事件通知给关心的应用程序去处理该事件。 golang 的 select 机制是，监听多个 channel，每一个 case 是一个事件，可以是读事件也可以是写事件，随机选择一个执行，可以设置 default.</p><p>它的作用是：当监听的多个事件都阻塞住会执行 default 的逻辑。</p><p>select 的源码在 (runtime/select.go)[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvcnVudGltZS9zZWxlY3QuZ28=\">https://github.com/golang/go/blob/master/src/runtime/select.go</span>] ，看的时候建议是重点关注 pollorder 和 lockorder.</p><ul><li>pollorder 保存的是 scase 的序号，乱序是为了之后执行时的随机性。</li><li>lockorder 保存了所有 case 中 channel 的地址，这里按照地址大小堆排了一下 lockorder 对应的这片连续内存。对 chan 排序是为了去重，保证之后对所有 channel 上锁时不会重复上锁。</li></ul><p>goroutine 作为 Golang 并发的核心，我们不仅要关注它们的创建和管理，当然还要关注如何合理的退出这些协程，不（合理）退出不然可能会造成阻塞、panic、程序行为异常、数据结果不正确等问题。goroutine 在退出方面，不像线程和进程，不能通过某种手段强制关闭它们，只能等待 goroutine 主动退出。</p><p>goroutine 的优雅退出方法有三种:</p><ol><li>使用 for-range 退出</li></ol><p>for-range 是使用频率很高的结构，常用它来遍历数据，range 能够感知 channel 的关闭，当 channel 被发送数据的协程关闭时，range 就会结束，接着退出 for 循环。</p><p>它在并发中的使用场景是：当协程只从 1 个 channel 读取数据，然后进行处理，处理后协程退出。下面这个示例程序，当 in 通道被关闭时，协程可自动退出。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>in <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// Using for-range to exit goroutine</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// range has the ability to detect the close/end of a channel</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span> x <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> in <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Process %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ol start=\"2\"><li>使用 select case ,ok 退出</li></ol><p>for-select 也是使用频率很高的结构，select 提供了多路复用的能力，所以 for-select 可以让函数具有持续多路处理多个 channel 的能力。但 select 没有感知 channel 的关闭，这引出了 2 个问题：</p><p>继续在关闭的通道上读，会读到通道传输数据类型的零值，如果是指针类型，读到 nil，继续处理还会产生 nil。<br>继续在关闭的通道上写，将会 panic。</p><p>问题 2 可以这样解决，通道只由发送方关闭，接收方不可关闭，即某个写通道只由使用该 select 的协程关闭，select 中就不存在继续在关闭的通道上写数据的问题。</p><p>问题 1 可以使用，ok 来检测通道的关闭，使用情况有 2 种。</p><p>第一种：如果某个通道关闭后，需要退出协程，直接 return 即可。示例代码中，该协程需要从 in 通道读数据，还需要定时打印已经处理的数量，有 2 件事要做，所有不能使用 for-range，需要使用 for-select，当 in 关闭时，ok=false，我们直接返回。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token comment\">// in for-select using ok to exit goroutine</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> x<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>in<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Process %d\\n\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\tprocessedCnt<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>t<span class=\"token punctuation\">.</span>C<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Working, processedCnt = %d\\n\"</span><span class=\"token punctuation\">,</span> processedCnt<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>第二种：如果某个通道关闭了，不再处理该通道，而是继续处理其他 case，退出是等待所有的可读通道关闭。我们需要使用 select 的一个特征：select 不会在 nil 的通道上进行等待。这种情况，把只读通道设置为 nil 即可解决。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token comment\">// in for-select using ok to exit goroutine</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> x<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>in1<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t\tin1 <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t<span class=\"token comment\">// Process</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> y<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>in2<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t\tin2 <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t<span class=\"token comment\">// Process</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>t<span class=\"token punctuation\">.</span>C<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Working, processedCnt = %d\\n\"</span><span class=\"token punctuation\">,</span> processedCnt<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token comment\">// If both in channel are closed, goroutine exit</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> in1 <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">&amp;&amp;</span> in2 <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><ol start=\"3\"><li>使用退出通道退出</li></ol><p>使用，ok 来退出使用 for-select 协程，解决是当读入数据的通道关闭时，没数据读时程序的正常结束。想想下面这 2 种场景，,ok 还能适用吗？</p><p>接收的协程要退出了，如果它直接退出，不告知发送协程，发送协程将阻塞。启动了一个工作协程处理数据，如何通知它退出？</p><p>使用一个专门的通道，发送退出的信号，可以解决这类问题。以第 2 个场景为例，协程入参包含一个停止通道 stopCh，当 stopCh 被关闭，case &lt;-stopCh 会执行，直接返回即可。</p><p>当我启动了 100 个 worker 时，只要 main () 执行关闭 stopCh，每一个 worker 都会都到信号，进而关闭。如果 main () 向 stopCh 发送 100 个数据，这种就低效了。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">worker</span><span class=\"token punctuation\">(</span>stopCh <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"worker exit\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token comment\">// Using stop channel explicit exit</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>stopCh<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Recv stop signal\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>t<span class=\"token punctuation\">.</span>C<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Working .\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>通过 channel 控制子 goroutine 的方法可以总结为：循环监听一个 channel，一般来说是 for 循环里放一个 select 监听 channel 以达到通知子 goroutine 的效果。再借助 Waitgroup，主进程可以等待所有协程优雅退出后再结束自己的运行，这就通过 channel 实现了优雅控制 goroutine 并发的开始和结束。</p><p>因此在退出协程的时候需要注意:</p><ul><li>发送协程主动关闭通道，接收协程不关闭通道。使用技巧：把接收方的通道入参声明为只读，如果接收协程关闭只读协程，编译时就会报错。</li><li>协程处理 1 个通道，并且是读时，协程优先使用 for-range，因为 range 可以关闭通道的关闭自动退出协程。</li><li>ok 可以处理多个读通道关闭，需要关闭当前使用 for-select 的协程。</li><li>显式关闭通道 stopCh 可以处理主动通知协程退出的场景。</li></ul><ol start=\"24\"><li><h4 id=\"context包的用途是什么\"><a class=\"anchor\" href=\"#context包的用途是什么\">#</a> Context 包的用途是什么</h4></li></ol><p>在 Go http 包的 Server 中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和 RPC 服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的 token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><p>在 Google 内部，我们开发了 Context 包，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>context 的数据结构是:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// A Context carries a deadline, cancelation signal, and request-scoped values</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// across API boundaries. Its methods are safe for simultaneous use by multiple</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// goroutines.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">type</span> Context <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// Done returns a channel that is closed when this `Context` is canceled</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// or times out.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;-</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// Err indicates why this Context was canceled, after the Done channel</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// is closed.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">Err</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// Deadline returns the time when this Context will be canceled, if any.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">Deadline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>deadline time<span class=\"token punctuation\">.</span>Time<span class=\"token punctuation\">,</span> ok <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// Value returns the value associated with key or nil if none.</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">Value</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>Context 中的方法:</p><ul><li>Done 会返回一个 channel，当该 context 被取消的时候，该 channel 会被关闭，同时对应的使用该 context 的 routine 也应该结束并返回。</li><li>Context 中的方法是协程安全的，这也就代表了在父 routine 中创建的 context，可以传递给任意数量的 routine 并让他们同时访问。</li><li>Deadline 会返回一个超时时间，routine 获得了超时时间后，可以对某些 io 操作设定超时时间。</li><li>Value 可以让 routine 共享一些数据，当然获得数据是协程安全的。</li></ul><p>这里需要注意一点的是在 goroutine 中使用 context 包的时候，通常我们需要在 goroutine 中新创建一个上下文的 context, 原因是：如果直接传递外部 context 到协层中，一个请求可能在主函数中已经结束，在 goroutine 中如果还没有结束的话，会直接导致 goroutine 中的运行的被取消.</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> ctx<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> log<span class=\"token punctuation\">.</span><span class=\"token function\">FromContextOrNew</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span><span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>context.Background 函数的返回值是一个空的 context，经常作为树的根结点，它一般由接收请求的第一个 routine 创建，不能被取消、没有值、也没有过期时间。</p><p>Background 函数的声明如下：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// Background returns an empty Context. It is never canceled, has no deadline,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// and has no values. Background is typically used in main, init, and tests,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// and as the top-level `Context` for incoming requests.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> Context</pre></td></tr></table></figure><p>WithCancel 和 WithTimeout 函数 会返回继承的 Context 对象， 这些对象可以比它们的父 Context 更早地取消。</p><p>当请求处理函数返回时，与该请求关联的 Context 会被取消。 当使用多个副本发送请求时，可以使用 WithCancel 取消多余的请求。 WithTimeout 在设置对后端服务器请求截止时间时非常有用。 下面是这三个函数的声明：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// WithCancel returns a copy of parent whose Done channel is closed as soon as</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// parent.Done is closed or cancel is called.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">WithCancel</span><span class=\"token punctuation\">(</span>parent Context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>ctx Context<span class=\"token punctuation\">,</span> cancel CancelFunc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// A CancelFunc cancels a Context.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">type</span> CancelFunc <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// WithTimeout returns a copy of parent whose Done channel is closed as soon as</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// parent.Done is closed, cancel is called, or timeout elapses. The new</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// Context's Deadline is the sooner of now+timeout and the parent's deadline, if</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// any. If the timer is still running, the cancel function releases its</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// resources.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">WithTimeout</span><span class=\"token punctuation\">(</span>parent Context<span class=\"token punctuation\">,</span> timeout time<span class=\"token punctuation\">.</span>Duration<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>Context<span class=\"token punctuation\">,</span> CancelFunc<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>调用 CancelFunc 对象将撤销对应的 Context 对象，这样父结点的所在的环境中，获得了撤销子节点 context 的权利，当触发某些条件时，可以调用 CancelFunc 对象来终止子结点树的所有 routine。在子节点的 routine 中，需要判断何时退出 routine：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>cxt<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">// do some cleaning and return</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>根据 cxt.Done () 判断是否结束。当顶层的 Request 请求处理结束，或者外部取消了这次请求，就可以 cancel 掉顶层 context，从而使整个请求的 routine 树得以退出。</p><p>WithDeadline 和 WithTimeout 比 WithCancel 多了一个时间参数，它指示 context 存活的最长时间。如果超过了过期时间，会自动撤销它的子 context。所以 context 的生命期是由父 context 的 routine 和 deadline 共同决定的。</p><p>WithValue 函数能够将请求作用域的数据与 Context 对象建立关系。声明如下：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> valueCtx <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    Context</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    key<span class=\"token punctuation\">,</span> val <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">WithValue</span><span class=\"token punctuation\">(</span>parent Context<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> val <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> Context <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">if</span> key <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"nil key\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token operator\">...</span><span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>valueCtx<span class=\"token punctuation\">&#123;</span>parent<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> val<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>valueCtx<span class=\"token punctuation\">)</span> <span class=\"token function\">Value</span><span class=\"token punctuation\">(</span>key <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">if</span> c<span class=\"token punctuation\">.</span>key <span class=\"token operator\">==</span> key <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">.</span>val</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">return</span> c<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">.</span><span class=\"token function\">Value</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>WithValue 返回 parent 的一个副本，该副本保存了传入的 <code>key/value</code> ，而调用 Context 接口的 Value (key) 方法就可以得到 val。注意在同一个 context 中设置 <code>key/value</code> ，若 key 相同，值会被覆盖。</p><p>Context 上下文数据的存储就像一个树，每个结点只存储一个 <code>key/value</code> 对。WithValue () 保存一个 <code>key/value</code> 对，它将父 context 嵌入到新的子 context，并在节点中保存了 <code>key/value</code> 数据。Value () 查询 key 对应的 value 数据，会从当前 context 中查询，如果查不到，会递归查询父 context 中的数据。</p><p>值得注意的是，context 中的上下文数据并不是全局的，它只查询本节点及父节点们的数据，不能查询兄弟节点的数据。</p><p>Context 使用原则:</p><ul><li>不要把 Context 放在结构体中，要以参数的方式传递。</li><li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO。</li><li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递。</li><li>Context 是线程安全的，可以放心的在多个 goroutine 中传递。</li></ul><ol start=\"25\"><li><h4 id=\"go主协程如何等其余协程完再操作\"><a class=\"anchor\" href=\"#go主协程如何等其余协程完再操作\">#</a> Go 主协程如何等其余协程完再操作</h4></li></ol><p>Go 提供了更简单的方法 —— 使用 <code>sync.WaitGroup</code> 。 <code>WaitGroup</code> ，就是用来等待一组操作完成的。 <code>WaitGroup</code> 内部实现了一个计数器，用来记录未完成的操作个数.</p><p>它提供了三个方法， <code>Add()</code> 用来添加计数。 <code>Done()</code> 用来在操作结束时调用，使计数减一。 <code>Wait()</code> 用来等待所有的操作结束，即计数变为 0，该函数会在计数不为 0 时等待，在计数为 0 时立即返回。</p><p>应用示例:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 因为有两个动作，所以增加 2 个计数</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Goroutine 1\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 操作完成，减少一个计数</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Goroutine 2\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 操作完成，减少一个计数</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    wg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 等待，直到计数为 0</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行输出:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Goroutine <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Goroutine <span class=\"token number\">1</span></pre></td></tr></table></figure><ol start=\"26\"><li><h4 id=\"go的slice如何扩容\"><a class=\"anchor\" href=\"#go的slice如何扩容\">#</a> Go 的 Slice 如何扩容</h4></li></ol><p>slice 是 Go 中的一种基本的数据结构，使用这种结构可以用来管理数据集合。但是 slice 本身并不是动态数据或者数组指针。slice 常见的操作有 reslice、append、copy。</p><p>slice 自身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。slice 本身是一个只读对象，其工作机制类似数组指针的一种封装。</p><p>slice 是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。</p><p>这里需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。</p><p>slice 是可以看做是一个长度可变的数组。</p><p>slice 数据结构如下:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> slice <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tarray unsafe<span class=\"token punctuation\">.</span>Pointer</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token builtin\">len</span>   <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token builtin\">cap</span>   <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>slice 的结构体由 3 部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。</p><p>通常我们在对 slice 进行 append 等操作时，可能会造成 slice 的自动扩容。</p><p>其扩容时的大小增长规则是：</p><ul><li><p>如果切片的容量小于 1024 个元素，那么扩容的时候 slice 的 cap 就翻番，乘以 2；一旦元素个数超过 1024 个元素，增长因子就变成 1.25，即每次增加原来容量的四分之一。</p></li><li><p>如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go 就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。</p></li></ul><p>通过 slice 源码可以看到，append 的实现只是简单的在内存中将旧 slice 复制给新 slice.</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>newcap <span class=\"token operator\">:=</span> old<span class=\"token punctuation\">.</span><span class=\"token builtin\">cap</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">if</span> newcap<span class=\"token operator\">+</span>newcap <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">cap</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    newcap <span class=\"token operator\">=</span> <span class=\"token builtin\">cap</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">if</span> old<span class=\"token punctuation\">.</span><span class=\"token builtin\">len</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1024</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            newcap <span class=\"token operator\">+=</span> newcap</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            newcap <span class=\"token operator\">+=</span> newcap <span class=\"token operator\">/</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">if</span> newcap <span class=\"token operator\">>=</span> <span class=\"token builtin\">cap</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"27\"><li><h4 id=\"go中的map如何实现顺序读取\"><a class=\"anchor\" href=\"#go中的map如何实现顺序读取\">#</a> Go 中的 map 如何实现顺序读取</h4></li></ol><p>Go 中 map 如果要实现顺序读取的话，可以先把 map 中的 key, 通过 sort 包排序.</p><p>通过 sort 中的排序包进行对 map 中的 key 进行排序.</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token string\">\"sort\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">var</span> m <span class=\"token operator\">=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">:</span>         <span class=\"token number\">0</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token string\">\"morning\"</span><span class=\"token punctuation\">:</span>       <span class=\"token number\">1</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token string\">\"keke\"</span><span class=\"token punctuation\">:</span>          <span class=\"token number\">2</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token string\">\"jame\"</span><span class=\"token punctuation\">:</span>   \t\t <span class=\"token number\">3</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">var</span> keys <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">for</span> k <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> m <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        keys <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    sort<span class=\"token punctuation\">.</span><span class=\"token function\">Strings</span><span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> keys <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Key:\"</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Value:\"</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"28\"><li><h4 id=\"go中cas是怎么回事\"><a class=\"anchor\" href=\"#go中cas是怎么回事\">#</a> Go 中 CAS 是怎么回事</h4></li></ol><p>CAS 算法（Compare And Swap）, 是原子操作的一种，CAS 算法是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。</p><p>该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><p>Go 中的 CAS 操作是借用了 CPU 提供的原子性指令来实现。CAS 操作修改共享变量时候不需要对共享变量加锁，而是通过类似乐观锁的方式进行检查，本质还是不断的占用 CPU 资源换取加锁带来的开销（比如上下文切换开销）。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token string\">\"sync\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token string\">\"sync/atomic\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\tcounter <span class=\"token builtin\">int32</span>          <span class=\"token comment\">// 计数器</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\twg      sync<span class=\"token punctuation\">.</span>WaitGroup <span class=\"token comment\">// 信号量</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\tthreadNum <span class=\"token operator\">:=</span> <span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>threadNum<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> threadNum<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">incCounter</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">incCounter</span><span class=\"token punctuation\">(</span>index <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token keyword\">defer</span> wg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\tspinNum <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t<span class=\"token comment\">// 原子操作</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\told <span class=\"token operator\">:=</span> counter</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\tok <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>counter<span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> old<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> ok <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\t\t<span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t\tspinNum<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"thread,%d,spinnum,%d\\n\"</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> spinNum<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当主函数 main 首先创建了 5 个信号量，然后开启五个线程执行 incCounter 方法，incCounter 内部执行，使用 cas 操作递增 counter 的值， <code>atomic.CompareAndSwapInt32</code> 具有三个参数，第一个是变量的地址，第二个是变量当前值，第三个是要修改变量为多少，该函数如果发现传递的 old 值等于当前变量的值，则使用第三个变量替换变量的值并返回 true，否则返回 false。</p><p>这里之所以使用无限循环是因为在高并发下每个线程执行 CAS 并不是每次都成功，失败了的线程需要重写获取变量当前的值，然后重新执行 CAS 操作。读者可以把线程数改为 10000 或者更多就会发现输出 <code>thread,5329,spinnum,1</code> 其中这个 1 就说明该线程尝试了两个 CAS 操作，第二次才成功。</p><p>因此呢，go 中 CAS 操作可以有效的减少使用锁所带来的开销，但是需要注意在高并发下这是使用 cpu 资源做交换的。</p><ol start=\"29\"><li><h4 id=\"go中的逃逸分析是什么\"><a class=\"anchor\" href=\"#go中的逃逸分析是什么\">#</a> Go 中的逃逸分析是什么</h4></li></ol><p>在 Go 中逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。</p><p>当一个变量 (或对象) 在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到 —— 这样指针就成功 “逃逸” 了。</p><p>如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。</p><p>导致内存逃逸的情况比较多，有些可能还是官方未能够实现精确的分析逃逸情况的 bug，通常来讲就是如果变量的作用域不会扩大并且其行为或者大小能够在编译的时候确定，一般情况下都是分配到栈上，否则就可能发生内存逃逸分配到堆上。</p><p>内存逃逸的五种情况:</p><ol><li><p>发送指针的指针或值包含了指针到 <code>channel</code> 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。</p></li><li><p>slices 中的值是指针的指针或包含指针字段。一个例子是类似 <code>[]*string</code> 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。</p></li><li><p>slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。</p></li><li><p>调用接口类型的方法。接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read (b) 的调用将导致 r 的值和字节片 b 的后续转义并因此分配到堆上。</p></li><li><p>尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上.</p></li></ol><p>有效的避免上述的五种逃逸的情况，就可以避免内存逃逸.</p><ol start=\"30\"><li><h4 id=\"go值接收者和指针接收者的区别\"><a class=\"anchor\" href=\"#go值接收者和指针接收者的区别\">#</a> Go 值接收者和指针接收者的区别</h4></li></ol><p>Go 中的方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法。接收者可以是值接收者，也可以是指针接收者。</p><p>在调用方法的时候，值类型既可以调用值接收者的方法，也可以调用指针接收者的方法；指针类型既可以调用指针接收者的方法，也可以调用值接收者的方法。</p><p>也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    age <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Elegance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> p<span class=\"token punctuation\">.</span>age</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Person<span class=\"token punctuation\">)</span> <span class=\"token function\">GetAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    p<span class=\"token punctuation\">.</span>age <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">//p1 是值类型</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    p <span class=\"token operator\">:=</span> Person<span class=\"token punctuation\">&#123;</span>age<span class=\"token punctuation\">:</span> <span class=\"token number\">18</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// 值类型 调用接收者也是值类型的方法</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">howOld</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">// 值类型 调用接收者是指针类型的方法</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    p<span class=\"token punctuation\">.</span><span class=\"token function\">GetAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">GetAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">// ----------------------</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token comment\">//p2 是指针类型</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    p2 <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>Person<span class=\"token punctuation\">&#123;</span>age<span class=\"token punctuation\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token comment\">// 指针类型 调用接收者是值类型的方法</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span><span class=\"token function\">GetAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token comment\">// 指针类型 调用接收者也是指针类型的方法</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    p2<span class=\"token punctuation\">.</span><span class=\"token function\">GetAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">.</span><span class=\"token function\">GetAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">18</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">19</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">100</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">101</span></pre></td></tr></table></figure><table><thead><tr><th>函数和方法</th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>方法会使用调用者的一个副本，类似于 “传值”</td><td>使用值的引用来调用方法，上例中，p1.GetAge () 实际上是 (&amp;p1).GetAge ().</td></tr><tr><td>指针类型调用者</td><td>指针被解引用为值，上例中，p2.GetAge () 实际上是 (*p1).GetAge ()</td><td>实际上也是 “传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><p>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法。</p><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。</p><p>通常我们使用指针作为方法的接收者的理由：</p><ul><li><p>使用指针方法能够修改接收者指向的值。</p></li><li><p>可以避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</p></li></ul><p>因而呢，我们是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质。</p><p>如果类型具备 “原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。像内置的引用类型，如 slice，map，interface，channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个 header， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 copy 了这些类型的 header，而 header 本身就是为复制设计的。</p><p>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法。比如 go 源码里的文件结构体（struct File）就不应该被复制，应该只有一份实体。</p><p>接口值的零值是指动态类型和动态值都为 nil。当仅且当这两部分的值都为 nil 的情况下，这个接口值就才会被认为 接口值 == nil。</p><ol start=\"31\"><li><h4 id=\"go的对象在内存中是怎样分配的\"><a class=\"anchor\" href=\"#go的对象在内存中是怎样分配的\">#</a> Go 的对象在内存中是怎样分配的</h4></li></ol><p>Go 中的内存分类并不像 TCMalloc 那样分成小、中、大对象，但是它的小对象里又细分了一个 Tiny 对象，Tiny 对象指大小在 1Byte 到 16Byte 之间并且不包含指针的对象。</p><p>小对象和大对象只用大小划定，无其他区分。</p><p>大对象指大小大于 32kb. 小对象是在 mcache 中分配的，而大对象是直接从 mheap 分配的，从小对象的内存分配看起。</p><p>Go 的内存分配原则:</p><p>Go 在程序启动的时候，会先向操作系统申请一块内存（注意这时还只是一段虚拟的地址空间，并不会真正地分配内存），切成小块后自己进行管理。</p><p>申请到的内存块被分配了三个区域，在 X64 上分别是 512MB，16GB，512GB 大小。<br>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/134.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>arena 区域就是我们所谓的堆区，Go 动态分配的内存都是在这个区域，它把内存分割成 8KB 大小的页，一些页组合起来称为 mspan。</p><p>bitmap 区域标识 arena 区域哪些地址保存了对象，并且用 4bit 标志位表示对象是否包含指针、GC 标记信息。bitmap 中一个 byte 大小的内存对应 arena 区域中 4 个指针大小（指针大小为 8B ）的内存，所以 bitmap 区域的大小是 <code>512GB/(4*8B)=16GB</code> 。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/135.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/136.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>此外我们还可以看到 bitmap 的高地址部分指向 arena 区域的低地址部分，这里 bitmap 的地址是由高地址向低地址增长的。</p><p>spans 区域存放 mspan（是一些 arena 分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以 spans 区域的大小就是 <code>512GB/8KB*8B=512MB</code> 。</p><p>除以 8KB 是计算 arena 区域的页数，而最后乘以 8 是计算 spans 区域所有指针的大小。创建 mspan 的时候，按页填充对应的 spans 区域，在回收 object 时，根据地址很容易就能找到它所属的 mspan。</p><ol start=\"32\"><li><h4 id=\"栈的内存是怎么分配的\"><a class=\"anchor\" href=\"#栈的内存是怎么分配的\">#</a> 栈的内存是怎么分配的</h4></li></ol><p>栈和堆只是虚拟内存上 2 块不同功能的内存区域：</p><ul><li><p>栈在高地址，从高地址向低地址增长。</p></li><li><p>堆在低地址，从低地址向高地址增长。</p></li></ul><p>栈和堆相比优势：</p><ul><li><p>栈的内存管理简单，分配比堆上快。</p></li><li><p>栈的内存不需要回收，而堆需要，无论是主动 free，还是被动的垃圾回收，这都需要花费额外的 CPU。</p></li><li><p>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU 访问的 2 块数据可能在不同的页上，CPU 访问数据的时间可能就上去了。</p></li></ul><ol start=\"33\"><li><h4 id=\"堆内存管理怎么分配的\"><a class=\"anchor\" href=\"#堆内存管理怎么分配的\">#</a> 堆内存管理怎么分配的</h4></li></ol><p>通常在 Golang 中，当我们谈论内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/130.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>堆内存管理中主要是三部分，1. 分配内存块，2. 回收内存块，3. 组织内存块。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/131.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>一个内存块包含了 3 类信息，如下图所示，元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。下图申请 5Byte 内存的时候，就需要进行内存对齐。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/132.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。</p><p>上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将 2 个连续的未使用的内存块合并，减少碎片。</p><p>想要深入了解可以看下这个文章，《Writing a Memory Allocator》.</p><ol start=\"34\"><li><h4 id=\"go中的defer函数使用下面的两种情况下结果是什么\"><a class=\"anchor\" href=\"#go中的defer函数使用下面的两种情况下结果是什么\">#</a> Go 中的 defer 函数使用下面的两种情况下结果是什么</h4></li></ol><p>我们看看下面两种 defer 函数的返回的是什么:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a1:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\ta<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a2:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>the value of a2<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>the value of a1<span class=\"token punctuation\">:</span><span class=\"token number\">1</span></pre></td></tr></table></figure><p>第一种情况：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a1:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>defer 延迟函数调用的 fmt.Println (a) 函数的参数值在 defer 语句出现时就已经确定了，所以无论后面如何修改 a 变量都不会影响延迟函数。</p><p>第二种情况:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>      fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a2:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>defer 延迟函数调用的函数参数的值在 defer 定义时候就确定了，而 defer 延迟函数内部所使用的值需要在这个函数运行时候才确定。</p><ol start=\"35\"><li><h4 id=\"在go函数中为什么会发生内存泄露\"><a class=\"anchor\" href=\"#在go函数中为什么会发生内存泄露\">#</a> 在 Go 函数中为什么会发生内存泄露</h4></li></ol><p>通常内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。</p><p>在 Go 中，由于 goroutine 的存在，因此，内存泄漏除了附着在长期对象上之外，还存在多种不同的形式。</p><ul><li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放.</li></ul><p>当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。</p><ul><li>goroutine 泄漏</li></ul><p>Goroutine 作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。</p><p>因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象.</p><p>例如:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"36\"><li><h4 id=\"go中new和make的区别\"><a class=\"anchor\" href=\"#go中new和make的区别\">#</a> Go 中 new 和 make 的区别</h4></li></ol><p>在 Go 中，的值类型和引用类型:</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>值类型：int，float，bool，string，struct和array.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>引用类型：slice，map，chan和值类型对应的指针.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收。</pre></td></tr></table></figure><p>这里需要注意的是：对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间.</p><p>因此 new 该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// The new built-in function allocates memory. The first argument is a type,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// not a value, and the value returned is a pointer to a newly</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// allocated zero value of that type.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Type<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Type</pre></td></tr></table></figure><p>而 make 也是用于内存分配，但是和 new 不同，只用来引用对象 slice、map 和 channel 的内存创建，它返回的类型就是类型本身，而不是它们的指针类型。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// The make built-in function allocates and initializes an object of type</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// slice, map, or chan (only). Like new, the first argument is a type, not a</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// value. Unlike new, make's return type is the same as the type of its</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// argument, not a pointer to it. The specification of the result depends on</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// the type:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">//\tSlice: The size specifies the length. The capacity of the slice is</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//\tequal to its length. A second integer argument may be provided to</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">//\tspecify a different capacity; it must be no smaller than the</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//\tlength. For example, make([]int, 0, 10) allocates an underlying array</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//\tof size 10 and returns a slice of length 0 and capacity 10 that is</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">//\tbacked by this underlying array.</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">//\tMap: An empty map is allocated with enough space to hold the</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">//\tspecified number of elements. The size may be omitted, in which case</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">//\ta small starting size is allocated.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">//\tChannel: The channel's buffer is initialized with the specified</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">//\tbuffer capacity. If zero, or the size is omitted, the channel is</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">//\tunbuffered.</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span>t Type<span class=\"token punctuation\">,</span> size <span class=\"token operator\">...</span>IntegerType<span class=\"token punctuation\">)</span> Type</pre></td></tr></table></figure><ol start=\"37\"><li><h4 id=\"g0的作用\"><a class=\"anchor\" href=\"#g0的作用\">#</a> G0 的作用</h4></li></ol><p>在 Go 中 g0 作为一个特殊的 goroutine，为 scheduler 执行调度循环提供了场地（栈）。对于一个线程来说，g0 总是它第一个创建的 goroutine。</p><p>之后，它会不断地寻找其他普通的 goroutine 来执行，直到进程退出。</p><p>当需要执行一些任务，且不想扩栈时，就可以用到 g0 了，因为 g0 的栈比较大。</p><p>g0 其他的一些 “职责” 有：创建 <code>goroutine</code> 、 <code>deferproc</code> 函数里新建 <code>_defer</code> 、垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。</p><ol start=\"38\"><li><h4 id=\"go中的锁如何实现\"><a class=\"anchor\" href=\"#go中的锁如何实现\">#</a> Go 中的锁如何实现</h4></li></ol><p>锁是一种同步机制，用于在多任务环境中限制资源的访问，以满足互斥需求。</p><p>go 源码 sync 包中经常用于同步操作的方式:</p><ul><li>原子操作</li><li>互斥锁</li><li>读写锁</li><li>waitgroup</li></ul><p>我们着重来分析下互斥锁和读写锁.</p><p>互斥锁:</p><p>下面是互斥锁的数据结构:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// A Mutex is a mutual exclusion lock.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// The zero value for a Mutex is an unlocked mutex.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// A Mutex must not be copied after first use.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">type</span> Mutex <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tstate <span class=\"token builtin\">int32</span>   <span class=\"token comment\">// 互斥锁上锁状态枚举值如下所示</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tsema  <span class=\"token builtin\">uint32</span>  <span class=\"token comment\">// 信号量，向处于 Gwaitting 的 G 发送信号</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\tmutexLocked <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token boolean\">iota</span> <span class=\"token comment\">// 值为 1，表示在 state 中由低向高第 1 位，意义：锁是否可用，0 可用，1 不可用，锁定中</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tmutexWoken   <span class=\"token comment\">// 值为 2，表示在 state 中由低向高第 2 位，意义：mutex 是否被唤醒</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tmutexStarving <span class=\"token comment\">// 当前的互斥锁进入饥饿状态；</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tmutexWaiterShift <span class=\"token operator\">=</span> <span class=\"token boolean\">iota</span>  <span class=\"token comment\">// 值为 2，表示 state 中统计阻塞在此 mutex 上 goroutine 的数目需要位移的偏移量</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tstarvationThresholdNs <span class=\"token operator\">=</span> <span class=\"token number\">1e6</span></pre></td></tr></table></figure><p>state 和 sema 两个加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 mutexLocked、mutexWoken 和 mutexStarving，剩下的位置用来表示当前有多少个 Goroutine 等待互斥锁的释放.<br>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/138.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>在默认情况下，互斥锁的所有状态位都是 0，int32 中的不同位分别表示了不同的状态：</p><ul><li>mutexLocked 表示互斥锁的锁定状态；</li><li>mutexWoken 表示从正常模式被从唤醒；</li><li>mutexStarving 当前的互斥锁进入饥饿状态；</li><li>waitersCount 当前互斥锁上等待的 Goroutine 个数；</li></ul><p>sync.Mutex 有两种模式，正常模式和饥饿模式。</p><p>在正常模式下，锁的等待者会按照先进先出的顺序获取锁。</p><p>但是刚被唤起的 <code>Goroutine</code> 与新创建的 <code>Goroutine</code> 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被饿死。</p><p>饥饿模式是在 Go 语言 1.9 版本引入的优化的，引入的目的是保证互斥锁的公平性（Fairness）。</p><p>在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。</p><p>如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会被切换回正常模式。</p><p>相比于饥饿模式，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p><p>互斥锁的加锁是靠 sync.Mutex.Lock 方法完成的，当锁的状态是 0 时，将 <code>mutexLocked</code> 位置成 1：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// Lock locks m.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// If the lock is already in use, the calling goroutine</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// blocks until the mutex is available.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token comment\">// Fast path: grab unlocked mutex.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mutexLocked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Acquire</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token comment\">// Slow path (outlined so that the fast path can be inlined)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tm<span class=\"token punctuation\">.</span><span class=\"token function\">lockSlow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果互斥锁的状态不是 0 时就会调用 <code>sync.Mutex.lockSlow</code> 尝试通过自旋（Spinnig）等方式等待锁的释放，</p><p>这个方法是一个非常大 for 循环，它获取锁的过程：</p><ol><li>判断当前 Goroutine 能否进入自旋；</li><li>通过自旋等待互斥锁的释放；</li><li>计算互斥锁的最新状态；</li><li>更新互斥锁的状态并获取锁；</li></ol><p>那么互斥锁是如何判断当前 Goroutine 能否进入自旋等互斥锁的释放，是通过它的 lockSlow 方法，由于自旋是一种多线程同步机制，所以呢当前的进程在进入自旋的过程中会一直保持对 CPU 的占用，持续检查某个条件是否为真。<br>通常在多核的 CPU 上，自旋可以避免 Goroutine 的切换，使用得当会对性能带来很大的增益，但是往往使用的不得当就会拖慢整个程序.</p><p>所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>互斥锁只有在普通模式才能进入自旋；</li><li><code>runtime.sync_runtime_canSpin</code> 需要返回 true：<br>a. 需要运行在多 CPU 的机器上；<br>b. 当前的 Goroutine 为了获取该锁进入自旋的次数小于四次；<br>c. 当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul><p>一旦当前 Goroutine 能够进入自旋就会调用 <code>runtime.sync_runtime_doSpin</code> 和 <code>runtime.procyield</code> 并执行 30 次的 PAUSE 指令，该指令只会占用 CPU 并消耗 CPU 时间.</p><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。</p><p>通过几个不同的条件分别会更新 state 字段中存储的不同信息， <code>mutexLocked</code> 、 <code>mutexStarving</code> 、 <code>mutexWoken</code> 和 <code>mutexWaiterShift</code> ：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin\">new</span> <span class=\"token operator\">:=</span> old</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> old<span class=\"token operator\">&amp;</span>mutexStarving <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token builtin\">new</span> <span class=\"token operator\">|=</span> mutexLocked</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">if</span> old<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>mutexLocked<span class=\"token operator\">|</span>mutexStarving<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token builtin\">new</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> mutexWaiterShift</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">if</span> starving <span class=\"token operator\">&amp;&amp;</span> old<span class=\"token operator\">&amp;</span>mutexLocked <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token builtin\">new</span> <span class=\"token operator\">|=</span> mutexStarving</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">if</span> awoke <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token builtin\">new</span> <span class=\"token operator\">&amp;^=</span> mutexWoken</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>计算了新的互斥锁状态之后，就会使用 CAS 函数 sync/atomic.CompareAndSwapInt32 更新该状态：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> old<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>mutexLocked<span class=\"token operator\">|</span>mutexStarving<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">break</span> <span class=\"token comment\">// 通过 CAS 函数获取了锁</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\t<span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t<span class=\"token function\">runtime_SemacquireMutex</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>sema<span class=\"token punctuation\">,</span> queueLifo<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\tstarving <span class=\"token operator\">=</span> starving <span class=\"token operator\">||</span> <span class=\"token function\">runtime_nanotime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span>waitStartTime <span class=\"token operator\">></span> starvationThresholdNs</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\told <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> old<span class=\"token operator\">&amp;</span>mutexStarving <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t\tdelta <span class=\"token operator\">:=</span> <span class=\"token function\">int32</span><span class=\"token punctuation\">(</span>mutexLocked <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span>mutexWaiterShift<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>starving <span class=\"token operator\">||</span> old<span class=\"token operator\">>></span>mutexWaiterShift <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t\t\tdelta <span class=\"token operator\">-=</span> mutexStarving</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t\tatomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> delta<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\tawoke <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\titer <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\told <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果我们没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 使用信号量保证资源不会被两个 Goroutine 获取。</p><p><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回， <code>sync.Mutex.Lock</code> 方法的剩余代码也会继续执行。</p><p>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环.</p><p>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出.</p><p>互斥锁的解锁过程 <code>sync.Mutex.Unlock</code> 与加锁过程相比就很简单，该过程会先使用 <code>sync/atomic.AddInt32</code> 函数快速解锁，这时会发生下面的两种情况：</p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，这段代码会调用 <code>sync.Mutex.unlockSlow</code> 方法开始慢速解锁：</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Release</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token comment\">// Fast path: drop lock bit.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token builtin\">new</span> <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>mutexLocked<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token builtin\">new</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token comment\">// Outlined slow path to allow inlining the fast path.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token comment\">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\tm<span class=\"token punctuation\">.</span><span class=\"token function\">unlockSlow</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>sync.Mutex.unlockSlow</code> 方法首先会校验锁状态的合法性，如果当前互斥锁已经被解锁过了就会直接抛出异常 <code>sync: unlock of unlocked mutex</code> 中止当前程序。</p><p>在正常情况下会根据当前互斥锁的状态，分别处理正常模式和饥饿模式下的互斥锁.</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">unlockSlow</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span> <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">new</span><span class=\"token operator\">+</span>mutexLocked<span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>mutexLocked <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sync: unlock of unlocked mutex\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token builtin\">new</span><span class=\"token operator\">&amp;</span>mutexStarving <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\told <span class=\"token operator\">:=</span> <span class=\"token builtin\">new</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t<span class=\"token comment\">// If there are no waiters or a goroutine has already</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t<span class=\"token comment\">// been woken or grabbed the lock, no need to wake anyone.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t<span class=\"token comment\">// In starvation mode ownership is directly handed off from unlocking</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\t<span class=\"token comment\">// goroutine to the next waiter. We are not part of this chain,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t<span class=\"token comment\">// since we did not observe mutexStarving when we unlocked the mutex above.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token comment\">// So get off the way.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> old<span class=\"token operator\">>></span>mutexWaiterShift <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> old<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>mutexLocked<span class=\"token operator\">|</span>mutexWoken<span class=\"token operator\">|</span>mutexStarving<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\t<span class=\"token comment\">// Grab the right to wake someone.</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t<span class=\"token builtin\">new</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>old <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span>mutexWaiterShift<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> mutexWoken</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> old<span class=\"token punctuation\">,</span> <span class=\"token builtin\">new</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\t\t<span class=\"token function\">runtime_Semrelease</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>sema<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t\told <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t<span class=\"token comment\">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t<span class=\"token comment\">// our time slice so that the next waiter can start to run immediately.</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t<span class=\"token comment\">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token comment\">// But mutex is still considered locked if mutexStarving is set,</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t<span class=\"token comment\">// so new coming goroutines won't acquire it.</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\t<span class=\"token function\">runtime_Semrelease</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>sema<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在正常模式下，这段代码会分别处理以下两种情况处理:</p><ul><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code> 、 <code>mutexStarving</code> 、 <code>mutexWoken</code> 状态不都为 0，那么当前方法就可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过 <code>sync.runtime_Semrelease</code> 唤醒等待者并移交锁的所有权；</li></ul><p>在饥饿模式下，上述代码会直接调用 <code>sync.runtime_Semrelease</code> 方法将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</p><p>互斥锁的加锁过程比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，就会直接通过置位 mutexLocked 加锁；</li><li>如果互斥锁处于 mutexLocked 并且在普通模式下工作，就会进入自旋，执行 30 次 PAUSE 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过 <code>runtime.sync_runtime_SemacquireMutex</code> 函数将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒当前 Goroutine；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，当前 Goroutine 会将互斥锁切换回正常模式；</li></ul><p>互斥锁的解锁过程与之相比就比较简单，其代码行数不多、逻辑清晰，也比较容易理解：</p><ul><li>当互斥锁已经被解锁时，那么调用 <code>sync.Mutex.Unlock</code> 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，会直接将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，就会直接返回；在其他情况下会通过 <code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine.</li></ul><p>读写锁:</p><p>读写互斥锁 <code>sync.RWMutex</code> 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。</p><p>sync.RWMutex 中总共包含 5 个字段：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> RWMutex <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tw           Mutex  <span class=\"token comment\">// 复用互斥锁提供的能力</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\twriterSem   <span class=\"token builtin\">uint32</span> <span class=\"token comment\">// 写等待读</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\treaderSem   <span class=\"token builtin\">uint32</span> <span class=\"token comment\">// 读等待写</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\treaderCount <span class=\"token builtin\">int32</span>  <span class=\"token comment\">// 存储了当前正在执行的读操作的数量</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\treaderWait  <span class=\"token builtin\">int32</span>  <span class=\"token comment\">// 当写操作被阻塞时等待的读操作个数</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们从写锁开始分析:</p><p>当我们想要获取写锁时，需要调用 <code>sync.RWMutex.Lock</code> 方法:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> rw<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Disable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token comment\">// First, resolve competition with other writers.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\trw<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token comment\">// Announce to readers there is a pending writer.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tr <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerCount<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>rwmutexMaxReaders<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> rwmutexMaxReaders</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token comment\">// Wait for active readers.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">if</span> r <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerWait<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token function\">runtime_SemacquireMutex</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>writerSem<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Acquire</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerSem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Acquire</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>writerSem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul><li>这里调用结构体持有的 <code>sync.Mutex</code> 的 <code>sync.Mutex.Lock</code> 方法阻塞后续的写操作；</li></ul><p>因为互斥锁已经被获取，其他 Goroutine 在获取写锁时就会进入自旋或者休眠；</p><ul><li>调用 <code>sync/atomic.AddInt32</code> 方法阻塞后续的读操作：</li></ul><p>如果仍然有其他 Goroutine 持有互斥锁的读锁 <code>（r != 0）</code> ，该 Goroutine 会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 进入休眠状态等待所有读锁所有者执行结束后释放 <code>writerSem</code> 信号量将当前协程唤醒。</p><p>写锁的释放会调用 <code>sync.RWMutex.Unlock</code> 方法：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> rw<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Release</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerSem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Disable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token comment\">// Announce to readers there is no active writer.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tr <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerCount<span class=\"token punctuation\">,</span> rwmutexMaxReaders<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">if</span> r <span class=\"token operator\">>=</span> rwmutexMaxReaders <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sync: Unlock of unlocked RWMutex\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token comment\">// Unblock blocked readers, if any.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">int</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token function\">runtime_Semrelease</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerSem<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token comment\">// Allow other writers to proceed.</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\trw<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>解锁与加锁的过程正好相反，写锁的释放分为以下几个步骤:</p><ol><li>调用 <code>sync/atomic.AddInt32</code> 函数将 <code>readerCount</code> 变回正数，释放读锁；</li><li>通过 for 循环触发所有由于获取读锁而陷入等待的 Goroutine：</li><li>调用 <code>sync.Mutex.Unlock</code> 方法释放写锁；</li></ol><p>获取写锁时会先阻塞写锁的获取，后阻塞读锁的获取，这种策略能够保证读操作不会被连续的写操作饿死。</p><p>接着是读锁:</p><p>读锁的加锁方法 <code>sync.RWMutex.RLock</code> 就比较简单了，该方法会通过 <code>sync/atomic.AddInt32</code> 将 <code>readerCount</code> 加一：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> rw<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Disable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerCount<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token comment\">// A writer is pending, wait for it.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token function\">runtime_SemacquireMutex</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerSem<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Acquire</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerSem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果 <code>RLock</code> 该方法返回负数，其他 Goroutine 获得了写锁，当前 Goroutine 就会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 陷入休眠等待锁的释放；<br>如果 <code>RLock</code> 该方法的结果为非负数，没有 Goroutine 获得写锁，当前方法就会成功返回.</p><p>当 Goroutine 想要释放读锁时，会调用如下所示的 <code>RUnlock</code> 方法：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">RUnlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> rw<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">.</span>state</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">ReleaseMerge</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>writerSem<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Disable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">if</span> r <span class=\"token operator\">:=</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerCount<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> r <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token comment\">// Outlined slow-path to allow the fast-path to be inlined</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\trw<span class=\"token punctuation\">.</span><span class=\"token function\">rUnlockSlow</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>该方法会先减少正在读资源的 <code>readerCount</code> 整数，根据 <code>sync/atomic.AddInt32</code> 的返回值不同会分别进行处理：</p><ul><li>如果返回值大于等于零，表示读锁直接解锁成功.</li><li>如果返回值小于零，表示有一个正在执行的写操作，在这时会调用 <code>rUnlockSlow</code> 方法.</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>rw <span class=\"token operator\">*</span>RWMutex<span class=\"token punctuation\">)</span> <span class=\"token function\">rUnlockSlow</span><span class=\"token punctuation\">(</span>r <span class=\"token builtin\">int32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span> r<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> r<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span>rwmutexMaxReaders <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Enable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sync: RUnlock of unlocked RWMutex\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token comment\">// A writer is pending.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">AddInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>readerWait<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token comment\">// The last reader unblocks the writer.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token function\">runtime_Semrelease</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>rw<span class=\"token punctuation\">.</span>writerSem<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>rUnlockSlow</code> 该方法会减少获取锁的写操作等待的读操作数 <code>readerWait</code> 并在所有读操作都被释放之后触发写操作的信号量， <code>writerSem</code> ，该信号量被触发时，调度器就会唤醒尝试获取写锁的 Goroutine。</p><p>其实读写互斥锁 (sync.RWMutex), 虽然提供的功能非常复杂，不过因为它是在互斥锁 ( sync.Mutex) 的基础上，所以整体的实现上会简单很多。</p><p>因此呢:</p><ul><li>调用 <code>sync.RWMutex.Lock</code> 尝试获取写锁时；</li></ul><p>每次 <code>sync.RWMutex.RUnlock</code> 都会将 <code>readerCount</code> 其减一，当它归零时该 Goroutine 就会获得写锁，将 <code>readerCount</code> 减少 <code>rwmutexMaxReaders</code> 个数以阻塞后续的读操作.</p><ul><li>调用 <code>sync.RWMutex.Unlock</code> 释放写锁时，会先通知所有的读操作，然后才会释放持有的互斥锁；</li></ul><p>读写互斥锁在互斥锁之上提供了额外的更细粒度的控制，能够在读操作远远多于写操作时提升性能。</p><ol start=\"39\"><li><h4 id=\"go中的channel的实现\"><a class=\"anchor\" href=\"#go中的channel的实现\">#</a> Go 中的 channel 的实现</h4></li></ol><p>在 Go 中最常见的就是通信顺序进程（Communicating sequential processes，CSP）的并发模型，通过共享通信，来实现共享内存，这里就提到了 channel.</p><p>Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/139.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>Goroutine 通过使用 channel 传递数据，一个会向 Channel 中发送数据，另一个会从 Channel 中接收数据，它们两者能够独立运行并不存在直接关联，但是能通过 Channel 间接完成通信。</p><p>Channel 收发操作均遵循了先入先出（FIFO）的设计，具体规则如下：</p><ul><li>先从 Channel 读取数据的 Goroutine 会先接收到数据；</li><li>先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；</li></ul><p>Channel 通常会有以下三种类型：</p><ul><li>同步 Channel — 不需要缓冲区，发送方会直接将数据交给（Handoff）接收方；</li><li>异步 Channel — 基于环形缓存的传统生产者消费者模型；</li><li><code>chan struct{}</code> 类型的异步 <code>Channel</code> 的 <code>struct{}</code> 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义；</li></ul><p>Channel 在运行时使用 <code>runtime.hchan</code> 结构体表示:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> hchan <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tqcount   <span class=\"token builtin\">uint</span>           <span class=\"token comment\">// 当前队列里还剩余元素个数</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tdataqsiz <span class=\"token builtin\">uint</span>           <span class=\"token comment\">// 环形队列长度，即缓冲区的大小，即 make (chan T,N) 中的 N</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tbuf      unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\">// 环形队列指针</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\telemsize <span class=\"token builtin\">uint16</span>         <span class=\"token comment\">// 每个元素的大小</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tclosed   <span class=\"token builtin\">uint32</span>         <span class=\"token comment\">// 标识当前通道是否处于关闭状态，创建通道后，该字段设置 0，即打开通道；通道调用 close 将其设置为 1，通道关闭</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\telemtype <span class=\"token operator\">*</span>_type         <span class=\"token comment\">// 元素类型，用于数据传递过程中的赋值</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tsendx    <span class=\"token builtin\">uint</span>           <span class=\"token comment\">// 环形缓冲区的状态字段，它只是缓冲区的当前索引 - 支持数组，它可以从中发送数据</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\trecvx    <span class=\"token builtin\">uint</span>          <span class=\"token comment\">// 环形缓冲区的状态字段，它只是缓冲区当前索引 - 支持数组，它可以从中接受数据</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\trecvq    waitq         <span class=\"token comment\">// 等待读消息的 goroutine 队列</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tsendq    waitq         <span class=\"token comment\">// 等待写消息的 goroutine 队列</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token comment\">// lock protects all fields in hchan, as well as several</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token comment\">// fields in sudogs blocked on this channel.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token comment\">//</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token comment\">// Do not change another G's status while holding this lock</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token comment\">// (in particular, do not ready a G), as this can deadlock</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token comment\">// with stack shrinking.</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\tlock mutex           <span class=\"token comment\">// 互斥锁，为每个读写操作锁定通道，因为发送和接受必须是互斥操作</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">type</span> waitq <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\tfirst <span class=\"token operator\">*</span>sudog</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\tlast  <span class=\"token operator\">*</span>sudog</pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>其中 hchan 结构体中有五个字段是构建底层的循环队列:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">*</span> qcount — Channel 中的元素个数；</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">*</span> dataqsiz — Channel 中的循环队列的长度；</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">*</span> buf — Channel 的缓冲区数据指针；</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">*</span> sendx — Channel 的发送操作处理到的位置；</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">*</span> recvx — Channel 的接收操作处理到的位置；</pre></td></tr></table></figure><p>通常， <code>elemsize</code> 和 <code>elemtype</code> 分别表示当前 Channel 能够收发的元素类型和大小.</p><p><code>sendq</code> 和 <code>recvq</code> 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 <code>runtime.waitq</code> 表示，链表中所有的元素都是 <code>runtime.sudog</code> 结构.</p><p><code>waitq</code> 表示一个在等待列表中的 Goroutine，该结构体中存储了阻塞的相关信息以及两个分别指向前后 <code>runtime.sudog</code> 的指针。</p><p>channel 在 Go 中是通过 make 关键字创建，编译器会将 make (chan int,10).</p><p>创建管道:</p><p><code>runtime.makechan</code> 和 <code>runtime.makechan64</code> 会根据传入的参数类型和缓冲区大小创建一个新的 Channel 结构，其中后者用于处理缓冲区大小大于 2 的 32 次方的情况.</p><p>这里我们来详细看下 <code>makechan</code> 函数:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">makechan</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>chantype<span class=\"token punctuation\">,</span> size <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>hchan <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\telem <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span>elem</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token comment\">// compiler checks this but be safe.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">if</span> elem<span class=\"token punctuation\">.</span>size <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">16</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"makechan: invalid channel element type\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">if</span> hchanSize<span class=\"token operator\">%</span>maxAlign <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> elem<span class=\"token punctuation\">.</span>align <span class=\"token operator\">></span> maxAlign <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"makechan: bad alignment\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tmem<span class=\"token punctuation\">,</span> overflow <span class=\"token operator\">:=</span> math<span class=\"token punctuation\">.</span><span class=\"token function\">MulUintptr</span><span class=\"token punctuation\">(</span>elem<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">if</span> overflow <span class=\"token operator\">||</span> mem <span class=\"token operator\">></span> maxAlloc<span class=\"token operator\">-</span>hchanSize <span class=\"token operator\">||</span> size <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token function\">plainError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"makechan: size out of range\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token comment\">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token comment\">// buf points into the same allocation, elemtype is persistent.</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t<span class=\"token comment\">// SudoG's are referenced from their owning thread so they can't be collected.</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token comment\">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">var</span> c <span class=\"token operator\">*</span>hchan</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token keyword\">switch</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token keyword\">case</span> mem <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\t<span class=\"token comment\">// Queue or element size is zero.</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\tc <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>hchan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">mallocgc</span><span class=\"token punctuation\">(</span>hchanSize<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t<span class=\"token comment\">// Race detector uses this location for synchronization.</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\tc<span class=\"token punctuation\">.</span>buf <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">raceaddr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t<span class=\"token keyword\">case</span> elem<span class=\"token punctuation\">.</span>ptrdata <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token comment\">// Elements do not contain pointers.</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t<span class=\"token comment\">// Allocate hchan and buf in one call.</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\tc <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>hchan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">mallocgc</span><span class=\"token punctuation\">(</span>hchanSize<span class=\"token operator\">+</span>mem<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\tc<span class=\"token punctuation\">.</span>buf <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hchanSize<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t<span class=\"token comment\">// Elements contain pointers.</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\tc <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>hchan<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t\tc<span class=\"token punctuation\">.</span>buf <span class=\"token operator\">=</span> <span class=\"token function\">mallocgc</span><span class=\"token punctuation\">(</span>mem<span class=\"token punctuation\">,</span> elem<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\tc<span class=\"token punctuation\">.</span>elemsize <span class=\"token operator\">=</span> <span class=\"token function\">uint16</span><span class=\"token punctuation\">(</span>elem<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\tc<span class=\"token punctuation\">.</span>elemtype <span class=\"token operator\">=</span> elem</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\tc<span class=\"token punctuation\">.</span>dataqsiz <span class=\"token operator\">=</span> <span class=\"token function\">uint</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t<span class=\"token function\">lockInit</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">,</span> lockRankHchan<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t<span class=\"token keyword\">if</span> debugChan <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\t<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"makechan: chan=\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> <span class=\"token string\">\"; elemsize=\"</span><span class=\"token punctuation\">,</span> elem<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">,</span> <span class=\"token string\">\"; dataqsiz=\"</span><span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t<span class=\"token keyword\">return</span> c</pre></td></tr><tr><td data-num=\"48\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>Channel 中根据收发元素的类型和缓冲区的大小初始化 <code>runtime.hchan</code> 结构体和缓冲区：</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/134.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>arena 区域就是我们所谓的堆区，Go 动态分配的内存都是在这个区域，它把内存分割成 8KB 大小的页，一些页组合起来称为 mspan。</p><p>bitmap 区域标识 arena 区域哪些地址保存了对象，并且用 4bit 标志位表示对象是否包含指针、GC 标记信息。bitmap 中一个 byte 大小的内存对应 arena 区域中 4 个指针大小（指针大小为 8B ）的内存，所以 bitmap 区域的大小是 512GB/(4*8B)=16GB。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/135.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/136.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>此外我们还可以看到 bitmap 的高地址部分指向 arena 区域的低地址部分，这里 bitmap 的地址是由高地址向低地址增长的。</p><p>spans 区域存放 mspan（是一些 arena 分割的页组合起来的内存管理基本单元，后文会再讲）的指针，每个指针对应一页，所以 spans 区域的大小就是 512GB/8KB*8B=512MB。</p><p>除以 8KB 是计算 arena 区域的页数，而最后乘以 8 是计算 spans 区域所有指针的大小。创建 mspan 的时候，按页填充对应的 spans 区域，在回收 object 时，根据地址很容易就能找到它所属的 mspan。</p><ol start=\"32\"><li><h4 id=\"栈的内存是怎么分配的-2\"><a class=\"anchor\" href=\"#栈的内存是怎么分配的-2\">#</a> 栈的内存是怎么分配的</h4></li></ol><p>栈和堆只是虚拟内存上 2 块不同功能的内存区域：</p><ul><li><p>栈在高地址，从高地址向低地址增长。</p></li><li><p>堆在低地址，从低地址向高地址增长。</p></li></ul><p>栈和堆相比优势：</p><ul><li><p>栈的内存管理简单，分配比堆上快。</p></li><li><p>栈的内存不需要回收，而堆需要，无论是主动 free，还是被动的垃圾回收，这都需要花费额外的 CPU。</p></li><li><p>栈上的内存有更好的局部性，堆上内存访问就不那么友好了，CPU 访问的 2 块数据可能在不同的页上，CPU 访问数据的时间可能就上去了。</p></li></ul><ol start=\"33\"><li><h4 id=\"堆内存管理怎么分配的-2\"><a class=\"anchor\" href=\"#堆内存管理怎么分配的-2\">#</a> 堆内存管理怎么分配的</h4></li></ol><p>通常在 Golang 中，当我们谈论内存管理的时候，主要是指堆内存的管理，因为栈的内存管理不需要程序去操心。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/130.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>堆内存管理中主要是三部分，1. 分配内存块，2. 回收内存块，3. 组织内存块。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/131.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>一个内存块包含了 3 类信息，如下图所示，元数据、用户数据和对齐字段，内存对齐是为了提高访问效率。下图申请 5Byte 内存的时候，就需要进行内存对齐。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/132.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>释放内存实质是把使用的内存块从链表中取出来，然后标记为未使用，当分配内存块的时候，可以从未使用内存块中有先查找大小相近的内存块，如果找不到，再从未分配的内存中分配内存。</p><p>上面这个简单的设计中还没考虑内存碎片的问题，因为随着内存不断的申请和释放，内存上会存在大量的碎片，降低内存的使用率。为了解决内存碎片，可以将 2 个连续的未使用的内存块合并，减少碎片。</p><p>想要深入了解可以看下这个文章，《Writing a Memory Allocator》.</p><ol start=\"34\"><li><h4 id=\"go中的defer函数使用下面的两种情况下结果是什么-2\"><a class=\"anchor\" href=\"#go中的defer函数使用下面的两种情况下结果是什么-2\">#</a> Go 中的 defer 函数使用下面的两种情况下结果是什么</h4></li></ol><p>我们看看下面两种 defer 函数的返回的是什么:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a1:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\ta<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a2:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>运行:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>the value of a1<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>the value of a1<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span></pre></td></tr></table></figure><p>第一种情况：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a1:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>defer 延迟函数调用的 fmt.Println (a) 函数的参数值在 defer 语句出现时就已经确定了，所以无论后面如何修改 a 变量都不会影响延迟函数。</p><p>第二种情况:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>      fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"the value of a2:\"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>defer 延迟函数调用的函数参数的值在 defer 定义时候就确定了，而 defer 延迟函数内部所使用的值需要在这个函数运行时候才确定。</p><ol start=\"35\"><li><h4 id=\"在go函数中为什么会发生内存泄露-2\"><a class=\"anchor\" href=\"#在go函数中为什么会发生内存泄露-2\">#</a> 在 Go 函数中为什么会发生内存泄露</h4></li></ol><p>通常内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。</p><p>在 Go 中，由于 goroutine 的存在，因此，内存泄漏除了附着在长期对象上之外，还存在多种不同的形式。</p><ul><li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放.</li></ul><p>当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。</p><ul><li>goroutine 泄漏</li></ul><p>Goroutine 作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。</p><p>因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象.</p><p>例如:</p><pre><code class=\"language-gow\">func main() {\n\tfor i := 0; i &lt; 10000; i++ {\n\t\tgo func() {\n\t\t\tselect {}\n\t\t}()\n\t}\n}\n</code></pre><ol start=\"36\"><li><h4 id=\"go中new和make的区别-2\"><a class=\"anchor\" href=\"#go中new和make的区别-2\">#</a> Go 中 new 和 make 的区别</h4></li></ol><p>在 Go 中，的值类型和引用类型:</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>值类型：int，float，bool，string，struct和array.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>变量直接存储值，分配栈区的内存空间，这些变量所占据的空间在函数被调用完后会自动释放。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>引用类型：slice，map，chan和值类型对应的指针.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>变量存储的是一个地址（或者理解为指针），指针指向内存中真正存储数据的首地址。内存通常在堆上分配，通过GC回收。</pre></td></tr></table></figure><p>这里需要注意的是：对于引用类型的变量，我们不仅要声明变量，更重要的是，我们得手动为它分配空间.</p><p>因此 new 该方法的参数要求传入一个类型，而不是一个值，它会申请一个该类型大小的内存空间，并会初始化为对应的零值，返回指向该内存空间的一个指针。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// The new built-in function allocates memory. The first argument is a type,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// not a value, and the value returned is a pointer to a newly</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// allocated zero value of that type.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Type<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Type</pre></td></tr></table></figure><p>而 make 也是用于内存分配，但是和 new 不同，只用来引用对象 slice、map 和 channel 的内存创建，它返回的类型就是类型本身，而不是它们的指针类型。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// The make built-in function allocates and initializes an object of type</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// slice, map, or chan (only). Like new, the first argument is a type, not a</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// value. Unlike new, make's return type is the same as the type of its</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// argument, not a pointer to it. The specification of the result depends on</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// the type:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">//\tSlice: The size specifies the length. The capacity of the slice is</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//\tequal to its length. A second integer argument may be provided to</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">//\tspecify a different capacity; it must be no smaller than the</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//\tlength. For example, make([]int, 0, 10) allocates an underlying array</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">//\tof size 10 and returns a slice of length 0 and capacity 10 that is</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">//\tbacked by this underlying array.</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">//\tMap: An empty map is allocated with enough space to hold the</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">//\tspecified number of elements. The size may be omitted, in which case</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">//\ta small starting size is allocated.</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">//\tChannel: The channel's buffer is initialized with the specified</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">//\tbuffer capacity. If zero, or the size is omitted, the channel is</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">//\tunbuffered.</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span>t Type<span class=\"token punctuation\">,</span> size <span class=\"token operator\">...</span>IntegerType<span class=\"token punctuation\">)</span> Type</pre></td></tr></table></figure><ul><li>如果当前 Channel 中不存在缓冲区，那么就只会为 <code>hchan</code> 分配一段内存空间.</li><li>如果当前 Channel 中存储的类型不是指针类型，就会为当前的 Channel 和底层的数组分配一块连续的内存空间.</li><li>在默认情况下会单独为 <code>hchan</code> 和缓冲区分配内存.</li></ul><p>发送数据:</p><p>当我们想要向 Channel 发送数据时，就需要使用 ch &lt;- i 语句.</p><p><code>runtime.chansend1</code> 调用了 <code>runtime.chansend</code> 并传入 Channel 和需要发送的数据。</p><p><code>runtime.chansend</code> 是向 Channel 中发送数据时最终会调用的函数，这个函数负责了发送数据的全部逻辑，如果我们在调用时将 block 参数设置成 true，那么就表示当前发送操作是一个阻塞操作：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">chansend</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>hchan<span class=\"token punctuation\">,</span> ep unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> block <span class=\"token builtin\">bool</span><span class=\"token punctuation\">,</span> callerpc <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>block <span class=\"token operator\">&amp;&amp;</span> c<span class=\"token punctuation\">.</span>closed <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">full</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">var</span> t0 <span class=\"token builtin\">int64</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">if</span> blockprofilerate <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        t0 <span class=\"token operator\">=</span> <span class=\"token function\">cputicks</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">if</span> c<span class=\"token punctuation\">.</span>closed <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token function\">plainError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"send on closed channel\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">if</span> sg <span class=\"token operator\">:=</span> c<span class=\"token punctuation\">.</span>recvq<span class=\"token punctuation\">.</span><span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> sg <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token comment\">// Found a waiting receiver. We pass the value we want to send</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token comment\">// directly to the receiver, bypassing the channel buffer (if any).</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token function\">send</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> sg<span class=\"token punctuation\">,</span> ep<span class=\"token punctuation\">,</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止发生竞争条件。如果 Channel 已经关闭，那么向该 Channel 发送数据时就会报 &quot;send on closed channel&quot; 错误并中止程序。</p><p>因为 <code>runtime.chansend</code> 函数的实现比较复杂，所以我们这里将该函数的执行过程分成以下的三个部分：</p><ul><li>当存在等待的接收者时，通过 runtime.send 直接将数据发送给阻塞的接收者.</li><li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区.</li><li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据.</li></ul><p>因此:</p><p>当我们使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p><ul><li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的 Goroutine；</li><li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们就会直接将数据直接存储到当前缓冲区 sendx 所在的位置上；</li><li>如果不满足上面的两种情况，就会创建一个 <code>runtime.sudog</code> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li></ul><p>发送数据的过程中可能包含几个会触发 Goroutine 调度的时机：</p><ol><li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度.</li><li>发送数据时并没有找到接收方并且缓冲区已经满了，这时就会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <code>runtime.goparkunlock</code> 触发 Goroutine 的调度让出处理器的使用权.</li></ol><p>接收数据:</p><p>接着我们看看接受数据，Go 中可以使用两种不同的方式去接收 Channel 中的数据：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">*</span> i <span class=\"token operator\">&lt;-</span> ch</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">*</span> i<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">&lt;-</span> ch</pre></td></tr></table></figure><p>虽然不同的接收方式会被转换成 <code>runtime.chanrecv1</code> 和 <code>runtime.chanrecv2</code> 两种不同函数的调用，但是这两个函数最终还是会调用 <code>runtime.chanrecv</code> 。</p><p>当我们从一个空 Channel 接收数据时会直接调用 <code>runtime.gopark</code> 直接让出处理器的使用权。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">chanrecv</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span>hchan<span class=\"token punctuation\">,</span> ep unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> block <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>selected<span class=\"token punctuation\">,</span> received <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span> c <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>block <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token function\">gopark</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">,</span> waitReasonChanReceiveNilChan<span class=\"token punctuation\">,</span> traceEvGoStop<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unreachable\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">if</span> c<span class=\"token punctuation\">.</span>closed <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> c<span class=\"token punctuation\">.</span>qcount <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> raceenabled <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\t<span class=\"token function\">raceacquire</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span><span class=\"token function\">raceaddr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> ep <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t\t<span class=\"token function\">typedmemclr</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>elemtype<span class=\"token punctuation\">,</span> ep<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果当前 Channel 已经被关闭并且缓冲区中不存在任何的数据，那么就会清除 <code>ep</code> 指针中的数据并立刻返回。</p><p>除了上述两种特殊情况，使用 <code>runtime.chanrecv</code> 从 Channel 接收数据时还包含以下三种不同情况：</p><ul><li>当存在等待的发送者时，通过 <code>runtime.recv</code> 直接从阻塞的发送者或者缓冲区中获取数据.</li><li>当缓冲区存在数据时，从 Channel 的缓冲区中接收数据.</li><li>当缓冲区中不存在数据时，等待其他 Goroutine 向 Channel 发送数据.</li></ul><p>因此接受数据的时候，Channel 中接收数据时可能会发生的五种情况：</p><ol><li>如果 Channel 为空，那么就会直接调用 <code>runtime.gopark</code> 挂起当前 Goroutine；</li><li>如果 Channel 已经关闭并且缓冲区没有任何数据， <code>runtime.chanrecv</code> 函数会直接返回；</li><li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，就会将 <code>recvx</code> 索引所在的数据拷贝到接收变量所在的内存空间上并将 <code>sendq</code> 队列中 Goroutine 的数据拷贝到缓冲区；</li><li>如果 Channel 的缓冲区中包含数据就会直接读取 recvx 索引对应的数据；</li><li>在默认情况下会挂起当前的 Goroutine，将 <code>runtime.sudog</code> 结构加入 <code>recvq</code> 队列并陷入休眠等待调度器的唤醒；</li></ol><p>从 Channel 接收数据时，会触发 Goroutine 调度的两个时机：</p><ul><li>当 Channel 为空时；</li><li>当缓冲区中不存在数据并且也不存在数据的发送者时；</li></ul><p>最后就是关闭管道:</p><p>编译器会将用于关闭管道的 close 关键字调用 <code>runtime.closechan</code> 的函数关闭。</p><p>当 Channel 是一个空指针或者已经被关闭时，Go 语言运行时都会直接 panic 并抛出异常，处理完了这些异常的情况之后就可以开始执行关闭 Channel 的逻辑.</p><ol start=\"40\"><li><h4 id=\"go中的map的实现\"><a class=\"anchor\" href=\"#go中的map的实现\">#</a> Go 中的 map 的实现</h4></li></ol><p>Go 中 Map 是一个 KV 对集合。底层使用 <code>hash table</code> ，用链表来解决冲突 ，出现冲突时，不是每一个 Key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。</p><p>在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 <code>aes</code> ，如果支持，则使用 <code>aes hash</code> ，否则使用 <code>memhash</code> 。</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hash函数,有加密型和非加密型。加密型的一般用于加密数据、数字摘要等，典型代表就是md5、sha1、sha256、aes256 这种,非加密型的一般就是查找。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>在map的应用场景中，用的是查找。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>选择hash函数主要考察的是两点：性能、碰撞概率。</pre></td></tr></table></figure><p>每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> hmap <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tcount     <span class=\"token builtin\">int</span>    <span class=\"token comment\">// 元素个数</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tflags     <span class=\"token builtin\">uint8</span>  <span class=\"token comment\">// 用来标记状态</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tB         <span class=\"token builtin\">uint8</span>  <span class=\"token comment\">// 扩容常量相关字段 B 是 buckets 数组的长度的对数 2^B</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tnoverflow <span class=\"token builtin\">uint16</span> <span class=\"token comment\">//noverflow 是溢出桶的数量，当 B&lt;16 时，为精确值，当 B>=16 时，为估计值                   \t</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\thash0     <span class=\"token builtin\">uint32</span> <span class=\"token comment\">// 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tbuckets    unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\">// 桶的地址 </span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\toldbuckets unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\">// 旧桶的地址，用于扩容 </span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\tnevacuate  <span class=\"token builtin\">uintptr</span>        <span class=\"token comment\">// 搬迁进度，扩容需要将旧数据搬迁至新数据，这里是利用指针来比较判断有没有迁移 </span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\textra <span class=\"token operator\">*</span>mapextra <span class=\"token comment\">// 用于扩容的指针</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">type</span> mapextra <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\toverflow    <span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>bmap</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\toldoverflow <span class=\"token operator\">*</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>bmap</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token comment\">// nextOverflow holds a pointer to a free overflow bucket.</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\tnextOverflow <span class=\"token operator\">*</span>bmap</pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// A bucket for a Go map.</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">type</span> bmap <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    tophash <span class=\"token punctuation\">[</span>bucketCnt<span class=\"token punctuation\">]</span><span class=\"token builtin\">uint8</span>  <span class=\"token comment\">//tophash 用于记录 8 个 key 哈希值的高 8 位，这样在寻找对应 key 的时候可以更快，不必每次都对 key 做全等判断</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\">// 实际上编辑期间会动态生成一个新的结构体</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">type</span> bmap <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    topbits  <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">uint8</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    keys     <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span>keytype</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    values   <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span>valuetype</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    pad      <span class=\"token builtin\">uintptr</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    overflow <span class=\"token builtin\">uintptr</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>bmap 就是我们常说的 “桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是 “一类” 的，关于 key 的定位我们在 map 的查询和赋值中详细说明。</p><p>在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有 8 个位置)。</p><p>当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。</p><p>但是，我们看 bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 hmap 的 extra 字段来。</p><p>这样随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><p>哈希表作为一种数据结构，我们肯定要分析它的常见操作，首先就是读写操作的原理。哈希表的访问一般都是通过下标或者遍历进行的：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span> v <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> hash <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// k, v</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这两种方式虽然都能读取哈希表的数据，但是使用的函数和底层原理完全不同。</p><p>第一个需要知道哈希的键并且一次只能获取单个键对应的值，而第二个可以遍历哈希中的全部键值对，访问数据时也不需要预先知道哈希的键。</p><p>在编译的类型检查期间， <code>hash[key]</code> 以及类似的操作都会被转换成哈希的 <code>OINDEXMAP</code> 操作，中间代码生成阶段会在 <code>cmd/compile/internal/gc.walkexpr</code> 函数中将这些 <code>OINDEXMAP</code> 操作转换成如下的代码：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>v <span class=\"token operator\">:=</span> hash<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token comment\">// => v     := *mapaccess1(maptype, hash, &amp;key)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>v<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> hash<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token comment\">// => v, ok := mapaccess2(maptype, hash, &amp;key)</span></pre></td></tr></table></figure><p>这里根据赋值语句左侧接受参数的个数会决定使用的运行时方法：</p><p>当接受一个参数时，会使用 <code>runtime.mapaccess1</code> ，该函数仅会返回一个指向目标值的指针；<br>当接受两个参数时，会使用 <code>runtime.mapaccess2</code> ，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 bool 值：</p><p><code>mapaccess1</code> 会先通过哈希表设置的哈希函数、种子获取当前键对应的哈希，再通过 <code>runtime.bucketMask</code> 和 <code>runtime.add</code> 拿到该键值对所在的桶序号和哈希高位的 8 位数字。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/141.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>如果在 bucket 中没有找到，此时如果 overflow 不为空，那么就沿着 overflow 继续查找，如果还是没有找到，那就从别的 key 槽位查找，直到遍历所有 bucket。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">mapaccess1</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">if</span> raceenabled <span class=\"token operator\">&amp;&amp;</span> h <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        callerpc <span class=\"token operator\">:=</span> <span class=\"token function\">getcallerpc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        pc <span class=\"token operator\">:=</span> <span class=\"token function\">funcPC</span><span class=\"token punctuation\">(</span>mapaccess1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token function\">racereadpc</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> callerpc<span class=\"token punctuation\">,</span> pc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token function\">raceReadObjectPC</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> callerpc<span class=\"token punctuation\">,</span> pc<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">if</span> msanenabled <span class=\"token operator\">&amp;&amp;</span> h <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">msanread</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 如果 h 说明都没有，返回零值</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">if</span> h <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> h<span class=\"token punctuation\">.</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">hashMightPanic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 如果哈希函数出错</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span>alg<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// see issue 23734</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>zeroVal<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">// 写和读冲突</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>flags<span class=\"token operator\">&amp;</span>hashWriting <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"concurrent map read and map write\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// 不同类型的 key 需要不同的 hash 算法需要在编译期间确定</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    alg <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span>alg</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">// 利用 hash0 引入随机性，计算哈希值</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    hash <span class=\"token operator\">:=</span> alg<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>hash0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\">// 比如 B=5 那 m 就是 31 二进制是全 1，</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">// 求 bucket num 时，将 hash 与 m 相与，</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">// 达到 bucket num 由 hash 的低 8 位决定的效果，</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token comment\">//bucketMask 函数掩蔽了移位量，省略了溢出检查。</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    m <span class=\"token operator\">:=</span> <span class=\"token function\">bucketMask</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token comment\">//b 即 bucket 的地址</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    b <span class=\"token operator\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>bmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>hash<span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token comment\">//oldbuckets 不为 nil，说明发生了扩容</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token keyword\">if</span> c <span class=\"token operator\">:=</span> h<span class=\"token punctuation\">.</span>oldbuckets<span class=\"token punctuation\">;</span> c <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>h<span class=\"token punctuation\">.</span><span class=\"token function\">sameSizeGrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            <span class=\"token comment\">// 新的 bucket 是旧的 bucket 两倍</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            m <span class=\"token operator\">>>=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        <span class=\"token comment\">// 求出 key 在旧的 bucket 中的位置</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        oldb <span class=\"token operator\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>bmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>hash<span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        <span class=\"token comment\">// 如果旧的 bucket 还没有搬迁到新的 bucket 中，那就在老的 bucket 中寻找</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span><span class=\"token function\">evacuated</span><span class=\"token punctuation\">(</span>oldb<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>            b <span class=\"token operator\">=</span> oldb</pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token comment\">// 计算 tophash 高 8 位</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    top <span class=\"token operator\">:=</span> <span class=\"token function\">tophash</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>bucketloop<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    <span class=\"token comment\">// 遍历所有 overflow 里面的 bucket</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">;</span> b <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">overflow</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token comment\">// 遍历 8 个 bucket</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> bucketCnt<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>            <span class=\"token comment\">//tophash 不匹配，继续</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token keyword\">if</span> b<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>                <span class=\"token keyword\">if</span> b<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> emptyRest <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>                    <span class=\"token keyword\">break</span> bucketloop</pre></td></tr><tr><td data-num=\"57\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>                <span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>            <span class=\"token comment\">//tophash 匹配，定位到 key 的位置</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>            k <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token operator\">+</span>i<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>            <span class=\"token comment\">// 若 key 为指针</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>            <span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectkey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                <span class=\"token comment\">// 解引用</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>                k <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>            <span class=\"token comment\">//key 相等</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>            <span class=\"token keyword\">if</span> alg<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                <span class=\"token comment\">// 定位 value 的位置</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                e <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token operator\">+</span>bucketCnt<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>i<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>elemsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                <span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectelem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>                    <span class=\"token comment\">//value 解引用</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>                    e <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>                <span class=\"token keyword\">return</span> e</pre></td></tr><tr><td data-num=\"76\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>    <span class=\"token comment\">// 没有找到，返回 0 值</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>    <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>zeroVal<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在 bucketloop 循环中，哈希会依次遍历正常桶和溢出桶中的数据，它先会比较哈希的高 8 位和桶中存储的 tophash，后比较传入的和桶中的值以加速数据的读写。用于选择桶序号的是哈希的最低几位，而用于加速访问的是哈希的高 8 位，这种设计能够减少同一个桶中有大量相等 tophash 的概率影响性能。</p><p>因此 bucket 里 key 的起始地址就是 <code>unsafe.Pointer(b)+dataOffset</code> ；第 i 个 key 的地址就要此基础上加 i 个 key 大小；value 的地址是在 key 之后，所以第 i 个 value，要加上所有的 key 的偏移。</p><p>另一个同样用于访问哈希表中数据的 <code>runtime.mapaccess2</code> 只是在 <code>runtime.mapaccess1</code> 的基础上多返回了一个标识键值对是否存在的 bool 值：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">mapaccess2</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bucketloop<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">;</span> b <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">overflow</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> bucketCnt<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> b<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> top <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> b<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> emptyRest <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t\t\t\t<span class=\"token keyword\">break</span> bucketloop</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\tk <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token operator\">+</span>i<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectkey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t\tk <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\t\te <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token operator\">+</span>bucketCnt<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>i<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>elemsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectelem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t\t\t\te <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">return</span> e<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t<span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>zeroVal<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>使用 <code>v, ok := hash[k]</code> 的形式访问哈希表中元素时，我们能够通过这个布尔值更准确地知道当 <code>v == nil</code> 时，v 到底是哈希中存储的元素还是表示该键对应的元素不存在，所以在访问哈希时，我们更推荐使用这种方式判断元素是否存在。</p><p>写入:</p><p>当形如 <code>hash[k]</code> 的表达式出现在赋值符号左侧时，该表达式也会在编译期间转换成 <code>mapassign</code> 函数的调用，该函数与 <code>mapaccess1</code> 比较相似:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">mapassign</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   \thash <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">hasher</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>hash0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   \t<span class=\"token comment\">// Set hashWriting after calling t.hasher, since t.hasher may panic,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   \t<span class=\"token comment\">// in which case we have not actually done a write.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   \th<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">^=</span> hashWriting</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   \t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>buckets <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   \t\th<span class=\"token punctuation\">.</span>buckets <span class=\"token operator\">=</span> <span class=\"token function\">newobject</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucket<span class=\"token punctuation\">)</span> <span class=\"token comment\">// newarray(t.bucket, 1)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   \t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   again<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   \tbucket <span class=\"token operator\">:=</span> hash <span class=\"token operator\">&amp;</span> <span class=\"token function\">bucketMask</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   \t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span><span class=\"token function\">growing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>   \t\t<span class=\"token function\">growWork</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">,</span> bucket<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>   \t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>   \tb <span class=\"token operator\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>bmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> bucket<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>   \ttop <span class=\"token operator\">:=</span> <span class=\"token function\">tophash</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们可以通过遍历比较桶中存储的 <code>tophash</code> 和键的哈希，如果找到了相同结果就会返回目标位置的地址。</p><p>如果当前桶已经满了，哈希会调用 <code>newoverflow</code> 创建新桶或者使用 <code>hmap</code> 预先在 <code>noverflow</code> 中创建好的桶来保存数据，新创建的桶不仅会被追加到已有桶的末尾，还会增加哈希表的 <code>noverflow</code> 计数器。</p><p>如果当前键值对在哈希中不存在，哈希会为新键值对规划存储的内存地址，通过 <code>typedmemmove</code> 将键移动到对应的内存空间中并返回键对应值的地址 val。</p><p>如果当前键值对在哈希中存在，那么就会直接返回目标区域的内存地址，哈希并不会在 <code>mapassign</code> 这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，真正的赋值操作是在编译期间插入的.</p><p>扩容:</p><p>随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要更多的桶和更大的内存保证哈希的读写性能，这个时候我们就需要用到扩容了.</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">mapassign</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  \t<span class=\"token comment\">// Did not find mapping for key. Allocate new cell &amp; add entry.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  \t<span class=\"token comment\">// If we hit the max load factor or we have too many overflow buckets,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  \t<span class=\"token comment\">// and we're not already in the middle of growing, start growing.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  \t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>h<span class=\"token punctuation\">.</span><span class=\"token function\">growing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token function\">overLoadFactor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>count<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token function\">tooManyOverflowBuckets</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>noverflow<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  \t\t<span class=\"token function\">hashGrow</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  \t\t<span class=\"token keyword\">goto</span> again <span class=\"token comment\">// Growing the table invalidates everything, so try again</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  \t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">// 装载因子超过 6.5</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">overLoadFactor</span><span class=\"token punctuation\">(</span>count <span class=\"token builtin\">int64</span><span class=\"token punctuation\">,</span> B <span class=\"token builtin\">uint8</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token keyword\">return</span> count <span class=\"token operator\">>=</span> bucketCnt <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">float32</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> loadFactor<span class=\"token operator\">*</span><span class=\"token function\">float32</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">uint64</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>B<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">// overflow buckets</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">tooManyOverflowBuckets</span><span class=\"token punctuation\">(</span>noverflow <span class=\"token builtin\">uint16</span><span class=\"token punctuation\">,</span> B <span class=\"token builtin\">uint8</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">if</span> B <span class=\"token operator\">&lt;</span> <span class=\"token number\">16</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> noverflow <span class=\"token operator\">>=</span> <span class=\"token function\">uint16</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>B</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token keyword\">return</span> noverflow <span class=\"token operator\">>=</span> <span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">15</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>mapassign</code> 函数会在以下两种情况发生时触发哈希的扩容：</p><ul><li>装载因子已经超过 6.5；</li><li>哈希使用了太多溢出桶；</li></ul><p>不过因为 Go 语言哈希的扩容不是一个原子的过程，所以 <code>mapassign</code> 还需要判断当前哈希是否已经处于扩容状态，避免二次扩容造成混乱。</p><p>根据触发的条件不同扩容的方式分成两种，如果这次扩容是溢出的桶太多导致的，那么这次扩容就是等量扩容 <code>sameSizeGrow</code> ， <code>sameSizeGrow</code> 是一种特殊情况下发生的扩容，当我们持续向哈希中插入数据并将它们全部删除时，如果哈希表中的数据量没有超过阈值，就会不断积累溢出桶造成缓慢的内存泄漏。</p><p><code>runtime: limit the number of map overflow buckets</code> 引入了 <code>sameSizeGrow</code> 通过复用已有的哈希扩容机制解决该问题，一旦哈希中出现了过多的溢出桶，它会创建新桶保存数据，垃圾回收会清理老的溢出桶并释放内存 \\。</p><p>扩容的入口是 <code>hashGrow</code> ：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">hashGrow</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token comment\">// If we've hit the load factor, get bigger.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token comment\">// Otherwise, there are too many overflow buckets,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token comment\">// so keep the same number of buckets and \"grow\" laterally.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// B+1 相当于是原来 2 倍的空间</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tbigger <span class=\"token operator\">:=</span> <span class=\"token function\">uint8</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span><span class=\"token function\">overLoadFactor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>count<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>       <span class=\"token comment\">// 进行等量的内存扩容，所以 B 不变</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\tbigger <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\th<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">|=</span> sameSizeGrow</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 将老 buckets 挂到 buckets 上</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\toldbuckets <span class=\"token operator\">:=</span> h<span class=\"token punctuation\">.</span>buckets</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 申请新的 buckets 空间</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\tnewbuckets<span class=\"token punctuation\">,</span> nextOverflow <span class=\"token operator\">:=</span> <span class=\"token function\">makeBucketArray</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">.</span>B<span class=\"token operator\">+</span>bigger<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\tflags <span class=\"token operator\">:=</span> h<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">&amp;^</span> <span class=\"token punctuation\">(</span>iterator <span class=\"token operator\">|</span> oldIterator<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>flags<span class=\"token operator\">&amp;</span>iterator <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\tflags <span class=\"token operator\">|=</span> oldIterator</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token comment\">// commit the grow (atomic wrt gc)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// 提交 grow 的动作</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\th<span class=\"token punctuation\">.</span>B <span class=\"token operator\">+=</span> bigger</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\th<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">=</span> flags</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\th<span class=\"token punctuation\">.</span>oldbuckets <span class=\"token operator\">=</span> oldbuckets</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\th<span class=\"token punctuation\">.</span>buckets <span class=\"token operator\">=</span> newbuckets</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">// 搬迁进度为 0</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\th<span class=\"token punctuation\">.</span>nevacuate <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token comment\">//overflow buckets 数为 0</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\th<span class=\"token punctuation\">.</span>noverflow <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>extra <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>overflow <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t<span class=\"token comment\">// Promote current overflow buckets to the old generation.</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>oldoverflow <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"oldoverflow is not nil\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t\th<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>oldoverflow <span class=\"token operator\">=</span> h<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>overflow</pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t\th<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>overflow <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t<span class=\"token keyword\">if</span> nextOverflow <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>extra <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t\t\th<span class=\"token punctuation\">.</span>extra <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>mapextra<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t\th<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>nextOverflow <span class=\"token operator\">=</span> nextOverflow</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t<span class=\"token comment\">// the actual copying of the hash table data is done incrementally</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\t<span class=\"token comment\">// by growWork() and evacuate().</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>哈希在扩容的过程中会通过 <code>makeBucketArray</code> 创建一组新桶和预创建的溢出桶，随后将原有的桶数组设置到 <code>oldbuckets</code> 上并将新的空桶设置到 buckets 上，溢出桶也使用了相同的逻辑更新.<br>这里会申请到了新的 buckets 空间，把相关的标志位都进行了处理，例如标志 nevacuate 被置为 0， 表示当前搬迁进度为 0。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/140.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>在 <code>hashGrow</code> 中还看不出来等量扩容和翻倍扩容的太多区别，等量扩容创建的新桶数量只是和旧桶一样，该函数中只是创建了新的桶，并没有对数据进行拷贝和转移。</p><p>哈希表的数据迁移的过程在是 <code>evacuate</code> 中完成的，它会对传入桶中的元素进行再分配。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">evacuate</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> oldbucket <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 这里会定位老的 bucket 地址 </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tb <span class=\"token operator\">:=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>bmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>oldbuckets<span class=\"token punctuation\">,</span> oldbucket<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 结果是 2^B</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tnewbit <span class=\"token operator\">:=</span> h<span class=\"token punctuation\">.</span><span class=\"token function\">noldbuckets</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 如果吧没有搬迁过</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span><span class=\"token function\">evacuated</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token comment\">// TODO: reuse overflow buckets instead of using new ones, if there</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t<span class=\"token comment\">// is no iterator using the old buckets.  (If !oldIterator.)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token comment\">// xy contains the x and y (low and high) evacuation destinations.</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token keyword\">var</span> xy <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>evacDst</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\tx <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>xy<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tx<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>bmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> oldbucket<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\tx<span class=\"token punctuation\">.</span>k <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\tx<span class=\"token punctuation\">.</span>e <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">,</span> bucketCnt<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token comment\">// 如果不是等 size 扩容，前后 bucket 序号有变，使用 y 进行搬迁</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>h<span class=\"token punctuation\">.</span><span class=\"token function\">sameSizeGrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\t<span class=\"token comment\">// Only calculate y pointers if we're growing bigger.</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t<span class=\"token comment\">// Otherwise GC can see bad pointers.</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\ty <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>xy<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t\ty<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>bmap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>oldbucket<span class=\"token operator\">+</span>newbit<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\t\ty<span class=\"token punctuation\">.</span>k <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t\ty<span class=\"token punctuation\">.</span>e <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">,</span> bucketCnt<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token comment\">// 遍历所有老的 bucket 地址</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">;</span> b <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">overflow</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t\tk <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t\te <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">,</span> bucketCnt<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> bucketCnt<span class=\"token punctuation\">;</span> i<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> e <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>elemsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\t\t\ttop <span class=\"token operator\">:=</span> b<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>top<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t\t\t\tb<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> evacuatedEmpty</pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t\t\t\t<span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> top <span class=\"token operator\">&lt;</span> minTopHash <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t\t\t\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bad map state\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t\t\t\tk2 <span class=\"token operator\">:=</span> k</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectkey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t\t\t\t\tk2 <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>k2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">var</span> useY <span class=\"token builtin\">uint8</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>h<span class=\"token punctuation\">.</span><span class=\"token function\">sameSizeGrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t\t\t\t\t<span class=\"token comment\">// Compute hash to make our evacuation decision (whether we need</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t\t\t\t\t<span class=\"token comment\">// to send this key/elem to bucket x or bucket y).</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\t\t\t\t\thash <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">hasher</span><span class=\"token punctuation\">(</span>k2<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>hash0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>\t\t\t\t\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>flags<span class=\"token operator\">&amp;</span>iterator <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">reflexivekey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>k2<span class=\"token punctuation\">,</span> k2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// If key != key (NaNs), then the hash could be (and probably</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// will be) entirely different from the old hash. Moreover,</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// it isn't reproducible. Reproducibility is required in the</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// presence of iterators, as our evacuation decision must</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// match whatever decision the iterator made.</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// Fortunately, we have the freedom to send these keys either</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// way. Also, tophash is meaningless for these kinds of keys.</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// We let the low bit of tophash drive the evacuation decision.</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// We recompute a new random tophash for the next level so</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// these keys will get evenly distributed across all buckets</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>\t\t\t\t\t\t<span class=\"token comment\">// after multiple grows.</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>\t\t\t\t\t\tuseY <span class=\"token operator\">=</span> top <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>\t\t\t\t\t\ttop <span class=\"token operator\">=</span> <span class=\"token function\">tophash</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>\t\t\t\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>\t\t\t\t\t\t<span class=\"token keyword\">if</span> hash<span class=\"token operator\">&amp;</span>newbit <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>\t\t\t\t\t\t\tuseY <span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>\t\t\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>\t\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> evacuatedX<span class=\"token operator\">+</span><span class=\"token number\">1</span> <span class=\"token operator\">!=</span> evacuatedY <span class=\"token operator\">||</span> evacuatedX<span class=\"token operator\">^</span><span class=\"token number\">1</span> <span class=\"token operator\">!=</span> evacuatedY <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>\t\t\t\t\t<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bad evacuatedN\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>\t\t\t\tb<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> evacuatedX <span class=\"token operator\">+</span> useY <span class=\"token comment\">// evacuatedX + 1 == evacuatedY</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>\t\t\t\tdst <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>xy<span class=\"token punctuation\">[</span>useY<span class=\"token punctuation\">]</span>                 <span class=\"token comment\">// evacuation destination</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> dst<span class=\"token punctuation\">.</span>i <span class=\"token operator\">==</span> bucketCnt <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre>\t\t\t\t\tdst<span class=\"token punctuation\">.</span>b <span class=\"token operator\">=</span> h<span class=\"token punctuation\">.</span><span class=\"token function\">newoverflow</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> dst<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>\t\t\t\t\tdst<span class=\"token punctuation\">.</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre>\t\t\t\t\tdst<span class=\"token punctuation\">.</span>k <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataOffset<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>\t\t\t\t\tdst<span class=\"token punctuation\">.</span>e <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">,</span> bucketCnt<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>\t\t\t\tdst<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">.</span>tophash<span class=\"token punctuation\">[</span>dst<span class=\"token punctuation\">.</span>i<span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span>bucketCnt<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> top <span class=\"token comment\">// mask dst.i as an optimization, to avoid a bounds check</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectkey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>\t\t\t\t\t<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> k2 <span class=\"token comment\">// copy pointer</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>\t\t\t\t\t<span class=\"token function\">typedmemmove</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">,</span> dst<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token comment\">// copy elem</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>\t\t\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">indirectelem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>\t\t\t\t\t<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>\t\t\t\t\t<span class=\"token function\">typedmemmove</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>elem<span class=\"token punctuation\">,</span> dst<span class=\"token punctuation\">.</span>e<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre>\t\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre>\t\t\t\tdst<span class=\"token punctuation\">.</span>i<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre>\t\t\t\t<span class=\"token comment\">// These updates might push these pointers past the end of the</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>\t\t\t\t<span class=\"token comment\">// key or elem arrays.  That's ok, as we have the overflow pointer</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>\t\t\t\t<span class=\"token comment\">// at the end of the bucket to protect against pointing past the</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre>\t\t\t\t<span class=\"token comment\">// end of the bucket.</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre>\t\t\t\tdst<span class=\"token punctuation\">.</span>k <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span>k<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre>\t\t\t\tdst<span class=\"token punctuation\">.</span>e <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>dst<span class=\"token punctuation\">.</span>e<span class=\"token punctuation\">,</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>elemsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre>\t\t<span class=\"token comment\">// Unlink the overflow buckets &amp; clear key/elem to help GC.</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>flags<span class=\"token operator\">&amp;</span>oldIterator <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> t<span class=\"token punctuation\">.</span>bucket<span class=\"token punctuation\">.</span>ptrdata <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"105\"></td><td><pre>\t\t\tb <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">.</span>oldbuckets<span class=\"token punctuation\">,</span> oldbucket<span class=\"token operator\">*</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>\t\t\t<span class=\"token comment\">// Preserve b.tophash because the evacuation</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre>\t\t\t<span class=\"token comment\">// state is maintained there.</span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre>\t\t\tptr <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> dataOffset<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>\t\t\tn <span class=\"token operator\">:=</span> <span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> dataOffset</pre></td></tr><tr><td data-num=\"110\"></td><td><pre>\t\t\t<span class=\"token function\">memclrHasPointers</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"111\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>\t<span class=\"token keyword\">if</span> oldbucket <span class=\"token operator\">==</span> h<span class=\"token punctuation\">.</span>nevacuate <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre>\t\t<span class=\"token function\">advanceEvacuationMark</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> newbit<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"116\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>evacuate</code> 会将一个旧桶中的数据分流到两个新桶，所以它会创建两个用于保存分配上下文的 <code>evacDst</code> 结构体，这两个结构体分别指向了一个新桶：</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/142.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>哈希表扩容目的:</p><p>如果这是等量扩容，那么旧桶与新桶之间是一对一的关系，所以两个 <code>evacDst</code> 只会初始化一个。而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中.</p><p>只使用哈希函数是不能定位到具体某一个桶的，哈希函数只会返回很长的哈希，我们还需一些方法将哈希映射到具体的桶上。</p><p>那么如何定位 key 呢？</p><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64 位机，32 位机就不讨论了，现在主流都是 64 位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。</p><p>如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 <code>2^5 = 32</code> 。</p><p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</pre></td></tr></table></figure><p>用最后的 5 个 bit 位，也就是 <code>01010</code> ，值为 10, 那么这个就是 10 号桶。</p><p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p><p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。</p><p>通常哈希冲突的解决手段是用链表法，在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><p>因此哈希表扩容的设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，扩容过程不是原子的，而是通过 <code>growWork</code> 增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流。</p><p>除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow</code> 这一机制，在出现较多溢出桶时会整理哈希的内存减少空间的占用。</p><p>删除:</p><p>如果想要删除哈希中的元素，就需要使用 Go 语言中的 delete 关键字，这个关键字的唯一作用就是将某一个键对应的元素从哈希表中删除，无论是该键对应的值是否存在，这个内建的函数都不会返回任何的结果。</p><p>因此呢 Go 采用拉链法来解决哈希碰撞的问题实现了哈希表，它的访问、写入和删除等操作都在编译期间转换成了运行时的函数或者方法。</p><p>哈希在每一个桶中存储键对应哈希的前 8 位，当对哈希进行操作时，这些 <code>tophash</code> 就成为可以帮助哈希快速遍历桶中元素的缓存。</p><p>哈希表的每个桶都只能存储 8 个键值对，一旦当前哈希的某个桶超出 8 个，新的键值对就会存储到哈希的溢出桶中。</p><p>随着键值对数量的增加，溢出桶的数量和哈希的装载因子也会逐渐升高，超过一定范围就会触发扩容，扩容会将桶的数量翻倍，元素再分配的过程也是在调用写操作时增量进行的，不会造成性能的瞬时巨大损耗。</p><ol start=\"41\"><li><h4 id=\"go中的http包的实现原理\"><a class=\"anchor\" href=\"#go中的http包的实现原理\">#</a> Go 中的 http 包的实现原理</h4></li></ol><p>Golang 中 http 包中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler。</p><p>ServeMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。</p><p>处理器（Handler）负责输出 HTTP 响应的头和正文。任何满足了 http.Handler 接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的 ServeHTTP 方法即可：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ServeHTTP</span><span class=\"token punctuation\">(</span>http<span class=\"token punctuation\">.</span>ResponseWriter<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>http<span class=\"token punctuation\">.</span>Request<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如 <code>FileServer</code> ， <code>NotFoundHandler</code> 和 <code>RedirectHandler</code> 。</p><p>应用示例:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token string\">\"log\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token string\">\"net/http\"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tmux <span class=\"token operator\">:=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">NewServeMux</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\trh <span class=\"token operator\">:=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">RedirectHandler</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http://www.baidu.com\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">307</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tmux<span class=\"token punctuation\">.</span><span class=\"token function\">Handle</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/foo\"</span><span class=\"token punctuation\">,</span> rh<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tlog<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Listening...\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\thttp<span class=\"token punctuation\">.</span><span class=\"token function\">ListenAndServe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":3000\"</span><span class=\"token punctuation\">,</span> mux<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在这个应用示例中，首先在 main 函数中我们只用了 <code>http.NewServeMux</code> 函数来创建一个空的 <code>ServeMux</code> 。 然后我们使用 <code>http.RedirectHandler</code> 函数创建了一个新的处理器，这个处理器会对收到的所有请求，都执行 307 重定向操作到 <code>http://www.baidu.com</code> 。</p><p>接下来我们使用 <code>ServeMux.Handle</code> 函数将处理器注册到新创建的 <code>ServeMux</code> ，所以它在 URL 路径 <code>/foo</code> 上收到所有的请求都交给这个处理器。 最后我们创建了一个新的服务器，并通过 <code>http.ListenAndServe</code> 函数监听所有进入的请求，通过传递刚才创建的 <code>ServeMux</code> 来为请求去匹配对应处理器。</p><p>在浏览器中访问 <code>http://localhost:3000/foo</code> ，你应该能发现请求已经成功的重定向了。</p><p>此刻你应该能注意到一些有意思的事情： <code>ListenAndServer</code> 的函数签名是 <code>ListenAndServe(addr string, handler Handler)</code> ，但是第二个参数我们传递的是个 <code>ServeMux</code> 。</p><p>通过这个例子我们就可以知道， <code>net/http</code> 包在编写 golang web 应用中有很重要的作用，它主要提供了基于 HTTP 协议进行工作的 client 实现和 server 实现，可用于编写 HTTP 服务端和客户端。</p><ol start=\"42\"><li><h4 id=\"goroutine发生了泄漏如何检测\"><a class=\"anchor\" href=\"#goroutine发生了泄漏如何检测\">#</a> Goroutine 发生了泄漏如何检测</h4></li></ol><p>通常内存泄漏，指的是能够预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。</p><p>在 Go 中，由于 Goroutine 的存在，因此，内存泄漏除了附着在长期对象上之外，还存在多种不同的形式。</p><ul><li>预期能被快速释放的内存因被根对象引用而没有得到迅速释放.</li></ul><p>当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。</p><ul><li>Goroutine 泄漏</li></ul><p>Goroutine 作为一种逻辑上理解的轻量级线程，需要维护执行用户代码的上下文信息。在运行过程中也需要消耗一定的内存来保存这类信息，而这些内存在目前版本的 Go 中是不会被释放的。</p><p>因此，如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象.</p><p>可以通过 Go 自带的工具 pprof 或者使用 Gops 去检测诊断当前在系统上运行的 Go 进程的占用的资源.</p><p>例如:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"43\"><li><h4 id=\"go函数返回局部变量的指针是否安全\"><a class=\"anchor\" href=\"#go函数返回局部变量的指针是否安全\">#</a> Go 函数返回局部变量的指针是否安全</h4></li></ol><p>在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</p><ol start=\"44\"><li><h4 id=\"go中两个nil可能不相等吗\"><a class=\"anchor\" href=\"#go中两个nil可能不相等吗\">#</a> Go 中两个 Nil 可能不相等吗</h4></li></ol><p>Go 中两个 Nil 可能不相等。</p><p>接口 (interface) 是对非接口值 (例如指针，struct 等) 的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p><p>两个接口值比较时，会先比较 T，再比较 V。<br>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">var</span> p <span class=\"token operator\">*</span><span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">var</span> i <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token operator\">=</span> p</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> p<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// false</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为 (T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 <code>i == p</code> ，p 与 nil 比较，直接比较值，所以 <code>p == nil</code> 。</p><p>但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil), 与 i (T=*int, V=nil) 不相等，因此 <code>i != nil</code> 。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</p><ol start=\"45\"><li><h4 id=\"goroutine和kernelthread之间是什么关系\"><a class=\"anchor\" href=\"#goroutine和kernelthread之间是什么关系\">#</a> Goroutine 和 KernelThread 之间是什么关系</h4></li></ol><p>首先我们先看下进程和线程还有协程之间的区别:</p><ul><li>进程</li></ul><p>计算机的操作系统模式是一种多任务系统，操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程 (process) 的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。CPU 由操作系统一进行分配，每个进程根据进程的优先级的高低都有机会得到 CPU, 但是如果允许时间超出了一定的时间，操作系统会暂停该进程，将 CPU 资源分配给其他等待的进程。这种 CPU 的分配方式即所谓的抢占式，操作系统可以强制剥夺 CPU 资源并且分配给它认为目前最需要的进程。如果操作系统分配给每个进程的时间都很短，即 CPU 在多个进程间快速地切换，从而造成了很多进程都在同时运行的假象。</p><ul><li>线程</li></ul><p>线程有时被称为轻量级进程（Lightweight Process）, 是程序执行流的最小单元，一个标准的线程由线程 ID, 当前指令指针（PC）、寄存器集合和堆栈组成，通常意义上，一个进程🈶一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）。</p><ul><li>协程</li></ul><p>协程（coroutine）是 Go 语言中的轻量级线程实现，由 Go 运行时（runtime）管理。</p><p>进程、线程、协程的关系和区别：</p><ul><li><p>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</p></li><li><p>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度 (标准线程是的)。</p></li><li><p>协程和线程一样共享堆，不共享栈，协程由程序开发者在协程的代码里显示调度。</p></li></ul><p>为什么协程比线程轻量？</p><p>a. go 协程调用跟切换比线程效率高.</p><p>线程并发执行流程: 线程是内核对外提供的服务，应用程序可以通过系统调用让内核启动线程，由内核来负责线程调度和切换。线程在等待 IO 操作时线程变为 unrunnable 状态会触发上下文切换。现代操作系统一般都采用抢占式调度，上下文切换一般发生在时钟中断和系统调用返回前，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境，最典型的就是切换 ESP 指向目标线程内核堆栈，将 EIP 指向目标线程上次被调度出时的指令地址。</p><p>go 协程并发执行流程：不依赖操作系统和其提供的线程，golang 自己实现的 CSP 并发模型实现：M, P, G .go 协程也叫用户态线程，协程之间的切换发生在用户态。在用户态没有时钟中断，系统调用等机制，因此效率高</p><p>b. go 协程占用内存少.</p><p>执行 go 协程只需要极少的栈内存（大概是 4～5KB），默认情况下，线程栈的大小为 1MB。goroutine 就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个 goroutine，但它们并不是被操作系统所调度执行。</p><p>因此协程和线程一样共享堆，不共享栈，协程由用户态下面的轻量级线程。</p><ol start=\"46\"><li><h4 id=\"为何gpm调度要有p\"><a class=\"anchor\" href=\"#为何gpm调度要有p\">#</a> 为何 GPM 调度要有 P</h4></li></ol><p>我们先看下 go1.0 源码当时是 c 实现的 go 的调度：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>static void</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>G <span class=\"token operator\">*</span>gp<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre> <span class=\"token function\">schedlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>gp <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>gp<span class=\"token operator\">-</span><span class=\"token operator\">></span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">case</span> Grunnable<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">case</span> Gdead<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token comment\">// Shouldn't have been running!</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   runtime·<span class=\"token function\">throw</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bad gp->status in sched\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">case</span> Grunning<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   gp<span class=\"token operator\">-</span><span class=\"token operator\">></span>status <span class=\"token operator\">=</span> Grunnable<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   <span class=\"token function\">gput</span><span class=\"token punctuation\">(</span>gp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>   <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre> gp <span class=\"token operator\">=</span> <span class=\"token function\">nextgandunlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre> gp<span class=\"token operator\">-</span><span class=\"token operator\">></span>readyonstop <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre> gp<span class=\"token operator\">-</span><span class=\"token operator\">></span>status <span class=\"token operator\">=</span> Grunning<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre> m<span class=\"token operator\">-</span><span class=\"token operator\">></span>curg <span class=\"token operator\">=</span> gp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre> gp<span class=\"token operator\">-</span><span class=\"token operator\">></span>m <span class=\"token operator\">=</span> m<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre> <span class=\"token operator\">...</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre> runtime·<span class=\"token function\">gogo</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>gp<span class=\"token operator\">-</span><span class=\"token operator\">></span>sched<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里调度的作用:</p><ul><li>调用 <code>schedlock</code> 方法来获取全局锁。</li><li>获取全局锁成功后，将当前 Goroutine 状态从 Running（正在被调度） 状态修改为 Runnable（可以被调度）状态。</li><li>调用 <code>gput</code> 方法来保存当前 Goroutine 的运行状态等信息，以便于后续的使用。</li><li>调用 <code>nextgandunlock</code> 方法来寻找下一个可运行 Goroutine，并且释放全局锁给其他调度使用。</li><li>获取到下一个待运行的 Goroutine 后，将其运行状态修改为 Running。</li><li>调用 <code>runtime·gogo</code> 方法，将刚刚所获取到的下一个待执行的 Goroutine 运行起来，进入下一轮调度。</li></ul><p>GM 模型的缺点：</p><p>Go1.0 的 GM 模型的 Goroutine 调度器限制了用 Go 编写的并发程序的可扩展性，尤其是高吞吐量服务器和并行计算程序。</p><p>GM 调度存在的问题：</p><ul><li><p>存在单一的全局 mutex（Sched.Lock）和集中状态管理：<br>mutex 需要保护所有与 goroutine 相关的操作（创建、完成、重排等），导致锁竞争严重。</p></li><li><p>Goroutine 传递的问题：</p></li></ul><p>goroutine（G）交接（G.nextg）：工作者线程（M's）之间会经常交接可运行的 goroutine。 而且可能会导致延迟增加和额外的开销。每个 M 必须能够执行任何可运行的 G，特别是刚刚创建 G 的 M。</p><ul><li>每个 M 都需要做内存缓存（M.mcache）：</li></ul><p>这样会导致资源消耗过大（每个 mcache 可以吸纳到 2M 的内存缓存和其他缓存），数据局部性差。</p><ul><li>频繁的线程阻塞 / 解阻塞：</li></ul><p>在存在 syscalls 的情况下，线程经常被阻塞和解阻塞。这增加了很多额外的性能开销。</p><p>为了解决 GM 模型的以上诸多问题，在 <code>Go1.1</code> 时， <code>Dmitry Vyukov</code> 在 GM 模型的基础上，新增了一个 P（Processor）组件。并且实现了 Work Stealing 算法来解决一些新产生的问题。</p><p>加了 P 之后会带来什么改变呢？</p><ul><li>每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。</li><li>每个 P 相对的平衡上，在 GMP 模型中也实现了 <code>Work Stealing</code> 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。</li></ul><p>为什么要有 P 呢？</p><p>一般来讲，M 的数量都会多于 P。像在 Go 中，M 的数量默认是 10000，P 的默认数量的 CPU 核数。另外由于 M 的属性，也就是如果存在系统阻塞调用，阻塞了 M，又不够用的情况下，M 会不断增加。</p><p>M 不断增加的话，如果本地队列挂载在 M 上，那就意味着本地队列也会随之增加。这显然是不合理的，因为本地队列的管理会变得复杂，且 Work Stealing 性能会大幅度下降。</p><p>M 被系统调用阻塞后，我们是期望把他既有未执行的任务分配给其他继续运行的，而不是一阻塞就导致全部停止。</p><p>因此使用 M 是不合理的，那么引入新的组件 P，把本地队列关联到 P 上，就能很好的解决这个问题。</p><ol start=\"47\"><li><h4 id=\"如何在goroutine执行一半就退出协程\"><a class=\"anchor\" href=\"#如何在goroutine执行一半就退出协程\">#</a> 如何在 goroutine 执行一半就退出协程</h4></li></ol><p>在 go 中，调度时候也不是每个 G 都能一直处于运行状态，等 G 不能运行时，就把它存起来，再调度下一个能运行的 G 过来运行。暂时不能运行的 G，P 上会有个本地队列去存放这些这些 G，P 的本地队列存不下的话，还有个全局队列，干的事情也类似。</p><p>在这个这个背景后， 通过 goexit0 观察，做的事情就是将当前的协程 G 置为_Gdead 状态，然后把它从 M 上摘下来，尝试放回到 P 的本地队列中。然后重新调度一波，获取另一个能跑的 G，拿出来跑。</p><p>因此只要执行 goexit 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</p><p>通过 runtime.Goexit () 可以做到提前结束协程，且结束前还能执行到 defer 的内容・runtime.Goexit () 其实是对 goexit0 的封装，只要执行 goexit0 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑</p><h3 id=\"mysql基础知识\"><a class=\"anchor\" href=\"#mysql基础知识\">#</a> Mysql 基础知识</h3><ol><li><h4 id=\"mysql索引用的是什么算法\"><a class=\"anchor\" href=\"#mysql索引用的是什么算法\">#</a> Mysql 索引用的是什么算法</h4></li></ol><p>Mysql 索引选用的是 B + 树，平衡二叉树的高度太高，查找可能需要较多的磁盘 IO。B 树索引占用内存较高 (非叶子节点存储数据)。</p><p>B + 树，主要是查询效率高，O (logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据.</p><ol start=\"2\"><li><h4 id=\"mysql事务的基本要素\"><a class=\"anchor\" href=\"#mysql事务的基本要素\">#</a> Mysql 事务的基本要素</h4></li></ol><ul><li>原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。</li><li>隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</li><li>持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li></ul><ol start=\"3\"><li><h4 id=\"mysql的存储引擎\"><a class=\"anchor\" href=\"#mysql的存储引擎\">#</a> Mysql 的存储引擎</h4></li></ol><ul><li>InnoDB 存储引擎</li></ul><p>InnoDB 存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。</p><p>其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从 Mysql5.5.8 版本开始，InnoDB 存储引擎是默认的存储引擎。</p><ul><li>MyISAM 存储引擎</li></ul><p>MyISAM 存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些 OLAP 数据库应用。</p><p>InnoDB 的数据文件本身就是主索引文件，而 MyISAM 的主索引和数据是分开的。</p><ul><li>NDB 存储引擎</li></ul><p>NDB 存储引擎是一个集群存储引擎，其结构是 share nothing 的集群架构，能提供更高的可用性。</p><p>NDB 的特点是数据全部放在内存中（从 MySQL 5.1 版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，并且通过添加 NDB 数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统。<br>NDB 存储引擎的连接操作是在 MySQL 数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB 存储引擎的市场应该是非常巨大的。</p><ul><li>Memory 存储引擎</li></ul><p>Memory 存储引擎（之前称 HEAP 存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。<br>它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory 存储引擎默认使用哈希索引，而不是我们熟悉的 B + 树索引。<br>虽然 Memory 存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持 TEXT 和 BLOB 列类型。最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存。</p><ul><li>Archive 存储引擎</li></ul><p>Archive 存储引擎只支持 INSERT 和 SELECT 操作，从 MySQL 5.1 开始支持索引。<br>Archive 存储引擎使用 zlib 算法将数据行（row）进行压缩后存储，压缩比一般可达 1∶10。正如其名字所示，Archive 存储引擎非常适合存储归档数据，如日志信息。<br>Archive 存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。</p><ul><li>Maria 存储引擎</li></ul><p>Maria 存储引擎是新开发的引擎，设计目标主要是用来取代原有的 MyISAM 存储引擎，从而成为 MySQL 的默认存储引擎。它可以看做是 MyISAM 的后续版本。<br>Maria 存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了 MVCC 功能，支持事务和非事务安全的选项，以及更好的 BLOB 字符类型的处理性能。</p><ol start=\"4\"><li><h4 id=\"mysql事务隔离级别\"><a class=\"anchor\" href=\"#mysql事务隔离级别\">#</a> Mysql 事务隔离级别</h4></li></ol><p>Mysql 有四种事务隔离级别，默认的是可重复读.</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交\te</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li>读未提交 (Read uncommitted)</li></ul><p>一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证。</p><p>(1) 所有事务都可以看到其他未提交事务的执行结果<br>(2) 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少<br>(3) 该级别引发的问题是 —— 脏读 (Dirty Read)：读取到了未提交的数据</p><ul><li>读已提交 (Read committed)</li></ul><p>一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生。</p><p>(1) 这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）<br>(2) 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变<br>(3) 这种隔离级别出现的问题是 —— 不可重复读 (Nonrepeatable Read), 不可重复读意味着我们在同一个事务中执行完全相同的 select 语句时可能看到不一样的结果。</p><p>导致这种情况的原因可能有：</p><p>(1) 有一个交叉的事务有新的 commit，导致了数据的改变；<br>(2) 一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的 commit.</p><ul><li>可重复读 (Repeatable read)</li></ul><p>就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生。</p><p>(1) 这是 MySQL 的默认事务隔离级别.<br>(2) 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行.<br>(3) 此级别可能出现的问题 —— 幻读 (Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影” 行.<br>(4) InnoDB 和 Falcon 存储引擎通过多版本并发控制 (MVCC，Multiversion Concurrency Control) 机制解决了该问题.InnoDB 采用 MVCC 来支持高并发，实现了四个标准隔离级别。默认基本是可重复读，并且提供间隙锁（next-key locks）策略防止幻读出现。</p><ul><li>串行 (Serializable)</li></ul><p>串行 (Serializable)，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。<br>但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。Mysql 的默认隔离级别是 Repeatable read。</p><p>(1) 这是最高的隔离级别.<br>(2) 它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。<br>(3) 在这个级别，可能导致大量的超时现象和锁竞争.</p><ol start=\"5\"><li><h4 id=\"mysql高可用方案有哪些\"><a class=\"anchor\" href=\"#mysql高可用方案有哪些\">#</a> Mysql 高可用方案有哪些</h4></li></ol><p>Mysql 高可用方案包括:</p><ul><li>主从复制方案</li></ul><p>这是 MySQL 自身提供的一种高可用解决方案，数据同步方法采用的是 <code>MySQL replication</code> 技术。 <code>MySQL replication</code> 就是从服务器到主服务器拉取二进制日志文件，然后再将日志文件解析成相应的 SQL 在从服务器上重新执行一遍主服务器的操作，通过这种方式保证数据的一致性。<br>为了达到更高的可用性，在实际的应用环境中，一般都是采用 <code>MySQL replication</code> 技术配合高可用集群软件 <code>keepalived</code> 来实现自动 <code>failover</code> ，这种方式可以实现 95.000% 的 SLA。</p><ul><li>MMM/MHA 高可用方案</li></ul><p>MMM 提供了 MySQL 主主复制配置的监控、故障转移和管理的一套可伸缩的脚本套件。在 MMM 高可用方案中，典型的应用是双主多从架构，通过 MySQL replication 技术可以实现两个服务器互为主从，且在任何时候只有一个节点可以被写入，避免了多点写入的数据冲突。<br>同时，当可写的主节点故障时，MMM 套件可以立刻监控到，然后将服务自动切换到另一个主节点，继续提供服务，从而实现 MySQL 的高可用。</p><ul><li>Heartbeat/SAN 高可用方案</li></ul><p>在这个方案中，处理 failover 的方式是高可用集群软件 Heartbeat，它监控和管理各个节点间连接的网络，并监控集群服务，当节点出现故障或者服务不可用时，自动在其他节点启动集群服务。<br>在数据共享方面，通过 SAN（Storage Area Network）存储来共享数据，这种方案可以实现 99.990% 的 SLA。</p><ul><li>Heartbeat/DRBD 高可用方案</li></ul><p>这个方案处理 failover 的方式上依旧采用 Heartbeat，不同的是，在数据共享方面，采用了基于块级别的数据同步软件 DRBD 来实现。<br>DRBD 是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。和 SAN 网络不同，它并不共享存储，而是通过服务器之间的网络复制数据。</p><ul><li>NDB CLUSTER 高可用方案</li></ul><p>国内用 NDB 集群的公司非常少，貌似有些银行有用。NDB 集群不需要依赖第三方组件，全部都使用官方组件，能保证数据的一致性，某个数据节点挂掉，其他数据节点依然可以提供服务，管理节点需要做冗余以防挂掉。<br>缺点是：管理和配置都很复杂，而且某些 SQL 语句例如 join 语句需要避免。</p><ol start=\"6\"><li><h4 id=\"mysql中utf8和utf8mb4区别\"><a class=\"anchor\" href=\"#mysql中utf8和utf8mb4区别\">#</a> Mysql 中 utf8 和 utf8mb4 区别</h4></li></ol><p>MySQL 在 5.5.3 之后增加了这个 <code>utf8mb4</code> 的编码，mb4 就是 <code>most bytes 4</code> 的意思，专门用来兼容四字节的 <code>unicode</code> 。好在 <code>utf8mb4</code> 是 <code>utf8</code> 的超集，除了将编码改为 <code>utf8mb4</code> 外不需要做其他转换。当然，为了节省空间，一般情况下使用 utf8 也就可以了。</p><p>Mysql 支持的 <code>utf8</code> 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 <code>Unicode</code> 字符是 <code>0xffff</code> ，也就是 <code>Unicode</code> 中的基本多文种平面 (BMP)。任何不在基本多文本平面的 Unicode 字符，都无法使用 Mysql 的 <code>utf8</code> 字符集存储。</p><p>包括 Emoji 表情 (Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上)，和很多不常用的汉字，以及任何新增的 Unicode 字符等等。</p><p>Mysql 中保存 4 字节长度的 UTF-8 字符，需要使用 <code>utf8mb4</code> 字符集，但只有 5.5.3 版本以后的才支持 (查看版本： select version ()😉。因此呢，为了获取更好的兼容性，应该总是使用 <code>utf8mb4</code> 而非 utf8.</p><p>对于 CHAR 类型数据， <code>utf8mb4</code> 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR 替代 CHAR。</p><ol start=\"7\"><li><h4 id=\"mysql中乐观锁和悲观锁区别\"><a class=\"anchor\" href=\"#mysql中乐观锁和悲观锁区别\">#</a> Mysql 中乐观锁和悲观锁区别</h4></li></ol><ul><li>悲观锁 (Pessimistic Lock)</li></ul><p>悲观锁顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。</p><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><ul><li>乐观锁 (Optimistic Lock),</li></ul><p>乐观锁顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 <code>write_condition</code> 机制的其实都是提供的乐观锁。</p><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即 “乐观” 的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p><p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span> SELECT data AS old_data<span class=\"token punctuation\">,</span> version AS old_version FROM …<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span> 根据获取的数据进行业务操作，得到new_data和new_version</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span> UPDATE SET data <span class=\"token operator\">=</span> new_data<span class=\"token punctuation\">,</span> version <span class=\"token operator\">=</span> new_version WHERE version <span class=\"token operator\">=</span> old_version</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>updated row <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 乐观锁获取成功，操作完成</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 乐观锁获取失败，回滚并重试</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部 update 同一行的时候是不允许并发的，即数据库每次执行一条 update 语句时会获取被 update 行的写锁，直到这一行被成功更新后才释放。</p><p>因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。</p><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果经常产生冲突，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><ol start=\"8\"><li><h4 id=\"mysql索引主要是哪些\"><a class=\"anchor\" href=\"#mysql索引主要是哪些\">#</a> Mysql 索引主要是哪些</h4></li></ol><p>索引的目的在于提高查询效率.</p><p>索引的类型：</p><ul><li>UNIQUE (唯一索引)：不可以出现相同的值，可以有 NULL 值</li><li>INDEX (普通索引)：允许出现相同的索引内容</li><li>PROMARY KEY (主键索引)：不允许出现相同的值</li><li>fulltext index (全文索引)：可以针对值中的某个单词，但效率确实不敢恭维</li><li>组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</li></ul><p>索引虽然好处很多，但过多的使用索引可能带来相反的问题，索引也是有缺点的：</p><ul><li><p>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT,UPDATE 和 DELETE。因为更新表时，mysql 不仅要保存数据，还要保存一下索引文件.</p></li><li><p>建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽，索引只是提高效率的一个方式，如果 mysql 有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句。</p></li></ul><p>使用索引时，有一些技巧：</p><ul><li>索引不会包含有 NULL 的列</li></ul><p>只要列中包含有 NULL 值，都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此符合索引就是无效的。</p><ul><li>使用短索引</li></ul><p>对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个 char（255）的列，如果在前 10 个或 20 个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。</p><ul><li>索引列排序</li></ul><p>mysql 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</p><ul><li>like 语句操作</li></ul><p>一般情况下不鼓励使用 like 操作，如果非使用不可，注意正确的使用方式。 <code>like ‘%aaa%’</code> 不会使用索引，而 <code>like ‘aaa%’</code> 可以使用索引。</p><ul><li><p>不要在列上进行运算</p></li><li><p>不使用 <code>NOT IN</code> 、 <code>&lt;&gt;</code> 、 <code>！=</code> 操作，但 <code>&lt;</code> , <code>&lt;=</code> ， <code>=</code> ， <code>&gt;</code> , <code>&gt;=</code> ,BETWEEN,IN 是可以用到索引的</p></li><li><p>索引要建立在经常进行 select 操作的字段上。<br>这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p></li><li><p>索引要建立在值比较唯一的字段上。</p></li><li><p>对于那些定义为 text、image 和 bit 数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。</p></li><li><p>在 where 和 join 中出现的列需要建立索引。</p></li><li><p>where 的查询条件里有不等号 (where column != …),mysql 将无法使用索引。</p></li><li><p>如果 where 字句的查询条件里使用了函数 (如：where DAY (column)=…),mysql 将无法使用索引。</p></li><li><p>在 join 操作中 (需要从多个数据表提取数据时)，mysql 只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。</p></li></ul><p>组合索引的作用:</p><ol><li>减少开销。</li></ol><p>建一个组合索引 (col1,col2,col3)，实际相当于建了 (col1),(col1,col2),(col1,col2,col3) 三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。<br>对于大量数据的表，使用组合索引会大大的减少开销。</p><ol start=\"2\"><li>覆盖索引。</li></ol><p>通常指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。</p><p>对组合索引 (col1,col2,col3)，如果有如下的 <code>sql: select col1,col2,col3 from test where col1=1 and col2=2</code> 。</p><p>那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 io 操作。减少 io 操作，特别的随机 io 其实是 dba 主要的优化策略。</p><p>所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</p><ol start=\"3\"><li>效率高。</li></ol><p>索引列越多，通过索引筛选出的数据越快。</p><ol start=\"9\"><li><h4 id=\"mysql联合索引最左匹配原则\"><a class=\"anchor\" href=\"#mysql联合索引最左匹配原则\">#</a> Mysql 联合索引最左匹配原则</h4></li></ol><p>最左前缀匹配原则：</p><ol><li>在 MySQL 建立联合索引时会遵守最左前缀匹配原则，即最左优先.</li></ol><p>在检索数据时从联合索引的最左边开始匹配，Mysql 会一直向右匹配直到遇到范围查询（ <code>&gt;、&lt;、between、like</code> ）就停止匹配了.</p><p>就比如 <code>a=3 and b=4 and c&gt;5 and d=6</code> 如果建立 (abcd) 顺序的索引，d 就用不到索引了，如果建立 (abdc) 的索引则都可以用到索引，其中 abd 的顺序可以任意调整，因为查询优化器会重新编排（即使是 c&gt;5 and b=4 and d=6 and a=3 也会全部用到 abdc 索引 ）.</p><ol start=\"2\"><li><code>=</code> 和 <code>in</code> 可以乱序，比如 <code>a=1 and b=2 and c=3</code> 建立 (abc) 索引可以任意顺序，mysql 查询优化器会优化顺序.</li></ol><p>这里需要注意下，比如 abc 索引 那么只要查询条件有 a 即可用到 abc 索引（如 abc ab ac a）, 没有 a 就用不到。</p><p>最左前缀匹配成因：Mysql 是创建复合索引的规则是根据索引最左边的字段进行排序，在第一个字段排序的基础上再进行第二个字段排序，类似于 <code>order by col1，col2…</code> 所以第一个字段是绝对有序的 第二个字段就是无序的了，所以 Mysql 强调最左前缀匹配.</p><ol start=\"10\"><li><h4 id=\"聚簇索引和非聚簇索引区别\"><a class=\"anchor\" href=\"#聚簇索引和非聚簇索引区别\">#</a> 聚簇索引和非聚簇索引区别</h4></li></ol><p>聚簇索引与非聚簇索引的区别是：叶子节点是否存放一整行记录.</p><p>InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/143.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ol><li><p>对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据 (包含了主键值)，二级索引的叶结点存储行的主键值。<br>使用的是 B + 树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录 (数据内容)。</p></li><li><p>对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是 B + 树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引 + 索引对应的记录的数据。</p></li></ol><p>因此，聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针.</p><ol start=\"11\"><li><h4 id=\"如何查询一个字段是否命中了索引\"><a class=\"anchor\" href=\"#如何查询一个字段是否命中了索引\">#</a> 如何查询一个字段是否命中了索引</h4></li></ol><p>通过 explain sql 可看下 SQL 是否走了索引，很快对比出来 .</p><p>当一个 sql 中索引字段为 int 类型时，例如搜索条件 <code>where num=&quot;111&quot;</code> 与 <code>where num=111</code> 都可以使用该字段的索引。当一个中索引字段为 varchar 类型时，例如搜索条件 <code>where num=&quot;111&quot;</code> 可以使用索引， <code>where num=111</code> 不可以使用索引.</p><ol start=\"12\"><li><h4 id=\"mysql中查询数据什么情况下不会命中索引\"><a class=\"anchor\" href=\"#mysql中查询数据什么情况下不会命中索引\">#</a> Mysql 中查询数据什么情况下不会命中索引</h4></li></ol><p>通常不命中索引有接种情况:</p><ul><li>索引规范不合理，sql 解析器不命中索引.</li><li>表中索引是以表中数据量字段最多的建立的索引，sql 解析器不命中索引.(实际就是索引没用，最后全局查找了)</li><li>bool 的字段做索引，sql 选择器不命中索引.</li><li>模糊查询 % like</li><li>索引列参与计算，使用了函数</li><li>非最左前缀顺序</li><li>where 对 null 判断</li><li>where 不等于</li><li>or 操作有至少一个字段没有索引</li><li>需要回表的查询结果集过大（超过配置的范围）</li></ul><ol start=\"13\"><li><h4 id=\"mysql中的mvcc是什么\"><a class=\"anchor\" href=\"#mysql中的mvcc是什么\">#</a> Mysql 中的 MVCC 是什么</h4></li></ol><p>数据库并发控制 —— 锁，Multiversion (version) concurrency control (MCC or MVCC) 多版本并发控制 ，它是数据库管理系统一种常见的并发控制。</p><p>并发控制常用的是锁，当线程要对一个共享资源进行操作的时候，加锁是一种非常简单粗暴的方法 (事务开始时给 DQL 加读锁，给 DML 加写锁)，这种锁是一种 悲观 的实现方式，也就是说这会给其他事务造成堵塞，从而影响数据库性能。</p><p>其中在数据库中最常见的就是悲观锁和乐观锁:</p><ul><li>悲观锁</li></ul><p>当一个线程需要对共享资源进行操作的时候，首先对共享资源进行加锁，当该线程持有该资源的锁的时候，其他线程对该资源进行操作的时候会被阻塞.</p><ul><li>乐观锁</li></ul><p>当一个线程需要对一个共享资源进行操作的时候，不对它进行加锁，而是在操作完成之后进行判断。<br>比如乐观锁会通过一个版本号控制，如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了，如果有则通知操作失败，如果没有则操作成功，当然除了版本号还有 CAS，如果不了解的可以去学习一下，这里不做过多涉及。</p><p>MVCC 的两种读形式:</p><ul><li>快照读</li></ul><p>读取的只是当前事务的可见版本，不用加锁。而你只要记住 简单的 <code>select</code> 操作就是快照读 (select * from table where id = xxx)。</p><ul><li>当前读</li></ul><p>读取的是当前版本，比如 特殊的读操作，更新 / 插入 / 删除操作.</p><p>比如：</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>select <span class=\"token italic\"><span class=\"token punctuation\">*</span><span class=\"token content\"> from table where xxx lock in share mode，</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> select <span class=\"token punctuation\">*</span> from table where xxx for update，</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> update table set....</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> insert into table (xxx,xxx) values (xxx,xxx)</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> delete from table where id = xxx</pre></td></tr></table></figure><p>MVCC 的实现原理:</p><p>MVCC 使用了 “三个隐藏字段” 来实现版本并发控制，MySQL 在创建建表的时候 innoDB 创建的真正的三个隐藏列吧。</p><table><thead><tr><th>RowID</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th><th>id</th><th>name</th><th>password</th></tr></thead><tbody><tr><td>自动创建的 id</td><td>事务 id</td><td>回滚指针</td><td>id</td><td>name</td><td>password</td></tr></tbody></table><ul><li><p>RowID：隐藏的自增 ID，当建表没有指定主键，InnoDB 会使用该 RowID 创建一个聚簇索引。</p></li><li><p>DB_TRX_ID：最近修改（更新 / 删除 / 插入）该记录的事务 ID。</p></li><li><p>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本。</p></li></ul><p>其实还有一个删除的 flag 字段，用来判断该行记录是否已经被删除。</p><p>而 MVCC 使用的是其中的 事务字段，回滚指针字段，是否删除字段。</p><p>我们来看一下现在的表格 (isDelete 是我自己取的，按照官方说法是在一行开头的 content 里面，这里其实位置无所谓，你只要知道有就行了)。</p><table><thead><tr><th>isDelete</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th><th>id</th><th>name</th><th>password</th></tr></thead><tbody><tr><td>true/false</td><td>事务 id</td><td>回滚指针</td><td>id</td><td>name</td><td>password</td></tr></tbody></table><ol start=\"14\"><li><h4 id=\"mvcc和redolog和undolog以及binlog有什么不同\"><a class=\"anchor\" href=\"#mvcc和redolog和undolog以及binlog有什么不同\">#</a> Mvcc 和 Redolog 和 Undolog 以及 Binlog 有什么不同</h4></li></ol><ul><li>Mvcc</li></ul><p>MVCC 多版本并发控制是 MySQL 中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在 MySQL 中，会在表中每一条数据后面添加两个字段，最近修改该行数据的事务 ID，指向该行（undolog 表中）回滚段的指针。</p><p>Read View 判断行的可见性，创建一个新事务时，copy 一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务 id 列表。</p><ul><li>UndoLog</li></ul><p>UndoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及 MVCC 中对于数据历史版本的查看。由引擎层的 InnoDB 引擎实现，是逻辑日志，记录数据修改被修改前的值，比如 &quot; 把 id='B' 修改为 id = 'B2' ，那么 undo 日志就会用来存放 id ='B' 的记录”。</p><p>当一条数据需要更新前，会先把修改前的记录存储在 undolog 中，如果这个修改出现异常，，则会使用 undo 日志来实现回滚操作，保证事务的一致性。当事务提交之后，undo log 并不能立马被删除，而是会被放到待清理链表中，待判断没有事物用到该版本的信息时才可以清理相应 undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读 (MVCC) 也即非锁定读。</p><ul><li>Redolog</li></ul><p>Redolog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。</p><p>Redolog 包括两部分：</p><p>一。是内存中的日志缓冲 (redo log buffer)，该部分日志是易失性的；</p><p>二。是磁盘上的重做日志文件 (redo log file)，该部分日志是持久的。</p><p>由引擎层的 InnoDB 引擎实现，是物理日志，记录的是物理数据页修改的信息，比如 “某个数据页上内容发生了哪些改动”。当一条数据需要更新时，InnoDB 会先将数据更新，然后记录 redoLog 在内存中，然后找个时间将 redoLog 的操作执行到磁盘上的文件上。<br>不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。</p><ul><li>Binlog</li></ul><p>Binlog 由 Mysql 的 Server 层实现，是逻辑日志，记录的是 sql 语句的原始逻辑，比如 &quot; 把 id='B' 修改为 id = ‘B2’。</p><p>Binlog 会写入指定大小的物理文件中，是追加写入的，当前文件写满则会创建新的文件写入。</p><p>产生：事务提交的时候，一次性将事务中的 sql 语句，按照一定的格式记录到 binlog 中。</p><p>用于复制和恢复在主从复制中，从库利用主库上的 binlog 进行重播 (执行日志中记录的修改逻辑), 实现主从同步。业务数据不一致或者错了，用 binlog 恢复。</p><ol start=\"15\"><li><h4 id=\"mysql读写分离以及主从同步\"><a class=\"anchor\" href=\"#mysql读写分离以及主从同步\">#</a> Mysql 读写分离以及主从同步</h4></li></ol><ul><li><p>原理：主库将变更写 binlog 日志，然后从库连接到主库后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个 sql 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再执行一遍 sql，这样就可以保证自己跟主库的数据一致。</p></li><li><p>问题：这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行 sql 特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以 mysql 实际上有两个机制，一个是半同步复制，用来解决主库数据丢失问题，一个是并行复制，用来解决主从同步延时问题。</p></li><li><p>半同步复制：semi-sync 复制，指的就是主库写入 binlog 日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库 ack 之后才会认为写完成。</p></li><li><p>并发复制：指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）</p></li></ul><ol start=\"16\"><li><h4 id=\"innodb的关键特性\"><a class=\"anchor\" href=\"#innodb的关键特性\">#</a> InnoDB 的关键特性</h4></li><li><p>插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个 Insert Buffer 对象中。然后再以一定的频率和情况进行 Insert Buffer 和辅助索引页子节点的 merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p></li><li><p>两次写：两次写带给 InnoDB 存储引擎的是数据页的可靠性，有经验的 DBA 也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到 page 页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过 memcpy 函数将脏页先复制到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次，每次 1MB 顺序地写入共享表空间的物理磁盘上，这就是 doublewrite。</p></li><li><p>自适应哈希索引：InnoDB 存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。</p></li><li><p>异步 IO：为了提高磁盘操作性能，当前的数据库系统都采用异步 IO（AIO）的方式来处理磁盘操作。AIO 的另一个优势是可以进行 IO Merge 操作，也就是将多个 IO 合并为 1 个 IO，这样可以提高 IOPS 的性能。</p></li><li><p>刷新邻接页：当刷新一个脏页时，InnoDB 存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过 AIO 可以将多个 IO 写入操作合并为一个 IO 操作，故该工作机制在传统机械磁盘下有着显著的优势。</p></li><li><h4 id=\"mysql如何保证一致性和持久性\"><a class=\"anchor\" href=\"#mysql如何保证一致性和持久性\">#</a> Mysql 如何保证一致性和持久性</h4></li></ol><p>Mysql 为了保证 <code>ACID</code> 中的一致性和持久性，使用了 WAL ( <code>Write-Ahead Logging</code> , 先写日志再写磁盘)。 <code>Redo log</code> 就是一种 WAL 的应用。</p><p>当数据库忽然掉电，再重新启动时，Mysql 可以通过 <code>Redo log</code> 还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新 <code>Redo log</code> 就足够了。</p><ol start=\"18\"><li><h4 id=\"为什么选择b树作为索引结构\"><a class=\"anchor\" href=\"#为什么选择b树作为索引结构\">#</a> 为什么选择 B + 树作为索引结构</h4></li></ol><ul><li><p>Hash 索引：Hash 索引底层是哈希表，哈希表是一种以 key-value 存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而 B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</p></li><li><p>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。</p></li><li><p>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。</p></li><li><p>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL 旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO 次数太多。</p></li><li><p>B + 树：在 B 树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。<br>此外，B + 树，主要是查询效率高，O (logN)，可以充分利用磁盘预读的特性，多叉树，深度小，叶子结点有序且存储数据.</p></li></ul><ol start=\"19\"><li><h4 id=\"innodb的行锁模式\"><a class=\"anchor\" href=\"#innodb的行锁模式\">#</a> InnoDB 的行锁模式</h4></li></ol><ul><li>共享锁 (S)：用法 lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li></ul><p>若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。</p><ul><li>排他锁 (X)：用法 for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。<br>若事务 T 对数据对象 A 加上 X 锁，事务 T 可以读 A 也可以修改 A，其他事务不能再对 A 加任何锁，直到 T 释放 A 上的锁。在没有索引的情况下，InnoDB 只能使用表锁。</li></ul><ol start=\"20\"><li><h4 id=\"哈希hash比树tree更快索引结构为什么要设计成树型\"><a class=\"anchor\" href=\"#哈希hash比树tree更快索引结构为什么要设计成树型\">#</a> 哈希 (hash) 比树 (tree) 更快，索引结构为什么要设计成树型</h4></li></ol><p>加速查找速度的数据结构，常见的有两类：</p><ul><li>哈希，例如 HashMap，查询 / 插入 / 修改 / 删除的平均时间复杂度都是 O (1)；</li><li>树，例如平衡二叉搜索树，查询 / 插入 / 修改 / 删除的平均时间复杂度都是 O (lg (n))；</li></ul><p>哈希只能满足等值查询，不满足范围和大小查询，其次哈希不可以排序.</p><p>Mysql 是用等值查询，用树的话，等值查询只需要顺序遍历即可.</p><p>但是对于排序查询的 sql 需求：分组： <code>group by</code> , 排序： <code>order by</code> , 比较： <code>&lt;、&gt;</code> 等，哈希型的索引，时间复杂度会退化为 O (n)，而树型的 “有序” 特性，依然能够保持 O (log (n)) 的高效率。</p><ol start=\"21\"><li><h4 id=\"为什么索引的key长度不能太长\"><a class=\"anchor\" href=\"#为什么索引的key长度不能太长\">#</a> 为什么索引的 key 长度不能太长</h4></li></ol><p>key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。</p><ol start=\"22\"><li><h4 id=\"mysql的数据如何恢复到任意时间点\"><a class=\"anchor\" href=\"#mysql的数据如何恢复到任意时间点\">#</a> Mysql 的数据如何恢复到任意时间点</h4></li></ol><p>恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点。</p><ol start=\"23\"><li><h4 id=\"mysql为什么加了索引可以加快查询\"><a class=\"anchor\" href=\"#mysql为什么加了索引可以加快查询\">#</a> Mysql 为什么加了索引可以加快查询</h4></li></ol><p>在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。</p><p>索引的优缺点:</p><p>优势：可以快速检索，减少 I/O 次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；</p><p>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的 1.5 倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表.</p><ol start=\"24\"><li><h4 id=\"explain命令有什么用\"><a class=\"anchor\" href=\"#explain命令有什么用\">#</a> Explain 命令有什么用</h4></li></ol><p>在开发的过程中，我们有时会用慢查询去记录一些执行时间比较久的 Sql 语句，找出这些 Sql 语句并不意味着完事了，这个时候我们就需要用到 explain 这个命令来查看一个这些 Sql 语句的执行计划，查看该 Sql 语句有没有使用上了索引，有没有做全表扫描，这些都可以通过 explain 命令来查看。<br>所以我们深入了解 Mysql 的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行 SQL 语句时哪种策略预计会被优化器采用。</p><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> explain <span class=\"token keyword\">select</span> * from server<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>+----+-------------+---------+------+---------------+------+---------+------+------+-------+</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token function\">id</span> <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> table   <span class=\"token operator\">|</span> <span class=\"token builtin class-name\">type</span> <span class=\"token operator\">|</span> possible_keys <span class=\"token operator\">|</span> key  <span class=\"token operator\">|</span> key_len <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> rows <span class=\"token operator\">|</span> Extra <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>+----+-------------+---------+------+---------------+------+---------+------+------+-------+</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> SIMPLE      <span class=\"token operator\">|</span> server  <span class=\"token operator\">|</span> ALL  <span class=\"token operator\">|</span> NULL          <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">1</span> <span class=\"token operator\">|</span> NULL  <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>+----+-------------+---------+------+---------------+------+---------+------+------+-------+</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.03</span> sec<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>expain 出来的信息有 10 列，分别是 <code>id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra</code> .</p><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>id: select选择标识符.</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>select_type: 表示查询的类型.</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>table: 输出结果集的表.</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>partitions: 匹配的分区.</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>type: 表示表的连接类型.</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>possible_keys: 表示查询时，可能使用的索引.</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>key: 表示实际使用的索引.</pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>key_len: 索引字段的长度.</pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>ref: 列与索引的比较.</pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>rows: 扫描出的行数(估算的行数).</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>filtered: 按表条件过滤的行百分比.</pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>Extra: 执行情况的描述和说明.</pre></td></tr></table></figure><ul><li>id</li></ul><p>id 是 Sql 执行的顺序的标识，Sql 从大到小的执行:</p><ol><li><p>id 相同时，执行顺序由上至下.</p></li><li><p>如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行.</p></li><li><p>id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行.</p></li></ol><ul><li>select_type 查询的类型</li></ul><p>示查询中每个 select 子句的类型:</p><ol><li><p>SIMPLE (简单 SELECT, 不使用 UNION 或子查询等)</p></li><li><p>PRIMARY (查询中若包含任何复杂的子部分，最外层的 select 被标记为 PRIMARY)</p></li><li><p>UNION (UNION 中的第二个或后面的 SELECT 语句)</p></li><li><p>DEPENDENT UNION (UNION 中的第二个或后面的 SELECT 语句，取决于外面的查询)</p></li><li><p>UNION RESULT (UNION 的结果)</p></li><li><p>SUBQUERY (子查询中的第一个 SELECT)</p></li><li><p>DEPENDENT SUBQUERY (子查询中的第一个 SELECT，取决于外面的查询)</p></li><li><p>DERIVED (派生表的 SELECT, FROM 子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY (一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li></ol><ul><li>table</li></ul><p>table 显示这一行的数据是关于哪张表的，有时不是真实的表名字，看到的是 derivedx.</p><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> explain <span class=\"token keyword\">select</span> * from <span class=\"token punctuation\">(</span>select * from <span class=\"token punctuation\">(</span> <span class=\"token keyword\">select</span> * from t1 where <span class=\"token assign-left variable\">id</span><span class=\"token operator\">=</span><span class=\"token number\">2602</span><span class=\"token punctuation\">)</span> a<span class=\"token punctuation\">)</span> b<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token function\">id</span> <span class=\"token operator\">|</span> select_type <span class=\"token operator\">|</span> table      <span class=\"token operator\">|</span> <span class=\"token builtin class-name\">type</span>   <span class=\"token operator\">|</span> possible_keys     <span class=\"token operator\">|</span> key     <span class=\"token operator\">|</span> key_len <span class=\"token operator\">|</span> ref  <span class=\"token operator\">|</span> rows <span class=\"token operator\">|</span> Extra <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">|</span>  <span class=\"token number\">1</span> <span class=\"token operator\">|</span> PRIMARY     <span class=\"token operator\">|</span> <span class=\"token operator\">&lt;</span>derived<span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span> <span class=\"token operator\">|</span> system <span class=\"token operator\">|</span> NULL              <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">1</span> <span class=\"token operator\">|</span>       <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">|</span>  <span class=\"token number\">2</span> <span class=\"token operator\">|</span> DERIVED     <span class=\"token operator\">|</span> <span class=\"token operator\">&lt;</span>derived<span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>></span> <span class=\"token operator\">|</span> system <span class=\"token operator\">|</span> NULL              <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL    <span class=\"token operator\">|</span> NULL <span class=\"token operator\">|</span>    <span class=\"token number\">1</span> <span class=\"token operator\">|</span>       <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">|</span>  <span class=\"token number\">3</span> <span class=\"token operator\">|</span> DERIVED     <span class=\"token operator\">|</span> t1         <span class=\"token operator\">|</span> const  <span class=\"token operator\">|</span> PRIMARY,idx_t1_id <span class=\"token operator\">|</span> PRIMARY <span class=\"token operator\">|</span> <span class=\"token number\">4</span>       <span class=\"token operator\">|</span>      <span class=\"token operator\">|</span>    <span class=\"token number\">1</span> <span class=\"token operator\">|</span>       <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>+----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+</pre></td></tr></table></figure><ul><li>type 表的连接类型</li></ul><p>type 表示 Mysql 在表中找到所需行的方式，又称 “访问类型”。</p><p>常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）.</p><ol><li><p>ALL：Full Table Scan， Mysql 将遍历全表以找到匹配的行.</p></li><li><p>index: Full Index Scan，index 与 ALL 区别为 index 类型只遍历索引树.</p></li><li><p>range: 只检索给定范围的行，使用一个索引来选择行.</p></li><li><p>ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值.</p></li><li><p>eq_ref: 类似 ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联条件.</p></li><li><p>const、system: 当 Mysql 对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于 where 列表中，Mysql 就能将该查询转换为一个常量，system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system.</p></li><li><p>NULL: Mysql 在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p></li></ol><ul><li>possible_keys</li></ul><p>possible_keys 指出 Mysql 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用.</p><p>该列完全独立于 <code>EXPLAIN</code> 输出所示的表的次序。这意味着在 <code>possible_keys</code> 中的某些键实际上不能按生成的表次序使用。<br>如果该列是 NULL，则没有相关的索引。在这种情况下，可以通过检查 WHERE 子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用 EXPLAIN 检查查询.</p><ul><li>Key</li></ul><p>key 列显示 MySql 实际决定使用的键（索引）.</p><p>如果没有选择索引，键是 NULL。要想强制 Mysql 使用或忽视 <code>possible_keys</code> 列中的索引，在查询中使用 <code>FORCE INDEX、USE INDEX</code> 或者 <code>IGNORE INDEX</code> 。</p><ul><li>key_len</li></ul><p>key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的）不损失精确性的情况下，长度越短越好 .</p><ul><li>ref</li></ul><p>ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值.</p><ul><li>rows</li></ul><p>rows 表示 Mysql 根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数.</p><ul><li>Extra 执行情况的描述和说明</li></ul><p>该列包含 Mysql 解决查询的详细信息，有以下几种情况：</p><ol><li><p>Using where: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示 mysql 服务器将在存储引擎检索行后再进行过滤.</p></li><li><p>Using temporary：表示 Mysql 需要使用临时表来存储结果集，常见于排序和分组查询.</p></li><li><p>Using filesort：Mysql 中无法利用索引完成的排序操作称为 “文件排序”</p></li><li><p>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p></li><li><p>Impossible where：这个值强调了 where 语句会导致没有符合条件的行。</p></li><li><p>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行.</p></li></ol><h3 id=\"redis基础知识\"><a class=\"anchor\" href=\"#redis基础知识\">#</a> Redis 基础知识</h3><ol><li><h4 id=\"redis的数据结构及使用场景\"><a class=\"anchor\" href=\"#redis的数据结构及使用场景\">#</a> Redis 的数据结构及使用场景</h4></li></ol><ul><li>String 字符串</li></ul><p>字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享 Session、限速等。</p><ul><li>Hash 哈希</li></ul><p>在 Redis 中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。</p><ul><li>List 列表（双向链表）</li></ul><p>列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。</p><ul><li>Set 集合</li></ul><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。<br>利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><ul><li>Sorted Set 有序集合（跳表实现）</li></ul><p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。</p><ol start=\"2\"><li><h4 id=\"redis持久化的几种方式\"><a class=\"anchor\" href=\"#redis持久化的几种方式\">#</a> Redis 持久化的几种方式</h4></li></ol><p>Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</p><p>Redis 的持久化策略有两种：</p><ol><li>RDB：快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。</li></ol><p>当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。当子进程完成写临时文件后，将原来的 RDB 替换掉。</p><ol start=\"2\"><li>AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。</li></ol><p>使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 <code>appendonly.aof</code> 中。<br>aof 的默认策略是每秒钟 fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。</p><p>缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。</p><p>Redis 默认是快照 RDB 的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）, 全同步结束后，进行增量同步 (AOF)。</p><ol start=\"3\"><li><h4 id=\"redis的lru具体实现\"><a class=\"anchor\" href=\"#redis的lru具体实现\">#</a> Redis 的 LRU 具体实现</h4></li></ol><p>传统的 LRU 是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行 <code>select *</code> 的时候大量非热点数据占领头部数据，所以需要改进。<br>Redis 每次按 key 获取一个值的时候，都会更新 value 中的 lru 字段为当前秒级别的时间戳。Redis 初始的实现算法很简单，随机从 dict 中取出五个 key, 淘汰一个 lru 字段值最小的。</p><p>在 3.0 的时候，又改进了一版算法，首先第一次随机选取的 key 都会放入一个 pool 中 (pool 的大小为 16),pool 中的 key 是按 lru 大小顺序排列的。<br>接下来每次随机选取的 keylru 值必须小于 pool 中最小的 lru 才会继续放入，直到将 pool 放满。放满之后，每次如果有新的 key 需要放入，需要将 pool 中 lru 最大的一个 key 取出。淘汰的时候，直接从 pool 中选取一个 lru 最小的值然后将其淘汰。</p><ol start=\"4\"><li><h4 id=\"单线程的redis为什么快\"><a class=\"anchor\" href=\"#单线程的redis为什么快\">#</a> 单线程的 Redis 为什么快</h4></li></ol><ul><li><p>纯内存操作</p></li><li><p>单线程操作，避免了频繁的上下文切换</p></li><li><p>合理高效的数据结构</p></li><li><p>采用了非阻塞 I/O 多路复用机制</p></li></ul><ol start=\"5\"><li><h4 id=\"redis的数据过期策略\"><a class=\"anchor\" href=\"#redis的数据过期策略\">#</a> Redis 的数据过期策略</h4></li></ol><p>Redis 中数据过期策略采用定期删除和惰性删除策略:</p><ul><li>定期删除策略</li></ul><p>Redis 启用一个定时器定时监视所有的 key，判断 key 是否过期，过期的话就删除。</p><p>这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。</p><ul><li>惰性删除策略</li></ul><p>在获取 key 时，先判断 key 是否过期，如果过期则删除。</p><p>这种方式存在一个缺点：如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。</p><p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的 key，基本上满足了所有要求。</p><p>但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？</p><p>这个时候就需要用到了，内存淘汰机制.</p><p>内存淘汰机制分为：</p><ul><li><p>当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略）</p></li><li><p>当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU 推荐使用）</p></li><li><p>当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。</p></li><li><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。</p></li><li><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。</p></li><li><p>当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。</p></li></ul><ol start=\"6\"><li><h4 id=\"如何解决redis缓存雪崩问题\"><a class=\"anchor\" href=\"#如何解决redis缓存雪崩问题\">#</a> 如何解决 Redis 缓存雪崩问题</h4></li></ol><ul><li><p>使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉</p></li><li><p>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效</p></li><li><p>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务</p></li></ul><ol start=\"7\"><li><h4 id=\"如何解决redis缓存穿透问题\"><a class=\"anchor\" href=\"#如何解决redis缓存穿透问题\">#</a> 如何解决 Redis 缓存穿透问题</h4></li></ol><ul><li><p>在接口层做校验</p></li><li><p>存 null 值（缓存击穿加锁）</p></li><li><p>布隆过滤器拦截：将所有可能的查询 key 先映射到布隆过滤器中，查询时先判断 key 是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。<br>布隆过滤器将值进行多次哈希 bit 存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。</p></li></ul><ol start=\"8\"><li><h4 id=\"redis并发竞争key如何解决\"><a class=\"anchor\" href=\"#redis并发竞争key如何解决\">#</a> Redis 并发竞争 key 如何解决</h4></li></ol><ul><li><p>可以利用分布式锁和时间戳来解决.</p></li><li><p>利用消息队列解决.</p></li></ul><ol start=\"9\"><li><h4 id=\"redis的主从模式和哨兵模式和集群模式区别\"><a class=\"anchor\" href=\"#redis的主从模式和哨兵模式和集群模式区别\">#</a> Redis 的主从模式和哨兵模式和集群模式区别</h4></li></ol><p>Redis 集群方式共有三种：主从模式，哨兵模式，集群 (cluster) 模式</p><ul><li>主从模式</li></ul><p>主从模式是三种集群方式里最简单的。它主要是基于 Redis 的主从复制特性架构的。通常我们会设置一个主节点，N 个从节点；默认情况下，主节点负责处理使用者的 IO 操作，而从节点则会对主节点的数据进行备份，并且也会对外提供读操作的处理。</p><p>主要的特点如下：</p><ol><li><p>主从模式下，当某一节点损坏时，因为其会将数据备份到其它 Redis 实例上，这样做在很大程度上可以恢复丢失的数据。</p></li><li><p>主从模式下，可以保证负载均衡.</p></li><li><p>主从模式下，主节点和从节点是读写分离的。使用者不仅可以从主节点上读取数据，还可以很方便的从从节点上读取到数据，这在一定程度上缓解了主机的压力。</p></li></ol><p>从节点也是能够支持写入数据的，只不过从从节点写入的数据不会同步到主节点以及其它的从节点下。</p><p>从以上，我们不难看出 Redis 在主从模式下，必须保证主节点不会宕机 —— 一旦主节点宕机，其它节点不会竞争称为主节点，此时，Redis 将丧失写的能力。这点在生产环境中，是致命的。</p><ul><li>哨兵模式</li></ul><p>哨兵模式是基于主从模式做的一定变化，它能够为 Redis 提供了高可用性。</p><p>在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的。</p><p>而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。其实，哨兵模式的核心还是主从复制。</p><p>只不过相对于主从模式在主节点宕机导致不可写的情况下，多了一个竞选机制 —— 从所有的从节点竞选出新的主节点。竞选机制的实现，是依赖于在系统中启动一个 sentinel 进程。</p><p>sentinel 特点：</p><ul><li><p>监控：它会监听主服务器和从服务器之间是否在正常工作。</p></li><li><p>通知：它能够通过 API 告诉系统管理员或者程序，集群中某个实例出了问题。</p></li><li><p>故障转移：它在主节点出了问题的情况下，会在所有的从节点中竞选出一个节点，并将其作为新的主节点。</p></li><li><p>提供主服务器地址：它还能够向使用者提供当前主节点的地址。这在故障转移后，使用者不用做任何修改就可以知道当前主节点地址。</p></li></ul><p>sentinel，也可以集群，部署多个哨兵，sentinel 可以通过发布与订阅来自动发现 Redis 集群上的其它 sentinel。sentinel 在发现其它 sentinel 进程后，会将其放入一个列表中，这个列表存储了所有已被发现的 sentinel。</p><p>集群中的所有 sentinel 不会并发着去对同一个主节点进行故障转移。故障转移只会从第一个 sentinel 开始，当第一个故障转移失败后，才会尝试下一个。</p><p>当选择一个从节点作为新的主节点后，故障转移即成功了 (而不会等到所有的从节点配置了新的主节点后)。这过程中，如果重启了旧的主节点，那么就会出现无主节点的情况，这种情况下，只能重启集群。</p><p>当竞选出新的主节点后，被选为新的主节点的从节点的配置信息会被 sentinel 改写为旧的主节点的配置信息。完成改写后，再将新主节点的配置广播给所有的从节点。</p><ul><li>集群模式</li></ul><p>Redis 集群是一个提供在多个 Redis 间节点间共享数据的程序集，其中 Redis 集群分为主节点和从节点。主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令请求。</p><p>Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同的节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误.</p><p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令. Redis 集群的优势:</p><p>自动分割数据到不同的节点上。</p><p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</p><p>Redis 集群的数据分片 Redis 集群没有使用一致性 hash, 而是引入了哈希槽的概念.</p><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分 hash 槽.</p><p>例如，当前集群有 3 个节点，那么:</p><ul><li><p>节点 A 包含 0 到 5500 号哈希槽.</p></li><li><p>节点 B 包含 5501 到 11000 号哈希槽.</p></li><li><p>节点 C 包含 11001 到 16384 号哈希槽.</p></li></ul><p>这种结构很容易添加或者删除节点。比如如果我想新添加个节点 D, 我需要从节点 A, B, C 中得部分槽到 D 上.</p><p>如果我想移除节点 A, 需要将 A 中的槽移到 B 和 C 节点上，然后将没有任何槽的 A 节点从集群中移除即可.</p><p>由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.</p><p>Redis 集群的主从复制模型 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有 N-1 个复制品.</p><ol start=\"10\"><li><h4 id=\"redis有序集合zset底层怎么实现的\"><a class=\"anchor\" href=\"#redis有序集合zset底层怎么实现的\">#</a> Redis 有序集合 zset 底层怎么实现的</h4></li></ol><p>Redis 中的 set 数据结构底层用的是跳表和哈希表实现的 (新的版本优化).</p><p>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p><ul><li>跳表是可以实现二分查找的有序链表；</li><li>每个元素插入时随机生成它的 level；</li><li>最低层包含所有的元素；</li><li>如果一个元素出现在 level (x)，那么它肯定出现在 x 以下的 level 中；</li><li>每个索引节点包含两个指针，一个向下，一个向右；</li><li>跳表查询、插入、删除的时间复杂度为 O (log n)，与平衡二叉树接近；</li></ul><p>为什么 Redis 选择使用跳表而不是红黑树来实现有序集合？(O (logN))</p><p>首先，我们来分析下 Redis 的有序集合支持的操作：</p><ul><li>插入元素</li><li>删除元素</li><li>查找元素</li><li>有序输出所有元素</li><li>查找区间内所有元素</li></ul><p>其中，前 4 项红黑树都可以完成，且时间复杂度与跳表一致。但是，最后一项，红黑树的效率就没有跳表高了。<br>在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。</p><p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。<br>此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以 Redis 选择使用跳表来实现有序集合。</p><ol start=\"11\"><li><h4 id=\"跳表的查询过程是怎么样的查询和插入的时间复杂度\"><a class=\"anchor\" href=\"#跳表的查询过程是怎么样的查询和插入的时间复杂度\">#</a> 跳表的查询过程是怎么样的，查询和插入的时间复杂度</h4></li></ol><p>先从第一层查找，不满足就下沉到第二层找，因为每一层都是有序的，写入和插入的时间复杂度都是 O (logN)</p><ol start=\"12\"><li><h4 id=\"redis如何分片\"><a class=\"anchor\" href=\"#redis如何分片\">#</a> redis 如何分片</h4></li></ol><p>Redis Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中三个为主节点，三个为从节点。三个主节点会分配槽，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。一般来说，主 Redis 节点会处理 Clients 的读写操作，而从节点只处理读操作。</p><p>分布式数据存储方案中最为重要的一点就是数据分片，也就是所谓的 Sharding。</p><p>为了使得集群能够水平扩展，首要解决的问题就是如何将整个数据集按照一定的规则分配到多个节点上，常用的数据分片的方法有：范围分片，哈希分片，一致性哈希算法，哈希槽等。</p><p>范围分片假设数据集是有序，将顺序相临近的数据放在一起，可以很好的支持遍历操作。范围分片的缺点是面对顺序写时，会存在热点。比如日志类型的写入，一般日志的顺序都是和时间相关的，时间是单调递增的，因此写入的热点永远在最后一个分片。</p><p>Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot = CRC16 (key) &amp; 16383。每一个节点负责维护一部分槽以及槽所映射的键值数据。</p><p>Redis 虚拟槽分区的特点：</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据</li><li>支持节点、槽和键之间的映射查询，用于数据路由，在线集群伸缩等场景。</li></ul><p>Redis 集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容。可以说，槽是 Redis 集群管理数据的基本单位，集群伸缩就是槽和数据在节点之间的移动。</p><h3 id=\"网络协议基础-2\"><a class=\"anchor\" href=\"#网络协议基础-2\">#</a> 网络协议基础</h3><ol><li><h4 id=\"tcp和udp有什么区别\"><a class=\"anchor\" href=\"#tcp和udp有什么区别\">#</a> TCP 和 UDP 有什么区别</h4></li></ol><p>TCP 与 UDP 区别总结：</p><p>1、TCP 面向连接（如打电话要先拨号建立连接）;UDP 是无连接的，即发送数据之前不需要建立连接.<br>2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付.<br>3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的.<br>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）.<br>4、每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信.<br>5、TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节.<br>6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道.</p><p>因此 UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务，随时都可以发送数据，处理简单且高效.</p><p>经常用于以下场景：</p><ul><li><p>包总量较小的通信（DNS、SNMP）</p></li><li><p>视频、音频等多媒体通信（即时通信）</p></li><li><p>广播通信</p></li></ul><p>TCP 使用场景:</p><p>相对于 UDP，TCP 实现了数据传输过程中的各种控制，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>在对可靠性要求较高的情况下，可以使用 TCP，即不考虑 UDP 的时候，都可以选择 TCP。</p><ol start=\"2\"><li><h4 id=\"tcp中三次握手和四次挥手\"><a class=\"anchor\" href=\"#tcp中三次握手和四次挥手\">#</a> TCP 中三次握手和四次挥手</h4></li></ol><ul><li>三次握手</li></ul><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/75.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文段， <code>SYN=1</code> ， <code>ACK=0</code> ，选择一个初始的序号 <code>seq = x</code> 。</li><li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段， <code>SYN=1</code> ， <code>ACK=1</code> ，确认号为 <code>x+1</code> ，同时也选择一个初始的序号 <code>seq = y</code> 。</li><li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 <code>ack = y+1</code> ，序号为 <code>seq = x+1</code> 。</li><li>A 的 TCP 通知上层应用进程，连接已经建立。</li><li>B 收到 A 的确认后，连接建立。</li><li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</li></ul><p>为什么 TCP 连接需要三次握手，两次不可以吗，为什么？</p><p>TCP 是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p><ul><li>四次挥手</li></ul><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/76.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。</p><ul><li>A 把连接释放报文段首部的 <code>FIN = 1</code> ，其序号 <code>seq = u</code> ，等待 B 的确认。</li><li>B 发出确认，确认号 <code>ack = u+1</code> ，而这个报文段自己的序号 <code>seq = v</code> 。（TCP 服务器进程通知高层应用进程）。</li><li>从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。A 不能向 B 发送数据；B 若发送数据，A 仍要接收。</li><li>当 B 不再需要连接时，发送连接释放请求报文段，FIN=1。</li><li>A 收到后发出确认，进入 <code>TIME-WAIT</code> 状态，等待 <code>2 MSL（2*2 = 4 mins）</code> 时间后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p>四次挥手的原因:</p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，</p><ol start=\"3\"><li><h4 id=\"tcp的listen状态是什么\"><a class=\"anchor\" href=\"#tcp的listen状态是什么\">#</a> TCP 的 LISTEN 状态是什么</h4></li></ol><p>TCP 的 LISTEN 是服务器处于监听状态:</p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>TIME_WAIT：客户端收到服务端的 FIN 包，并立即发出 ACK 包做最后的确认，在此之后的 2MSL 时间称为 TIME_WAIT 状态。</li></ul><ol start=\"4\"><li><h4 id=\"常见的http状态码有哪些\"><a class=\"anchor\" href=\"#常见的http状态码有哪些\">#</a> 常见的 HTTP 状态码有哪些</h4></li></ol><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/144.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ol start=\"5\"><li><h4 id=\"301和302有什么区别\"><a class=\"anchor\" href=\"#301和302有什么区别\">#</a> 301 和 302 有什么区别</h4></li></ol><p>301: Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><p>302 Found 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。</p><p>301 是永久重定向，而 302 是临时重定向。</p><ol start=\"6\"><li><h4 id=\"504和500有什么区别\"><a class=\"anchor\" href=\"#504和500有什么区别\">#</a> 504 和 500 有什么区别</h4></li></ol><p>500 的错误通常是由于服务器上代码出错或者是抛出了异常.</p><p>502 即 Bad Gateway 网关 (这里的网关是指 CGI, 即通用网关接口) 错误，通常是程序空指针错误。</p><p>504 即 Gateway timeout, 即超时错误.</p><ol start=\"7\"><li><h4 id=\"https和http有什么区别\"><a class=\"anchor\" href=\"#https和http有什么区别\">#</a> HTTPS 和 HTTP 有什么区别</h4></li></ol><p>http 协议和 https 协议的区别：传输信息安全性不同、连接方式不同、端口不同、证书专申请方式不同.</p><p>一、传输信息安全性不同</p><ol><li><p>http 协议：是超文本传输协议，信息是明文传输。如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。</p></li><li><p>https 协议：是具有安全性的 ssl 加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安</p></li></ol><p>二，连接方式不同</p><ol><li>http 协议：http 的连接很简单，是无状态的。</li><li>https 协议：是由 SSL＋HTTP 协议构建的可进行加密传输、身份认证的网络协议。</li></ol><p>三、端口不同</p><ol><li>http 协议：使用的端口是 80。</li><li>https 协议：使用的端口是 443．</li></ol><p>四、证书申请方式不同</p><ol><li><p>http 协议：免费申请。</p></li><li><p>https 协议：需要到 ca 申请证书，一般免费证书很少，需要交费。</p></li><li><h4 id=\"quic有什么优点相比http2\"><a class=\"anchor\" href=\"#quic有什么优点相比http2\">#</a> Quic 有什么优点相比 Http2</h4></li></ol><ul><li><code>HTTP1</code> 有连接无法复用、队头阻塞、协议开销大和安全因素等多个缺陷.</li><li><code>HTTP2</code> 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的</li><li><code>Quic</code> 基于 UDP 实现，是 HTTP3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议.quic 中加密认证的报文，(TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。) 这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</li></ul><p>此外 quic 还有向前纠错的能力，QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。</p><p>向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间 (包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗),</p><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。<br>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势:</p><p>减少了 TCP 三次握手及 TLS 握手时间。改进的拥塞控制。避免队头阻塞的多路复用。连接迁移。前向冗余纠错.</p><ol start=\"9\"><li><h4 id=\"grpc的优缺点\"><a class=\"anchor\" href=\"#grpc的优缺点\">#</a> Grpc 的优缺点</h4></li></ol><p>gRPC 是 Google 公司基于 Protobuf 开发的跨语言的开源 RPC 框架。gRPC 基于 HTTP/2 协议设计，可以基于一个 HTTP/2 链接提供多个服务，对于移动设备更加友好。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/145.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>最底层为 TCP 或 Unix Socket 协议，在此之上是 HTTP/2 协议的实现，然后在 HTTP/2 协议之上又构建了针对 Go 语言的 gRPC 核心库。应用程序通过 gRPC 插件生产的 Stub 代码和 gRPC 核心库通信，也可以直接和 gRPC 核心库通信。</p><p>Grpc 优缺点：</p><p>优点：</p><ul><li>protobuf 二进制消息，性能好 / 效率高（空间和时间效率都很不错）</li><li>proto 文件生成目标代码，简单易用</li><li>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射 (XML,JSON 都是这种方式)</li><li>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级</li><li>支持多种语言（可以把 proto 文件看做 IDL 文件）</li></ul><p>缺点：</p><ul><li>GRPC 尚未提供连接池，需要自行实现</li><li>尚未提供 “服务发现”、“负载均衡” 机制</li><li>因为基于 HTTP2，绝大部多数 <code>HTTP Server、Nginx</code> 都尚不支持，即 Nginx 不能将 GRPC 请求作为 HTTP 请求来负载均衡，而是作为普通的 TCP 请求。（nginx1.9 版本已支持）</li><li>Protobuf 二进制可读性差（貌似提供了 Text_Fromat 功能）默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</li></ul><ol start=\"10\"><li><h4 id=\"get和post区别\"><a class=\"anchor\" href=\"#get和post区别\">#</a> Get 和 Post 区别</h4></li></ol><p>Get 和 Post 的区别和不同:</p><ol><li><p>Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中；Post 的所有操作对用户来说都是不可见的。</p></li><li><p>Get 传送的数据量较小，这主要是因为受 URL 长度限制；Post 传送的数据量较大，一般被默认为不受限制。</p></li><li><p>Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。</p></li><li><p>Get 执行效率却比 Post 方法好。Get 是 form 提交的默认方法。</p></li><li><p>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。（非必然，客户端可灵活决定）</p></li><li><h4 id=\"unicode和ascii以及utf8的区别\"><a class=\"anchor\" href=\"#unicode和ascii以及utf8的区别\">#</a> Unicode 和 ASCII 以及 Utf8 的区别</h4></li></ol><p>计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有 0 和 1 两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。</p><p>也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从 00000000 到 11111111。</p><p>上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。</p><p>ASCII 码一共规定了 128 个字符的编码，比如空格 SPACE 是 32（二进制 00100000），大写的字母 A 是 65（二进制 01000001）。</p><p>这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为 0。</p><ul><li><p>Unicode 是字符集<br>如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。<br>Unicode 当然是一个很大的集合，现在的规模可以容纳 100 多万个符号。</p></li><li><p>UTF-8 是编码规则</p></li></ul><p>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p><p>互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。<br>这里需要注意下，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</p><ol start=\"12\"><li><h4 id=\"cookie与session异同\"><a class=\"anchor\" href=\"#cookie与session异同\">#</a> Cookie 与 Session 异同</h4></li></ol><p>Cookie 和 Session 都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决 HTTP 无状态的问题而所做的努力。</p><ul><li>Cookie 机制</li></ul><p>简单地说，Cookie 就是浏览器储存在用户电脑上的一小段文本文件。Cookie 是纯文本格式，不包含任何可执行的代码。<br>一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。<br>大多数需要登录的网站在用户验证成功之后都会设置一个 Cookie，只要这个 Cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。</p><p>Cookie 会被浏览器自动删除，通常存在以下几种原因：</p><ol><li>会话 Cooke (Session Cookie) 在会话结束时（浏览器关闭）会被删除</li><li>持久化 Cookie（Persistent Cookie）在到达失效日期时会被删除</li><li>如果浏览器中的 Cookie 数量达到限制，那么 Cookie 会被删除以为新建的 Cookie 创建空间。</li></ol><p>大多数浏览器支持最大为 4096 字节的 Cookie。由于这限制了 Cookie 的大小，最好用 Cookie 来存储少量数据，或者存储用户 ID 之类的标识符。</p><p>用户 ID 随后便可用于标识用户，以及从数据库或其他数据源中读取用户信息。 浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。</p><p>大多数浏览器只允许每个站点存储 20 个 Cookie；如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。</p><p>有些浏览器还会对它们将接受的来自所有站点的 Cookie 总数作出绝对限制，通常为 300 个。</p><p>使用 Cookie 的缺点：</p><ol><li><p>不良站点用 Cookie 收集用户隐私信息；</p></li><li><p>Cookie 窃取：黑客以可以通过窃取用户的 cookie 来模拟用户的请求行为。（跨站脚本攻击 XSS）</p></li><li><p>Session 机制</p></li></ol><p>Session 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 Session 标识（Session id）.</p><p>如果已包含一个 SessionID 则说明以前已经为此客户端创建过 Session，服务器就按照 SessionID 把这个 Session 检索出来使用（如果检索不到，可能会新建一个）。<br>如果客户端请求不包含 SessionID，则为此客户端创建一个 Session 并且生成一个与此 Session 相关联的 SessionID，SessionID 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 SessionID 将被在本次响应中返回给客户端保存。</p><p>具体实现方式：</p><ul><li>Cookie 方式</li></ul><p>服务器给每个 Session 分配一个唯一的 JSESSIONID，并通过 Cookie 发送给客户端。</p><p>当客户端发起新的请求的时候，将在 Cookie 头中携带这个 JSESSIONID，这样服务器能够找到这个客户端对应的 Session。</p><ul><li>URL 回写</li></ul><p>服务器在发送给浏览器页面的所有链接中都携带 JSESSIONID 的参数，这样客户端点击任何一个链接都会把 JSESSIONID 带回服务器。如果直接在浏览器输入服务端资源的 url 来请求该资源，那么 Session 是匹配不到的。</p><p>Web 缓存:</p><p>WEB 缓存 (cache) 位于 Web 服务器和客户端之间，缓存机制会根据请求保存输出内容的副本，例如 html 页面，图片，文件，当下一个请求来到的时候：如果是相同的 URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p><p>主要分三种情况:</p><ol><li>未找到缓存 (黑色线)：当没有找到缓存时，说明本地并没有这些数据，这种情况一般发生在我们首次访问网站，或者以前访问过，但是清除过缓存后。</li></ol><p>浏览器就会先访问服务器，然后把服务器上的内容取回来，内容取回来以后，就要根据情况来决定是否要保留到缓存中了。</p><ol start=\"2\"><li><p>缓存未过期 (蓝色线)：缓存未过期，指的是本地缓存没有过期，不需要访问服务器了，直接就可以拿本地的缓存作为响应在本地使用了。这样节省了不少网络成本，提高了用户体验过。</p></li><li><p>缓存已过期 (红色线)：当满足过期的条件时，会向服务器发送请求，发送的请求一般都会进行一个验证，目的是虽然缓存文档过期了，但是文档内容不一定会有什么改变，所以服务器返回的也许是一个新的文档，这时候的 HTTP 状态码是 200，或者返回的只是一个最新的时间戳和 304 状态码。</p></li></ol><p>缓存过期后，有两种方法来判定服务端的文件有没有更新。</p><p>第一种在上一次服务端告诉客户端约定的有效期的同时，告诉客户端该文件最后修改的时间，当再次试图从服务端下载该文件的时候，check 下该文件有没有更新（对比最后修改时间），如果没有，则读取缓存.</p><p>第二种方式是在上一次服务端告诉客户端约定有效期的同时，同时告诉客户端该文件的版本号，当服务端文件更新的时候，改变版本号，再次发送请求的时候 check 一下版本号是否一致就行了，如一致，则可直接读取缓存。</p><p>浏览器是依靠请求和响应中的的头信息来控制缓存的，如下：</p><ul><li>Expires 与 Cache-Control：服务端用来约定和客户端的有效时间的。</li></ul><p>Expires 规定了缓存失效时间（Date 为当前时间），而 <code>Cache-Control</code> 的 max-age 规定了缓存有效时间（2552s）。</p><p>Expires 是 HTTP1.0 的东西，而 <code>Cache-Control</code> 是 HTTP1.1 的，规定如果 <code>max-age</code> 和 Expires 同时存在，前者优先级高于后者。</p><ul><li><p>Last-Modified/If-Modified-Since 缓存过期后，check 服务端文件是否更新的第一种方式。</p></li><li><p>ETag/If-None-Match：缓存过期时 check 服务端文件是否更新的第二种方式。</p></li></ul><p>实际上 ETag 并不是文件的版本号，而是一串可以代表该文件唯一的字符串，当客户端发现和服务器约定的直接读取缓存的时间过了，就在请求中发送 If-None-Match 选项，值即为上次请求后响应头的 ETag 值.<br>该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则相应 HTTP304，客户端直接读取缓存，如果不相同，HTTP200，下载正确的数据，更新 ETag 值。</p><p>当然并不是所有请求都能被缓存。无法被浏览器缓存的请求：</p><ol><li>HTTP 信息头中包含 <code>Cache-Control:no-cache，pragma:no-cache（HTTP1.0）</code> ，或 <code>Cache-Control:max-age=0</code> 等告诉浏览器不用缓存的请求</li><li>需要根据 Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</li><li>POST 请求无法被缓存</li></ol><p>浏览器缓存过程还和用户行为有关。譬如先打开一个主页有个 jquery 的请求（假设访问后会缓存下来）。</p><p>接着如果直接在地址栏输入 jquery 地址，然后回车，响应 HTTP200（from cache），因为有效期还没过直接读取的缓存；如果 <code>ctrl+r</code> 进行刷新，则会相应 HTTP304（Not Modified），虽然还是读取的本地缓存，但是多了一次服务端的请求；而如果是 ctrl+shift+r 强刷，则会直接从服务器下载新的文件，响应 HTTP200。</p><ol start=\"13\"><li><h4 id=\"client如何实现长连接\"><a class=\"anchor\" href=\"#client如何实现长连接\">#</a> Client 如何实现长连接</h4></li></ol><p>TCP 协议的 <code>KeepAlive</code> 机制与 <code>HeartBeat</code> 心跳包</p><ul><li>HeartBeat 心跳包</li></ul><p>很多应用层协议都有 HeartBeat 机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线，并传输一些可能必要的数据。使用心跳包的典型协议是 IM，比如 QQ/MSN/ 飞信等协议。</p><p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。</p><p>在 TCP 的机制里面，本身是存在有心跳包的机制的，也就是 TCP 的选项：SO_KEEPALIVE。系统默认是设置的 2 小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。</p><p>心跳包一般来说都是在逻辑层发送空的 echo 包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。</p><p>其实，要判定掉线，只需要 send 或者 recv 一下，如果结果为零，则为掉线。但是，在长连接下，有可能很长一段时间都没有数据往来。</p><p>理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。</p><p>在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的数据清理呀，重新连接呀…… 当然，这个自然是要由逻辑层根据需求去做了。</p><p>总的来说，心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在 30-40 秒比较不错。如果实在要求高，那就在 6-9 秒。</p><ul><li>TCP 协议的 <code>KeepAlive</code> 机制</li></ul><p>TCP 的 IP 传输层的两个主要协议是 UDP 和 TCP，其中 UDP 是无连接的、面向 packet 的，而 TCP 协议是有连接、面向流的协议。</p><p>TCP 的 <code>KeepAlive</code> 机制，首先它貌似默认是不打开的，要用 <code>setsockopt</code> 将 <code>SOL_SOCKET.SO_KEEPALIVE</code> 设置为 1 才是打开，并且可以设置三个参数 <code>tcp_keepalive_time/tcp_keepalive_probes/tcp_keepalive_intvl</code> ，分别表示连接闲置多久开始发 <code>keepalive</code> 的 ack 包、发几个 ack 包不回复才当对方死了、两个 ack 包之间间隔多.</p><p>在测试的时候用 <code>Ubuntu Server 10.04</code> 下面默认值是 7200 秒（2 个小时，要不要这么蛋疼啊！）、9 次、75 秒。</p><p>于是连接就了有一个超时时间窗口，如果连接之间没有通信，这个时间窗口会逐渐减小，当它减小到零的时候，TCP 协议会向对方发一个带有 ACK 标志的空数据包（KeepAlive 探针），对方在收到 ACK 包以后，如果连接一切正常，应该回复一个 ACK；如果连接出现错误了（例如对方重启了，连接状态丢失），则应当回复一个 RST；如果对方没有回复，服务器每隔 intvl 的时间再发 ACK，如果连续 probes 个包都被无视了，说明连接被断开了。</p><p>在 http 早期，每个 http 请求都要求打开一个 tpc socket 连接，并且使用一次之后就断开这个 tcp 连接。</p><p>使用 <code>keep-alive</code> 可以改善这种状态，即在一次 TCP 连接中可以持续发送多份数据而不会断开连接。通过使用 <code>keep-alive</code> 机制，可以减少 tcp 连接建立次数，也意味着可以减少 <code>TIME_WAIT</code> 状态连接，以此提高性能和提高 httpd 服务器的吞吐率 (更少的 tcp 连接意味着更少的系统内核调用，socket 的 <code>accept()</code> 和 <code>close()</code> 调用)。</p><p>但是， <code>keep-alive</code> 并不是免费的午餐，长时间的 tcp 连接容易导致系统资源无效占用。配置不当的 <code>keep-alive</code> ，有时比重复利用连接带来的损失还更大。所以，正确地设置 <code>keep-alive timeout</code> 时间非常重要。</p><p>使用 <code>http keep-alvie</code> ，可以减少服务端 <code>TIME_WAIT</code> 数量 (因为由服务端 httpd 守护进程主动关闭连接)。道理很简单，相较而言，启用 <code>keep-alive</code> ，建立的 tcp 连接更少了，自然要被关闭的 tcp 连接也相应更少了。</p><p>使用启用 <code>keepalive</code> 的不同。另外， <code>http keepalive</code> 是客户端浏览器与服务端 httpd 守护进程协作的结果，所以，我们另外安排篇幅介绍不同浏览器的各种情况对 <code>keep-alive</code> 的利用。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/106.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ol start=\"14\"><li><h4 id=\"http1和http2和grpc之间的区别是什么\"><a class=\"anchor\" href=\"#http1和http2和grpc之间的区别是什么\">#</a> Http1 和 Http2 和 Grpc 之间的区别是什么</h4></li></ol><p>在互联网流量传输只使用了几个网络协议。使用 <code>IPv4</code> 进行路由，使用 <code>TCP</code> 进行连接层面的流量控制，使用 <code>SSL/TLS</code> 协议实现传输安全，使用 <code>DNS</code> 进行域名解析，使用 <code>HTTP</code> 进行应用数据的传输。</p><p>但是使用 Http 进行应用数据的传输，却是在不断的改变，那么 Http1 和 Http2 和 Grpc 之间的区别是什么，我们下面分析下.</p><p>通常影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。</p><ul><li>带宽</li></ul><p>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p><ul><li>延迟</li></ul><p>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p><p>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用 DNS 缓存结果来达到减少这个时间的目的。</p><p>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p><p>然而，HTTP2 并不是对 HTTP1 协议的重写，相对于 HTTP1，HTTP2 的侧重点主要在性能。其中请求方法，状态码和语义和 HTTP1 都是相同的，可以使用与 HTTP1 相同的 API（可能有一些小的添加）来表示协议。</p><p>HTTP2 主要有两个规范组成:</p><ul><li><code>Hypertext Transfer Protocol version 2</code> (超文本传输协议版本 2)</li><li><code>HPACK - HTTP2</code> 的头压缩 （HPACK 是一种头部压缩算法）</li></ul><p>HTTP2 和 HTTP1 相比的新特性包括:</p><ul><li>新的二进制格式（Binary Format）</li></ul><p>HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</p><ul><li>多路复用（MultiPlexing）</li></ul><p>连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</p><ul><li>Header 压缩</li></ul><p>Header 压缩，如上文中所言，对前面提到过 HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</p><ul><li>服务端推送（server push）</li></ul><p>服务端推送（server push），同 SPDY 一样，HTTP2.0 也具有 server push 功能。</p><p>Grpc 的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务，同时，它也是高性能的，而 HTTP2 恰好支持这些。</p><p>而 Grpc 是基于 http2 的.</p><ul><li>HTTP2 天然的通用性满足各种设备，场景.</li><li>HTTP2 的性能相对来说也是很好的，除非你需要极致的性能.</li><li>HTTP2 的安全性非常好，天然支持 SSL.</li><li>HTTP2 的鉴权也非常成熟.</li><li>Grpc 基于 HTTP2 多语言实现也更容易.</li></ul><ol start=\"15\"><li><h4 id=\"tcp中的拆包和粘包是怎么回事\"><a class=\"anchor\" href=\"#tcp中的拆包和粘包是怎么回事\">#</a> Tcp 中的拆包和粘包是怎么回事</h4></li></ol><p>拆包和粘包是在 socket 编程中经常出现的情况，在 socket 通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp 协议会将多个数据包打包成一个 tcp 报文发送出去，这就是所谓的粘包。</p><p>而如果通讯的一端发送的数据包超过一次 tcp 报文所能传输的最大值时，就会将一个数据包拆成多个最大 tcp 长度的 tcp 报文分开传输，这就叫做拆包。</p><p>MTU:</p><p>泛指通讯协议中的最大传输单元。一般用来说明 <code>TCP/IP</code> 四层协议中数据链路层的最大传输单元，不同类型的网络 MTU 也会不同，我们普遍使用的以太网的 MTU 是 1500，即最大只能传输 1500 字节的数据帧。可以通过 ifconfig 命令查看电脑各个网卡的 MTU。</p><p>MSS:</p><p>指 TCP 建立连接后双方约定的可传输的最大 TCP 报文长度，是 TCP 用来限制应用层可发送的最大字节数。如果底层的 MTU 是 <code>1500byte</code> ，则 <code>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</code> 。</p><ol start=\"16\"><li><h4 id=\"tfo的原理是什么\"><a class=\"anchor\" href=\"#tfo的原理是什么\">#</a> TFO 的原理是什么</h4></li></ol><p>TCP 快速打开（TCP Fast Open，TFO）是对 TCP 的一种简化握手手续的拓展，用于提高两端点间连接的打开速度。<br>简而言之，就是在 TCP 的三次握手过程中传输实际有用的数据。这个扩展最初在 Linux 系统实现，Linux 服务器，Linux 系统上的 Chrome 浏览器，或运行在 Linux 上的其他支持的软件。<br>它通过握手开始时的 SYN 包中的 TFO cookie 来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。<br>这个加密的 Cookie 被存储在客户端，在一开始的连接时被设定好。然后每当客户端连接时，这个 Cookie 被重复返回。</p><p>请求 Tcp Fast Open Cookie</p><ul><li>客户端发送 SYN 数据包，该数据包包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li><li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li><li>客户端收到 SYN-ACK 后，缓存 Fast Open 选项中的 Cookie。</li></ul><ol start=\"17\"><li><h4 id=\"time_wait的作用\"><a class=\"anchor\" href=\"#time_wait的作用\">#</a> TIME_WAIT 的作用</h4></li></ol><p>主动关闭的 Socket 端会进入 TIME_WAIT 状态，并且持续 2MSL 时间长度，MSL 就是 maximum segment lifetime (最大分节生命期），这是一个 IP 数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。MSL 在 RFC 1122 上建议是 2 分钟，而源自 berkeley 的 TCP 实现传统上使用 30 秒，因而，TIME_WAIT 状态一般维持在 1-4 分钟。</p><ul><li>可靠地实现 TCP 全双工连接的终止</li></ul><p>在进行关闭连接四路握手协议时，最后的 ACK 是由主动关闭端发出的，如果这个最终的 ACK 丢失，服务器将重发最终的 FIN，因此客户端必须维护状态信息允 许它重发最终的 ACK。</p><p>如果不维持这个状态信息，那么客户端将响应 RST 分节，服务器将此分节解释成一个错误（在 java 中会抛出 connection reset 的 SocketException)。</p><p>因而，要实现 TCP 全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭 的客户端必须维持状态信息进入 TIME_WAIT 状态。</p><ul><li>允许老的重复分节在网络中消逝</li></ul><p>TCP 分节可能由于路由器异常而 “迷途”，在迷途期间，TCP 发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个 原来的迷途分节就称为 lost duplicate。</p><p>在关闭一个 TCP 连接后，马上又重新建立起一个相同的 IP 地址和端口之间的 TCP 连接，后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。</p><p>为了避免这个情况，TCP 不允许处于 TIME_WAIT 状态的连接启动一个新的化身，因为 TIME_WAIT 状态持续 2MSL，就可以保证当成功建立一个 TCP 连接的时 候，来自连接先前化身的重复分组已经在网络中消逝。</p><ol start=\"18\"><li><h4 id=\"网络的性能指标有哪些\"><a class=\"anchor\" href=\"#网络的性能指标有哪些\">#</a> 网络的性能指标有哪些</h4></li></ol><p>通常是以 4 个指标来衡量网络的性能，分别是带宽、延时、吞吐率、PPS（Packet Per Second），它们表示的意义如下：</p><ul><li><p>带宽，表示链路的最大传输速率，单位是 <code>b/s</code> （比特 / 秒），带宽越大，其传输能力就越强。</p></li><li><p>延时，表示请求数据包发送后，收到对端响应，所需要的时间延迟。不同的场景有着不同的含义，比如可以表示建立 <code>TCP</code> 连接所需的时间延迟，或一个数据包往返所需的时间延迟。</p></li><li><p>吞吐率，表示单位时间内成功传输的数据量，单位是 <code>b/s</code> （比特 / 秒）或者 <code>B/s</code> （字节 / 秒），吞吐受带宽限制，带宽越大，吞吐率的上限才可能越高。</p></li><li><p><code>PPS</code> ，全称是 <code>Packet Per Second</code> （包 / 秒），表示以网络包为单位的传输速率，一般用来评估系统对于网络的转发能力。</p></li></ul><p>当然，除了以上这四种基本的指标，还有一些其他常用的性能指标，比如：</p><ul><li><p>网络的可用性，表示网络能否正常通信；</p></li><li><p>并发连接数，表示 TCP 连接数量；</p></li><li><p>丢包率，表示所丢失数据包数量占所发送数据组的比率；</p></li><li><p>重传率，表示重传网络包的比例；</p></li></ul><h3 id=\"linux基础-2\"><a class=\"anchor\" href=\"#linux基础-2\">#</a> Linux 基础</h3><ol><li><h4 id=\"异步和非阻塞的区别\"><a class=\"anchor\" href=\"#异步和非阻塞的区别\">#</a> 异步和非阻塞的区别</h4></li></ol><p>异步和非阻塞的区别:</p><ul><li>异步：调用在发出之后，这个调用就直接返回，不管有无结果；异步是过程。</li><li>非阻塞：关注的是程序在等待调用结果（消息，返回值）时的状态，指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ul><p>同步和异步的区别：</p><ul><li>同步：一个服务的完成需要依赖其他服务时，只有等待被依赖的服务完成后，才算完成，这是一种可靠的服务序列。要么成功都成功，失败都失败，服务的状态可以保持一致。</li><li>异步：一个服务的完成需要依赖其他服务时，只通知其他依赖服务开始执行，而不需要等待被依赖的服务完成，此时该服务就算完成了。被依赖的服务是否最终完成无法确定，一次它是一个不可靠的服务序列。</li></ul><p>消息通知中的同步和异步：</p><ul><li>同步：当一个同步调用发出后，调用者要一直等待返回消息（或者调用结果）通知后，才能进行后续的执行。</li><li>异步：当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。在调用结束之后，通过消息回调来通知调用者是否调用成功。</li></ul><p>阻塞与非阻塞的区别：</p><ul><li>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务，函数只有在得到结果之后才会返回。</li><li>非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</li></ul><p>同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。</p><p>阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。</p><p>阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。</p><ol start=\"2\"><li><h4 id=\"虚拟内存作用是什么\"><a class=\"anchor\" href=\"#虚拟内存作用是什么\">#</a> 虚拟内存作用是什么</h4></li></ol><p>我们都知道一个进程是与其他进程共享 CPU 和内存资源的。正因如此，操作系统需要有一套完善的内存管理机制才能防止进程之间内存泄漏的问题.</p><p>为了更加有效地管理内存并减少出错，现代操作系统提供了一种对主存的抽象概念，即是虚拟内存（Virtual Memory）。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。</p><p>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，使得程序的编写难度降低。并且，把内存扩展到硬盘空间只是使用虚拟内存的必然结果，虚拟内存空间会存在硬盘中，并且会被内存缓存（按需），有的操作系统还会在内存不够的情况下，将某一进程的内存全部放入硬盘空间中，并在切换到该进程时再从硬盘读取.</p><p>虚拟内存主要提供了如下三个重要的能力：</p><ul><li><p>它把主存看作为一个存储在硬盘上的虚拟地址空间的高速缓存，并且只在主存中缓存活动区域（按需缓存）。</p></li><li><p>它为每个进程提供了一个一致的地址空间，从而降低了程序员对内存管理的复杂性。</p></li><li><p>它还保护了每个进程的地址空间不会被其他进程破坏。</p></li></ul><ol start=\"3\"><li><h4 id=\"linux查看端口占用和cpu负载\"><a class=\"anchor\" href=\"#linux查看端口占用和cpu负载\">#</a> Linux 查看端口占用和 cpu 负载</h4></li></ol><p>linux ps 命令，查看某进程 cpu 和内存占用率情况:</p><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">ps</span> aux</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token environment constant\">USER</span>               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>admin            <span class=\"token number\">72824</span>  <span class=\"token number\">17.3</span>  <span class=\"token number\">1.4</span>  <span class=\"token number\">5518204</span> <span class=\"token number\">118212</span>   ??  R    <span class=\"token number\">27</span> <span class=\"token number\">519</span>   <span class=\"token number\">54</span>:49.93 /Applications/iTerm.app/Contents/MacOS/iTerm2</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>_windowserver      <span class=\"token number\">179</span>  <span class=\"token number\">16.1</span>  <span class=\"token number\">0.6</span>  <span class=\"token number\">7525352</span>  <span class=\"token number\">46552</span>   ??  Rs   <span class=\"token number\">21</span> <span class=\"token number\">519</span>  <span class=\"token number\">457</span>:09.25 /System/Library/PrivateFrameworks/SkyLight.fra</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>admin              <span class=\"token number\">734</span>  <span class=\"token number\">12.2</span>  <span class=\"token number\">3.3</span>  <span class=\"token number\">6095348</span> <span class=\"token number\">273108</span>   ??  R    <span class=\"token number\">21</span> <span class=\"token number\">519</span>  <span class=\"token number\">635</span>:17.25 /Users/admin/Desktop/Google Chrome.app/Content</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>admin            <span class=\"token number\">10718</span>   <span class=\"token number\">9.0</span>  <span class=\"token number\">2.7</span>  <span class=\"token number\">5604388</span> <span class=\"token number\">223604</span>   ??  S    <span class=\"token number\">22</span> <span class=\"token number\">519</span>  <span class=\"token number\">557</span>:56.89 /Users/admin/Desktop/Google Chrome.app/Content</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>admin              <span class=\"token number\">750</span>   <span class=\"token number\">6.4</span>  <span class=\"token number\">0.6</span>  <span class=\"token number\">4633300</span>  <span class=\"token number\">52372</span>   ??  S    <span class=\"token number\">21</span> <span class=\"token number\">519</span>  <span class=\"token number\">147</span>:59.59 /Users/admin/Desktop/Google Chrome.app/Content</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>admin              <span class=\"token number\">749</span>   <span class=\"token number\">5.6</span>  <span class=\"token number\">1.2</span>  <span class=\"token number\">5570904</span>  <span class=\"token number\">96832</span>   ??  S    <span class=\"token number\">21</span> <span class=\"token number\">519</span>  <span class=\"token number\">359</span>:56.37 /Users/admin/Desktop/Google Chrome.app/Content</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>admin              <span class=\"token number\">818</span>   <span class=\"token number\">4.5</span>  <span class=\"token number\">0.1</span>  <span class=\"token number\">6557980</span>   <span class=\"token number\">5508</span>   ??  S    <span class=\"token number\">21</span> <span class=\"token number\">519</span>  <span class=\"token number\">557</span>:27.52 com.docker.hyperkit -A -u -F vms/0/hyperkit.pi</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>admin            <span class=\"token number\">32898</span>   <span class=\"token number\">3.5</span>  <span class=\"token number\">1.4</span>  <span class=\"token number\">4977204</span> <span class=\"token number\">117684</span>   ??  S    <span class=\"token number\">10</span>:54上午   <span class=\"token number\">0</span>:02.27 /Users/admin/Desktop/Google Chrome.app/Content</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>admin            <span class=\"token number\">30591</span>   <span class=\"token number\">2.2</span>  <span class=\"token number\">3.7</span>  <span class=\"token number\">9505844</span> <span class=\"token number\">310584</span>   ??  S     <span class=\"token number\">9</span>:47上午  <span class=\"token number\">10</span>:49.28 /Applications/GoLand.app/Contents/MacOS/goland</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>root              <span class=\"token number\">1300</span>   <span class=\"token number\">1.9</span>  <span class=\"token number\">0.1</span>  <span class=\"token number\">4334916</span>   <span class=\"token number\">6212</span>   ??  Ss   <span class=\"token number\">21</span> <span class=\"token number\">519</span>  <span class=\"token number\">123</span>:53.86 /usr/libexec/taskgated</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>admin            <span class=\"token number\">31232</span>   <span class=\"token number\">1.2</span>  <span class=\"token number\">1.1</span> <span class=\"token number\">10553808</span>  <span class=\"token number\">88860</span>   ??  S    <span class=\"token number\">10</span>:24上午   <span class=\"token number\">3</span>:28.67 /Applications/WebStorm.app/Contents/MacOS/webs</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>admin            <span class=\"token number\">18704</span>   <span class=\"token number\">0.7</span>  <span class=\"token number\">0.2</span> <span class=\"token number\">19282032</span>  <span class=\"token number\">12948</span>   ??  S     <span class=\"token number\">3</span>:56下午   <span class=\"token number\">4</span>:18.12 /private/var/folders/kp/3yqnp9cj4f3_9539b06q4</pre></td></tr></table></figure><ul><li>linux 下的 ps 命令</li><li>USER 进程运行用户</li><li>PID 进程编号</li><li>% CPU 进程的 cpu 占用率</li><li>% MEM 进程的内存占用率</li><li>VSZ 进程所使用的虚存的大小</li><li>RSS 进程</li></ul><ol start=\"4\"><li><h4 id=\"linux如何发送信号给一个进程\"><a class=\"anchor\" href=\"#linux如何发送信号给一个进程\">#</a> Linux 如何发送信号给一个进程</h4></li></ol><p>通常在 linux 中可以通过 <code>pkill</code> 命令、 <code>kill</code> 命令和 <code>killall</code> 命令，或者组合键向进程发送各种信号.</p><ul><li><code>Ctrl + C</code> : 中断信号，发送 <code>SIGINT</code> 信号到运行在前台的进程.</li><li><code>Ctrl + Y</code> : 延时挂起信号，使运行的进程在尝试从终端读取输入时停止。控制权返回给 Shell，使用户可以将进程放在前台或后台，或杀掉该进程.</li><li><code>Ctrl + Z</code> : 挂起信号，发送 <code>SIGTSTP</code> 信号到运行的进程，由此将其停止，并将控制权返回给 Shell.<br>也可以使用 kill 命令结束进程:</li></ul><p>发送 <code>SIGKILL</code> 信号到 <code>PID</code> 是 123 的进程：</p><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">kill</span> -9 <span class=\"token number\">123</span></pre></td></tr></table></figure><p><code>killall</code> 命令会发送信号到运行任何指定命令的所有进程。所以，当一个进程启动了多个实例时，使用 <code>killall</code> 命令来杀掉这些进程会更方便一些。</p><ul><li>使用 killall 命令杀掉所有 firefox 进程:</li></ul><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">killall</span> firefox</pre></td></tr></table></figure><p>使用 <code>pkill</code> 命令，可以通过指定进程名、用户名、组名、终端、UID、EUID 和 GID 等属性来杀掉相应的进程。pkill 命令默认也是发送 SIGTERM 信号到进程。</p><ul><li>使用 pkill 命令杀掉所有用户的 firefox 进程.</li></ul><figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token operator\">></span> <span class=\"token function\">pkill</span> firefox</pre></td></tr></table></figure><ol start=\"5\"><li><h4 id=\"如何避免死锁\"><a class=\"anchor\" href=\"#如何避免死锁\">#</a> 如何避免死锁</h4></li></ol><p>死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。<br>例如，在某一个计算机系统中只有一台打印机和一台输入 设备，进程 P1 正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程 P2 所占用，而 P2 在未释放打印机之前，又提出请求使用正被 P1 占用着的输入设备。<br>这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p><p>死锁产生的原因:</p><ol><li>系统资源的竞争</li></ol><p>系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p><ol start=\"2\"><li>进程运行推进顺序不合适</li></ol><p>进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</p><p>死锁的四个必要条件:</p><ul><li><p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p></li><li><p>不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p></li><li><p>循环等待条件：若干进程间形成首尾相接循环等待资源的关系</p></li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><p>死锁的避免与预防:</p><ul><li>死锁避免的基本思想</li></ul><p>系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。<br>如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。</p><ul><li>安全状态</li></ul><p>如果系统存在 由所有的安全序列 {P1，P2，…Pn}, 则系统处于安全状态。一个进程序列是安全的，如果对其中每一个进程 Pi (i &gt;=1 &amp;&amp; i &lt;= n) 他以后尚需要的资源不超过系统当前剩余资源量与所有进程 Pj (j &lt; i) 当前占有资源量之和，系统处于安全状态则不会发生死锁。<br>不安全状态：如果不存在任何一个安全序列，则系统处于不安全状态。</p><p>我们可以通过破坏死锁产生的 4 个必要条件来预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。</p><ul><li><p>破坏 “不可剥夺” 条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。</p></li><li><p>破坏” 请求与保持条件 “：第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。</p></li><li><p>破坏 “循环等待” 条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</p></li></ul><ol start=\"6\"><li><h4 id=\"孤儿进程和僵尸进程区别\"><a class=\"anchor\" href=\"#孤儿进程和僵尸进程区别\">#</a> 孤儿进程和僵尸进程区别</h4></li></ol><ul><li><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。<br>孤儿进程将被 init 进程 (进程号为 1) 所收养，并由 init 进程对它们完成状态收集工作。</p></li><li><p>僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p></li></ul><ol start=\"7\"><li><h4 id=\"滑动窗口的概念以及应用\"><a class=\"anchor\" href=\"#滑动窗口的概念以及应用\">#</a> 滑动窗口的概念以及应用</h4></li></ol><p>滑窗 (sliding window) 被同时应用于接收方和发送方。发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示 TCP 正在处理该片段。滑窗中可以有多个片段，也就是可以同时处理多个片段。</p><p>滑窗越大，越大的滑窗同时处理的片段数目越多 (当然，计算机也必须分配出更多的缓存供滑窗使用)。</p><p>滑动窗口概念不仅存在于数据链路层，也存在于传输层，两者有不同的协议，但基本原理是相近的。其中一个重要区别是，一个是针对于帧的传送，另一个是字节数据的传送。</p><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。</p><p>由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。参见滑动窗口如何根据网络拥塞发送数据仿真视频。</p><p>滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。</p><p>CP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。</p><p>发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。</p><p>另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><ol start=\"8\"><li><h4 id=\"epoll和select的区别\"><a class=\"anchor\" href=\"#epoll和select的区别\">#</a> Epoll 和 Select 的区别</h4></li></ol><ul><li>epoll 和 select 都是 <code>I/O</code> 多路复用的技术，都可以实现同时监听多个 <code>I/O</code> 事件的状态。</li><li>epoll 相比 select 效率更高，主要是基于其操作系统支持的 <code>I/O</code> 事件通知机制，而 select 是基于轮询机制。</li><li>epoll 支持水平触发和边沿触发两种模式。</li></ul><ol start=\"9\"><li><h4 id=\"进程之间为什么要进行通信呢\"><a class=\"anchor\" href=\"#进程之间为什么要进行通信呢\">#</a> 进程之间为什么要进行通信呢</h4></li></ol><ul><li>数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。</li><li>共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。</li><li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</li><li>资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。</li><li>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</li></ul><ol start=\"10\"><li><h4 id=\"输入pingip后敲回车发包前会发生什么\"><a class=\"anchor\" href=\"#输入pingip后敲回车发包前会发生什么\">#</a> 输入 PingIP 后敲回车，发包前会发生什么</h4></li></ol><p>首先根据目的 IP 和路由表决定走哪个网卡，再根据网卡的子网掩码地址判断目的 IP 是否在子网内。如果不在则会通过 arp 缓存查询 IP 的网卡地址，不存在的话会通过广播询问目的 IP 的 mac 地址，得到后就开始发包了，同时 mac 地址也会被 arp 缓存起来。</p><ol start=\"11\"><li><h4 id=\"进程和进程间的通信方式区别和不同\"><a class=\"anchor\" href=\"#进程和进程间的通信方式区别和不同\">#</a> 进程和进程间的通信方式区别和不同</h4></li></ol><p>进程：计算机中是资源分配的基本单位。</p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>线程：是独立调度的基本单位。</p><p>一个进程中可以有多个线程，它们共享进程资源。</p><p>例如 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p><p>在 linux 下进程间通信主要是：</p><ul><li><p>管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p></li><li><p>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux 除了支持 Unix 早期信号语义函数 sigal 外，还支持语义符合 Posix.1 标准的信号函数 sigaction（实际上，该函数是基于 BSD 的，BSD 为了实现可靠信号机制，又能够统一对外接口，用 sigaction 函数重新实现了 signal 函数）；</p></li><li><p>消息队列（Message）：消息队列是消息的链接表，包括 Posix 消息队列 system V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用 IPC 形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p></li><li><p>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</p></li><li><p>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由 Unix 系统的 BSD 分支开发出来的，但现在一般可以移植到其它类 Unix 系统上：Linux 和 System V 的变种都支持套接字。</p></li></ul><ol start=\"12\"><li><h4 id=\"如何查看二进制可执行文件引用的动态链接库\"><a class=\"anchor\" href=\"#如何查看二进制可执行文件引用的动态链接库\">#</a> 如何查看二进制可执行文件引用的动态链接库</h4></li></ol><p>linux 中可以用 ldd 查看，macOs 中可以用 otool 可以查看.</p><h3 id=\"algorithm和structrues-2\"><a class=\"anchor\" href=\"#algorithm和structrues-2\">#</a> Algorithm 和 Structrues</h3><ol><li><h4 id=\"哪些排序算法是稳定的\"><a class=\"anchor\" href=\"#哪些排序算法是稳定的\">#</a> 哪些排序算法是稳定的</h4></li></ol><p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法.</p><p>排序算法的稳定性这个应该是清晰明了的，通俗地讲就是能保证排序前 2 个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果 <code>Ai = Aj</code> ，Ai 原来在位置前，排序后 Ai 还是要在 Aj 位置前。</p><p>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。</p><p>基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些。</p><p>现在我们来分析一下常见的排序算法的稳定性。</p><p>(1) 冒泡排序</p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。<br>所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><p>(2) 选择排序</p><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第 n - 1 个元素，第 n 个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。<br>比较拗口，举个例子，序列 5 8 5 2 9，我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><p>(3) 插入排序</p><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有 1 个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。<br>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p><p>(4) 快速排序</p><p>快速排序有两个方向，左边的 i 下标一直往右走，当 <code>a[i] &lt;= a[center index]</code> ，其中 <code>center_index</code> 是中枢元素的数组下标，一般取为数组第 0 个元素。而右边的 j 下标一直往左走，当 <code>a[j] &gt; a[center_index]</code> 。如果 i 和 j 都走不动了， <code>i &lt;= j</code> ，交换 <code>a[i]</code> 和 <code>a[j]</code> , 重复上面的过程，直到 <code>i &gt; j</code> 。 交换 <code>a[j]</code> 和 <code>a[center_index]</code> ，完成一趟快速排序。<br>在中枢元素和 <code>a[j]</code> 交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素 5 和 3（第 5 个元素，下标从 1 开始计）交换就会把元素 3 的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和 <code>a[j]</code> 交换的时刻。</p><p>(5) 归并排序</p><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有 1 个元素（认为直接有序）或者 2 个序列（1 次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在 1 个或 2 个元素时，1 个元素不会交换，2 个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><p>(6) 基数排序</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p><p>(7) 希尔排序 (shell)</p><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 O (n^2) 好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以 shell 排序是不稳定的。</p><p>(8) 堆排序</p><p>我们知道堆的结构是节点 i 的孩子为 <code>2 * i</code> 和 <code>2 * i + 1</code> 节点，大顶堆要求父节点大于等于其 2 个子节点，小顶堆要求父节点小于等于其 2 个子节点。在一个长为 n 的序列，堆排序的过程是从第 n / 2 开始和其子节点共 3 个值选择最大（大顶堆）或者最小（小顶堆），这 3 个元素之间的选择当然不会破坏稳定性。但当为 <code>n / 2 - 1</code> ， <code>n / 2 - 2</code> ， ... 1 这些个父节点选择元素时，就会破坏稳定性。有可能第 <code>n / 2</code> 个父节点交换把后面一个元素交换过去了，而第 <code>n / 2 - 1</code> 个父节点把后面一个相同的元素没 有交换，那么这 2 个相同的元素之间的稳定性就被破坏了。</p><p>所以，堆排序不是稳定的排序算法。</p><p>因此会有：选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法</p><ol start=\"2\"><li><h4 id=\"给定一个二叉树判断其是否是一个有效的二叉搜索树\"><a class=\"anchor\" href=\"#给定一个二叉树判断其是否是一个有效的二叉搜索树\">#</a> 给定一个二叉树，判断其是否是一个有效的二叉搜索树</h4></li></ol><p>什么是二叉树（Binary Tree)?</p><p>每个结点至多拥有两棵子树的树结构 (即二叉树中不存在度大于 2 的结点)。并且，二叉树的子树有左右之分，其次序不能任意颠倒。通常子树被称作 “左子树”（left subtree）和 “右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p>上面概念中提到了 “度” 的概念，“度” 其实就是某个节点子节点的数量。如果某个节点的子节点数量为 1，则该节点的度为 1，如果有 8 个子节点，则度为 8，以此类推。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>示例 1:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>输入:</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   2</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  / \\</pre></td></tr><tr><td data-num=\"5\"></td><td><pre> 1   3</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>输出: true</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>示例 2:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>输入:</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     5</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    / \\</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   1   4</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  / \\</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> 3   6</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>输出: false</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>解释: 输入为: [5,1,4,null,null,3,6]。</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>根节点的值为 5 ，但是其右子节点值为 4 。</pre></td></tr></table></figure><p>可以直接按照定义比较大小，比 root 节点小的都在左边，比 root 节点大的都在右边:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">type</span> TreeNode <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>      Val <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>      Left <span class=\"token operator\">*</span>TreeNode</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>      Right <span class=\"token operator\">*</span>TreeNode</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">isValidBST</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">*</span>TreeNode<span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> math<span class=\"token punctuation\">.</span>MinInt64<span class=\"token punctuation\">,</span> math<span class=\"token punctuation\">.</span>MaxInt64<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>root <span class=\"token operator\">*</span>TreeNode<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">,</span> max <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token keyword\">if</span> root <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token keyword\">if</span> root<span class=\"token punctuation\">.</span>Val <span class=\"token operator\">&lt;=</span> min <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">if</span> root<span class=\"token punctuation\">.</span>Val <span class=\"token operator\">>=</span> max <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>Left<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">.</span>Val<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">.</span>Right<span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">.</span>Val<span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ol start=\"3\"><li><h4 id=\"排序算法\"><a class=\"anchor\" href=\"#排序算法\">#</a> 排序算法</h4></li></ol><p>排序算法又分为稳定性算法和不稳定性算法：</p><ul><li><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p></li><li><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p></li><li><p>冒泡排序</p></li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token comment\">// 升序</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token function\">bubbleAscendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token function\">bubbleDescendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 升序</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">bubbleAscendingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\t\tarr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bubbleAscendingSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">bubbleDescendingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t\t\tarr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bubbleDescendingSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>bubbleAscendingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">9</span> <span class=\"token number\">10</span> <span class=\"token number\">11</span> <span class=\"token number\">20</span> <span class=\"token number\">27</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bubbleDescendingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">27</span> <span class=\"token number\">20</span> <span class=\"token number\">11</span> <span class=\"token number\">10</span> <span class=\"token number\">9</span> <span class=\"token number\">5</span> <span class=\"token number\">4</span> <span class=\"token number\">3</span> <span class=\"token number\">3</span> <span class=\"token number\">2</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>选择排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">28</span><span class=\"token punctuation\">,</span><span class=\"token number\">17</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">13</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token comment\">// 升序</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token function\">selectAscendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token function\">selectDescendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 升序</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">selectAscendingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tl <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tm <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tk <span class=\"token operator\">:=</span> i</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> arr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\t\tk <span class=\"token operator\">=</span> j</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> k <span class=\"token operator\">!=</span> i <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\tarr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"selectAscendingSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">selectDescendingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\tl <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\tm <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> m<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\tk <span class=\"token operator\">:=</span> i</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> l<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> arr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t\t\t\tk <span class=\"token operator\">=</span> j</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> k <span class=\"token operator\">!=</span> i <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t\t\tarr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"selectDescendingSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>selectDescendingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">5</span> <span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">9</span> <span class=\"token number\">10</span> <span class=\"token number\">13</span> <span class=\"token number\">17</span> <span class=\"token number\">19</span> <span class=\"token number\">28</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>selectAscendingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">28</span> <span class=\"token number\">19</span> <span class=\"token number\">17</span> <span class=\"token number\">13</span> <span class=\"token number\">10</span> <span class=\"token number\">9</span> <span class=\"token number\">7</span> <span class=\"token number\">6</span> <span class=\"token number\">5</span> <span class=\"token number\">4</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>插入排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">13</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">26</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">insertSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"insertSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">insertSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tn <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">></span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t\tarr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>insertSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span> <span class=\"token number\">12</span> <span class=\"token number\">13</span> <span class=\"token number\">15</span> <span class=\"token number\">19</span> <span class=\"token number\">26</span> <span class=\"token number\">27</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>希尔排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">17</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">shellSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"shellSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">shellSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tn <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\th <span class=\"token operator\">:=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token comment\">// 寻找合适的间隔 h</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">for</span> h <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">/</span><span class=\"token number\">3</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\th <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token operator\">*</span>h <span class=\"token operator\">+</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token keyword\">for</span> h <span class=\"token operator\">>=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> h<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> h <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">-=</span> h <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t\tarr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\th <span class=\"token operator\">/=</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>shellSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">6</span> <span class=\"token number\">8</span> <span class=\"token number\">15</span> <span class=\"token number\">17</span> <span class=\"token number\">19</span> <span class=\"token number\">27</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>归并排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tarray <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">55</span><span class=\"token punctuation\">,</span> <span class=\"token number\">94</span><span class=\"token punctuation\">,</span> <span class=\"token number\">87</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">39</span><span class=\"token punctuation\">,</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64</span><span class=\"token punctuation\">,</span> <span class=\"token number\">53</span><span class=\"token punctuation\">,</span> <span class=\"token number\">70</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"before MergeSort\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tarray <span class=\"token operator\">=</span> <span class=\"token function\">MergeSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"after MergeSort:\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">MergeSort</span><span class=\"token punctuation\">(</span>array <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tn <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> array</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\tkey <span class=\"token operator\">:=</span> n <span class=\"token operator\">/</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\tleft <span class=\"token operator\">:=</span> <span class=\"token function\">MergeSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\tright <span class=\"token operator\">:=</span> <span class=\"token function\">MergeSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token keyword\">return</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>left <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> right <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\ttmp <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\ti<span class=\"token punctuation\">,</span> j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token keyword\">for</span>  i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> left<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\t\ttmp <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t\ti <span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t\ttmp <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t\t\tj <span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\ttmp <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\ttmp <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token keyword\">return</span> tmp</pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>before MergeSort <span class=\"token punctuation\">[</span><span class=\"token number\">55</span> <span class=\"token number\">94</span> <span class=\"token number\">87</span> <span class=\"token number\">12</span> <span class=\"token number\">4</span> <span class=\"token number\">32</span> <span class=\"token number\">11</span> <span class=\"token number\">8</span> <span class=\"token number\">39</span> <span class=\"token number\">42</span> <span class=\"token number\">64</span> <span class=\"token number\">53</span> <span class=\"token number\">70</span> <span class=\"token number\">12</span> <span class=\"token number\">9</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>after MergeSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">11</span> <span class=\"token number\">12</span> <span class=\"token number\">12</span> <span class=\"token number\">32</span> <span class=\"token number\">39</span> <span class=\"token number\">42</span> <span class=\"token number\">53</span> <span class=\"token number\">55</span> <span class=\"token number\">64</span> <span class=\"token number\">70</span> <span class=\"token number\">87</span> <span class=\"token number\">94</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>快速排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span><span class=\"token number\">15</span><span class=\"token punctuation\">,</span><span class=\"token number\">23</span><span class=\"token punctuation\">,</span><span class=\"token number\">34</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">quickAscendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"quickAscendingSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token function\">quickDescendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"quickDescendingSort:\"</span><span class=\"token punctuation\">,</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 升序</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">quickAscendingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> end <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\ti<span class=\"token punctuation\">,</span> j <span class=\"token operator\">:=</span> start<span class=\"token punctuation\">,</span> end</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tkey <span class=\"token operator\">:=</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;=</span> j <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> key <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\t\ti<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\t\tj<span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> i <span class=\"token operator\">&lt;=</span> j <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t\t\tarr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\t\t\ti<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t\t\tj<span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> start <span class=\"token operator\">&lt;</span> j <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t\t<span class=\"token function\">quickAscendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> end <span class=\"token operator\">></span> i <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t\t<span class=\"token function\">quickAscendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token comment\">// 降序</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">quickDescendingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> end <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>start <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t\ti<span class=\"token punctuation\">,</span> j <span class=\"token operator\">:=</span> start<span class=\"token punctuation\">,</span> end</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t\tkey <span class=\"token operator\">:=</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> end<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;=</span> j <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\t\t\ti<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t\t\t<span class=\"token keyword\">for</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> key <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\t\t\t\tj<span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>\t\t\t<span class=\"token keyword\">if</span> i <span class=\"token operator\">&lt;=</span> j <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>\t\t\t\tarr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>\t\t\t\ti<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>\t\t\t\tj<span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>\t\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> start <span class=\"token operator\">&lt;</span> j <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>\t\t\t<span class=\"token function\">quickDescendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> end <span class=\"token operator\">></span> i <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>\t\t\t<span class=\"token function\">quickDescendingSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>quickAscendingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">6</span> <span class=\"token number\">7</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">15</span> <span class=\"token number\">16</span> <span class=\"token number\">19</span> <span class=\"token number\">23</span> <span class=\"token number\">34</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>quickDescendingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">34</span> <span class=\"token number\">23</span> <span class=\"token number\">19</span> <span class=\"token number\">16</span> <span class=\"token number\">15</span> <span class=\"token number\">9</span> <span class=\"token number\">8</span> <span class=\"token number\">7</span> <span class=\"token number\">6</span> <span class=\"token number\">3</span> <span class=\"token number\">2</span> <span class=\"token number\">1</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>堆排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tarray <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">52</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span><span class=\"token number\">37</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token number\">29</span><span class=\"token punctuation\">,</span><span class=\"token number\">13</span><span class=\"token punctuation\">,</span><span class=\"token number\">37</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">HeapSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"HeapSort:\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">HeapSort</span><span class=\"token punctuation\">(</span>array <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tm <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\ts <span class=\"token operator\">:=</span> m<span class=\"token operator\">/</span><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> s<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token function\">heap</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> m<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> m<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tarray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token function\">heap</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">heap</span><span class=\"token punctuation\">(</span>array <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> end <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\tl <span class=\"token operator\">:=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">if</span> l <span class=\"token operator\">></span> end <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\tn <span class=\"token operator\">:=</span> l</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\tr <span class=\"token operator\">:=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>i<span class=\"token operator\">+</span><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t<span class=\"token keyword\">if</span> r <span class=\"token operator\">&lt;=</span> end <span class=\"token operator\">&amp;&amp;</span> array<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>array<span class=\"token punctuation\">[</span>l<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t\tn <span class=\"token operator\">=</span> r</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t<span class=\"token keyword\">if</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> array<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\tarray<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token function\">heap</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>HeapSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">9</span> <span class=\"token number\">12</span> <span class=\"token number\">12</span> <span class=\"token number\">13</span> <span class=\"token number\">16</span> <span class=\"token number\">19</span> <span class=\"token number\">27</span> <span class=\"token number\">29</span> <span class=\"token number\">32</span> <span class=\"token number\">37</span> <span class=\"token number\">37</span> <span class=\"token number\">42</span> <span class=\"token number\">52</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>桶排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tarray <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">31</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span><span class=\"token number\">37</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">13</span><span class=\"token punctuation\">,</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token number\">29</span><span class=\"token punctuation\">,</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span><span class=\"token number\">28</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">BucketSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BucketSort:\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">sortInBucket</span><span class=\"token punctuation\">(</span>bucket <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">// 此处实现插入排序方式，其实可以用任意其他排序方式</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tlength <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">if</span> length <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">&#123;</span><span class=\"token keyword\">return</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\tbackup <span class=\"token operator\">:=</span> bucket<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\tj <span class=\"token operator\">:=</span> i <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token comment\">// 将选出的被排数比较后插入左边有序区</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token keyword\">for</span>  j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> backup <span class=\"token operator\">&lt;</span> bucket<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span><span class=\"token comment\">// 注意 j >= 0 必须在前边，否则会数组越界</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\tbucket<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> bucket<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token comment\">// 移动有序数组</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t\tj <span class=\"token operator\">--</span> <span class=\"token comment\">// 反向移动下标</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\tbucket<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> backup <span class=\"token comment\">// 插队插入移动后的空位</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token comment\">// 获取数组最大值</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">getMaxInArr</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\tmax <span class=\"token operator\">:=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> max<span class=\"token punctuation\">&#123;</span> max <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t<span class=\"token keyword\">return</span> max</pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">// 桶排序</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">BucketSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token comment\">// 桶数</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\tnum <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t<span class=\"token comment\">//k（数组最大值）</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\tmax <span class=\"token operator\">:=</span> <span class=\"token function\">getMaxInArr</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t<span class=\"token comment\">// 二维切片</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\tbuckets <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t<span class=\"token comment\">// 分配入桶</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\tindex <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t\tindex <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span>max<span class=\"token comment\">// 分配桶 index = value * (n-1) /k</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\tbuckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t<span class=\"token comment\">// 桶内排序</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\ttmpPos <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> num<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>\t\tbucketLen <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>buckets<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>\t\t<span class=\"token keyword\">if</span> bucketLen <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>\t\t\t<span class=\"token function\">sortInBucket</span><span class=\"token punctuation\">(</span>buckets<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>\t\t\t<span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>tmpPos<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> buckets<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>\t\t\ttmpPos <span class=\"token operator\">+=</span> bucketLen</pre></td></tr><tr><td data-num=\"57\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>\t<span class=\"token keyword\">return</span> arr</pre></td></tr></table></figure><p>运行结果：</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>BucketSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token number\">7</span> <span class=\"token number\">9</span> <span class=\"token number\">10</span> <span class=\"token number\">12</span> <span class=\"token number\">13</span> <span class=\"token number\">16</span> <span class=\"token number\">18</span> <span class=\"token number\">27</span> <span class=\"token number\">28</span> <span class=\"token number\">29</span> <span class=\"token number\">31</span> <span class=\"token number\">32</span> <span class=\"token number\">37</span> <span class=\"token number\">42</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>计数排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tarray <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">69</span><span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span><span class=\"token number\">48</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">17</span><span class=\"token punctuation\">,</span><span class=\"token number\">42</span><span class=\"token punctuation\">,</span><span class=\"token number\">29</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">28</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token function\">countingSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BucketSort:\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">countingSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> maxValue <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tbucketLen <span class=\"token operator\">:=</span> maxValue <span class=\"token operator\">+</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\tbucket <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> bucketLen<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 初始为 0 的数组</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tsortedIndex <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\tlength <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\tbucket<span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> bucketLen<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> bucket<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\t\tarr<span class=\"token punctuation\">[</span>sortedIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t\t\tsortedIndex <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t\tbucket<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t<span class=\"token keyword\">return</span> arr</pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>countingSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token number\">3</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">10</span> <span class=\"token number\">12</span> <span class=\"token number\">16</span> <span class=\"token number\">17</span> <span class=\"token number\">27</span> <span class=\"token number\">28</span> <span class=\"token number\">29</span> <span class=\"token number\">32</span> <span class=\"token number\">42</span> <span class=\"token number\">48</span> <span class=\"token number\">69</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ul><li>基数排序</li></ul><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tarray <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span><span class=\"token number\">28</span><span class=\"token punctuation\">,</span><span class=\"token number\">21</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"before radixSort:\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"after radixSort:\"</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 获取数组的最大值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">maxValue</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>ret <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tret <span class=\"token operator\">=</span> <span class=\"token number\">1</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token keyword\">var</span> key <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> key <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t\tkey <span class=\"token operator\">=</span> key <span class=\"token operator\">*</span> <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t\tret<span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t<span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>arr <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\tkey <span class=\"token operator\">:=</span> <span class=\"token function\">maxValue</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\ttmp <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\tcount <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\tradix <span class=\"token operator\">:=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t<span class=\"token keyword\">var</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> k <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 进行 key 次排序</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\t\tcount<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\t\tk <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> radix<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t\tcount<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 将 tmp 中的为准依次分配给每个桶</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t\t\tcount<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> count<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> count<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t\t\tk <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> radix<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\t\t\ttmp<span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\t\t\tcount<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token operator\">--</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t\t\tarr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tmp<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>\t\tradix <span class=\"token operator\">=</span> radix <span class=\"token operator\">*</span> <span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>before radixSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">12</span> <span class=\"token number\">3</span> <span class=\"token number\">8</span> <span class=\"token number\">5</span> <span class=\"token number\">9</span> <span class=\"token number\">11</span> <span class=\"token number\">23</span> <span class=\"token number\">36</span> <span class=\"token number\">20</span> <span class=\"token number\">28</span> <span class=\"token number\">21</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>after radixSort<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span> <span class=\"token number\">5</span> <span class=\"token number\">8</span> <span class=\"token number\">9</span> <span class=\"token number\">11</span> <span class=\"token number\">12</span> <span class=\"token number\">20</span> <span class=\"token number\">21</span> <span class=\"token number\">23</span> <span class=\"token number\">28</span> <span class=\"token number\">36</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><ol start=\"4\"><li><h4 id=\"如何通过递归反转单链表\"><a class=\"anchor\" href=\"#如何通过递归反转单链表\">#</a> 如何通过递归反转单链表</h4></li></ol><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p><p>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。</p><p>由于不必须按顺序存储，链表在插入的时候可以达到 O (1) 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O (n) 的时间，而线性表和顺序表相应的时间复杂度分别是 O (logn) 和 O (1)。</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p><p>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p><p>链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像 Lisp 和 Scheme 这样的语言的内建数据类型中就包含了链表的存取和操作。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> main</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 通过递归反转单链表</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">type</span> Node <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tValue <span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tNextNode <span class=\"token operator\">*</span>Node</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">Param</span><span class=\"token punctuation\">(</span>node <span class=\"token operator\">*</span>Node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">for</span> node <span class=\"token operator\">!=</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>Value<span class=\"token punctuation\">,</span><span class=\"token string\">\"--->\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\tnode <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>NextNode</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>headNode <span class=\"token operator\">*</span>Node<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Node<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">if</span> headNode <span class=\"token operator\">==</span><span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> headNode</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token keyword\">if</span> headNode<span class=\"token punctuation\">.</span>NextNode <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t<span class=\"token keyword\">return</span> headNode</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t<span class=\"token keyword\">var</span> newNode <span class=\"token operator\">=</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>headNode<span class=\"token punctuation\">.</span>NextNode<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\theadNode<span class=\"token punctuation\">.</span>NextNode<span class=\"token punctuation\">.</span>NextNode <span class=\"token operator\">=</span> headNode</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\theadNode<span class=\"token punctuation\">.</span>NextNode <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t<span class=\"token keyword\">return</span> newNode</pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token keyword\">var</span> node1 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>Node<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\tnode1<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>\tnode2 <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\tnode2<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">=</span> <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\tnode3 <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\tnode3<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">=</span> <span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\tnode4 <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\tnode4<span class=\"token punctuation\">.</span>Value <span class=\"token operator\">=</span> <span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\tnode1<span class=\"token punctuation\">.</span>NextNode <span class=\"token operator\">=</span> node2</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\tnode2<span class=\"token punctuation\">.</span>NextNode <span class=\"token operator\">=</span> node3</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>\tnode3<span class=\"token punctuation\">.</span>NextNode <span class=\"token operator\">=</span> node4</pre></td></tr><tr><td data-num=\"44\"></td><td><pre>\t<span class=\"token function\">Param</span><span class=\"token punctuation\">(</span>node1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>\treverseNode <span class=\"token operator\">:=</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>node1<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>\t<span class=\"token function\">Param</span><span class=\"token punctuation\">(</span>reverseNode<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行结果:</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">4</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">4</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">3</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">2</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token operator\">--</span><span class=\"token operator\">-</span><span class=\"token operator\">></span></pre></td></tr></table></figure><ol start=\"5\"><li><h4 id=\"链表和数组相比有什么优缺点\"><a class=\"anchor\" href=\"#链表和数组相比有什么优缺点\">#</a> 链表和数组相比有什么优缺点</h4></li></ol><p>数组是一块连续的空间，声明时长度就要确定，链表是一块不连续的动态空间，长度可变，数组的优点是速度快，数据操作直接使用偏移地址， 链表需要按顺序检索节点，效率低，链表的优点是可以快速插入和删除节点，大小动态分配长度不需要固定.</p><p>链表不存在越界问题，数组有越界问题.</p><ol start=\"6\"><li><h4 id=\"通常一般会用到哪些数据结构\"><a class=\"anchor\" href=\"#通常一般会用到哪些数据结构\">#</a> 通常一般会用到哪些数据结构</h4></li></ol><p>数据结构是计算机存储、组织数据的方式。对于特定的数据结构 (比如数组)，有些操作效率很高 (读某个数组元素)，有些操作的效率很低 (删除某个数组元素)。开发者的目标是为当前的问题选择最优的数据结构。</p><ol><li>数组：是最常用的数据结构了。其他数据结构，比如栈和队列都是由数组衍生出来的。</li><li>栈：是限定仅表尾进行插入和删除操作的线性表 。</li><li>队列</li><li>链表</li><li>图</li><li>树</li><li>前缀树</li><li>哈希表</li></ol><p>算法可大致分为基本算法、数据结构的算法、数论与代数算法、计算几何的算法、图论的算法、动态规划以及数值分析、加密算法、排序算法、检索算法、随机化算法、并行算法，厄米变形模型，随机森林算法。</p><p>数据对象的运算和操作：计算机可以执行的基本操作是以指令的形式描述的。一个计算机系统能执行的所有指令的集合，成为该计算机系统的指令系统。</p><p>一个计算机的基本运算和操作有如下四类：</p><ul><li>算术运算：加减乘除等运算.</li><li>逻辑运算：或、且、非等运算.</li><li>关系运算：大于、小于、等于、不等于等运算.</li><li>数据传输：输入、输出、赋值等运算.</li></ul><h4 id=\"其他基础-2\"><a class=\"anchor\" href=\"#其他基础-2\">#</a> 其他基础</h4><ol><li><h4 id=\"中间件原理\"><a class=\"anchor\" href=\"#中间件原理\">#</a> 中间件原理</h4></li></ol><p>中间件（middleware）是基础软件的一大类，属于可复用软件的范畴。</p><p>中间件处于操作系统软件与用户的应用软件的中间。中间件在操作系统、网络和数据库之上，应用软件的下层，总的作用是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成复杂的应用软件.</p><p>IDC 的定义是：中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。</p><p>中间件解决的问题是：</p><p>在中间件产生以前，应用软件直接使用操作系统、网络协议和数据库等开发，这些都是计算机最底层的东西，越底层越复杂，开发者不得不面临许多很棘手的问题，如操作系统的多样性，繁杂的网络程序设计、管理，复杂多变的网络环境，数据分散处理带来的不一致性问题、性能和效率、安全，等等。</p><p>这些与用户的业务没有直接关系，但又必须解决，耗费了大量有限的时间和精力。于是，有人提出能不能将应用软件所要面临的共性问题进行提炼、抽象，在操作系统之上再形成一个可复用的部分，供成千上万的应用软件重复使用。这一技术思想最终构成了中间件这类的软件。</p><p>中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><ol start=\"2\"><li><h4 id=\"hash冲突有什么解决办法\"><a class=\"anchor\" href=\"#hash冲突有什么解决办法\">#</a> Hash 冲突有什么解决办法</h4></li></ol><p>解决 hash 冲突的办法目前主要有四种:</p><ul><li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）.</li><li>再哈希法.</li><li>链地址法.</li><li>建立一个公共溢出区.</li></ul><ol start=\"3\"><li><h4 id=\"微服务架构是什么样子的\"><a class=\"anchor\" href=\"#微服务架构是什么样子的\">#</a> 微服务架构是什么样子的</h4></li></ol><p>通常传统的项目体积庞大，需求、设计、开发、测试、部署流程固定。新功能需要在原项目上做修改。</p><p>但是微服务可以看做是对大项目的拆分，是在快速迭代更新上线的需求下产生的。新的功能模块会发布成新的服务组件，与其他已发布的服务组件一同协作。 服务内部有多个生产者和消费者，通常以 http rest 的方式调用，服务总体以一个（或几个）服务的形式呈现给客户使用。</p><p>微服务架构是一种思想对微服务架构我们没有一个明确的定义，但简单来说微服务架构是：</p><p>采用一组服务的方式来构建一个应用，服务独立部署在不同的进程中，不同服务通过一些轻量级交互机制来通信，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。</p><p>Golang 的微服务框架<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb2tpdC5pby8=\"> kit</span> 中有详细的微服务的例子，可以参考学习.</p><p>微服务架构设计包括:</p><ol><li>服务熔断降级限流机制 熔断降级的概念 ( <code>Rate Limiter</code> 限流器， <code>Circuit breaker</code> 断路器).</li><li>框架调用方式解耦方式 <code>Kit</code> 或 <code>Istio</code> 或 <code>Micro</code> 服务发现 (consul zookeeper kubeneters etcd) RPC 调用框架.</li><li>链路监控， <code>zipkin</code> 和 <code>prometheus</code> .</li><li>多级缓存.</li><li>网关 ( <code>kong gateway</code> ).</li><li>Docker 部署管理 <code>Kubenetters</code> .</li><li>自动集成部署 CI/CD 实践.</li><li>自动扩容机制规则.</li><li>压测 优化.</li><li><code>Trasport</code> 数据传输 (序列化和反序列化).</li><li><code>Logging</code> 日志.</li><li><code>Metrics</code> 指针对每个请求信息的仪表盘化.</li></ol><p>微服务架构介绍详细的可以参考:</p><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHN0LmlmaS5sbXUuZGUvTGVocmUvd2lzZS0xNC0xNS9tc2UvbWljcm9zZXJ2aWNlLWFyY2hpdGVjdHVyZXMucGRm\">Microservice Architectures</span></p><ol start=\"4\"><li><h4 id=\"分布式锁实现\"><a class=\"anchor\" href=\"#分布式锁实现\">#</a> 分布式锁实现</h4></li></ol><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p><ol><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</li><li>高可用的获取锁与释放锁；</li><li>高性能的获取锁与释放锁；</li><li>具备可重入特性；</li><li>具备锁失效机制，防止死锁；</li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ol><p>分布式的 CAP 理论告诉我们 “任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项”。<br>所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证 “最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>通常分布式锁以单独的服务方式实现，目前比较常用的分布式锁实现有三种：</p><ul><li>基于数据库实现分布式锁。</li><li>基于缓存 Redis 实现分布式锁。</li><li>基于 Etcd 实现分布式锁。</li></ul><p>尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！</p><ul><li>基于数据库的实现方式</li></ul><p>基于数据库的实现方式的核心思想是，在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><p>使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：</p><p>1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；</p><p>2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；</p><p>3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</p><p>4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</p><p>5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</p><ul><li>基于 Redis 的实现方式</li></ul><p>利用 Redis 的 SetNX 来实现分布式锁，性能高，edis 可持久化，也能保证数据不易丢失，redis 集群方式提高稳定性。</p><ul><li>基于 Etcd 实现分布式锁</li></ul><p>Etcd 提供了实现分布式锁的特性:</p><ol><li>Raft 一致性，是工程上使用较为广泛，强一致性、去中心化、高可用的分布式协议。</li></ol><p>Raft 提供了分布式系统的可靠性功能。详细的查看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYWZ0LmdpdGh1Yi5pby8=\"> Raft</span>.</p><ol start=\"2\"><li>Lease 功能</li></ol><p>Lease 功能，就是租约机制 (TimeToLive, 即 TTL)。</p><ul><li><p>Etcd 可以对存储 <code>Key Value</code> 的数据设置租约，也就是给 <code>Key Value</code> 设置一个过期时间，当租约到期， <code>Key Value</code> 将会失效而被 Etcd 删除。</p></li><li><p>Etcd 同时也支持续约租期，可以通过客户端在租约到期之间续约，以避免 <code>Key Value</code> 失效；</p></li><li><p>Etcd 还支持解约，一旦解约，与该租约绑定的 <code>Key Value</code> 将会失效而删除。</p></li></ul><p>Lease 功能可以保证分布式锁的安全性，为锁对应的 key 配置租约，即使锁的持有者因故障而不能主动释放锁，锁也会因租约到期而自动释放。</p><ol start=\"3\"><li>Watch 功能</li></ol><p>监听功能。Watch 机制支持监听某个固定的 key，它也支持 Watch 一个范围（前缀机制），当被 watch 的 key 或范围发生变化时，客户端将收到通知。</p><p>在实现分布式锁时，如果抢锁失败，可通过 Prefix 机制返回的 <code>Key Value</code> 列表获得 Revision 比自己小且相差最小的 key（称为 pre-key），对 pre-key 进行监听，因为只有它释放锁，自己才能获得锁，如果 Watch 到 pre-key 的 DELETE 事件，则说明 pre-ke 已经释放，自己已经持有锁。</p><ol start=\"4\"><li>Prefix 功能</li></ol><p>前缀机制:</p><p>目录机制，如两个 key 命名如下： <code>key1=“/mykey/key1″</code> , <code>key2=”/mykey/key2″</code> ，那么，可以通过前缀 <code>“/mykey”</code> 查询，返回包含两个 <code>Key Value</code> 对的列表。可以和前面的 watch 功能配合使用。</p><p>通常呢，例如我们创建一个名为 <code>/mylock</code> 的锁，两个争抢它的客户端进行写操作，实际写入的 <code>key</code> 分别为： <code>key1=”/mylock/UUID1″</code> ， <code>key2=”/mylock/UUID2″</code> ，其中， <code>UUID</code> 表示全局唯一的 ID，确保两个 <code>key</code> 的唯一性。</p><p>很显然，写操作都会成功，但返回的 <code>Revision</code> 不一样，那么，如何判断谁获得了锁呢？通过前缀 <code>/mylock</code> 查询，返回包含两个 <code>Key Value</code> 对的的 <code>Key Value</code> 列表，同时也包含它们的 <code>Revision</code> ，通过 <code>Revision</code> 大小，客户端可以判断自己是否获得锁，如果抢锁失败，则等待锁释放（对应的 key 被删除或者租约过期），然后再判断自己是否可以获得锁。</p><p>Lease 功能和 Prefix 功能，能解决上面的死锁问题。</p><ol start=\"5\"><li>Revision 功能</li></ol><p>每个 key 带有一个 <code>Revision</code> 号，每进行一次事务加一，因此它是全局唯一的，如初始值为 0，进行一次 <code>put(key, value)</code> ，key 的 <code>Revision</code> 变为 1；</p><p>同样的操作，再进行一次， <code>Revision</code> 变为 2；换成 <code>key1</code> 进行 <code>put(key1, value)</code> 操作， <code>Revision</code> 将变为 3。</p><p>这种机制有一个作用：</p><p>通过 <code>Revision</code> 的大小就可以知道进行写操作的顺序。在实现分布式锁时，多个客户端同时抢锁，根据 <code>Revision</code> 号大小依次获得锁，可以避免 &quot;惊群效应&quot;，实现公平锁。</p><ol start=\"5\"><li><h4 id=\"负载均衡原理是什么\"><a class=\"anchor\" href=\"#负载均衡原理是什么\">#</a> 负载均衡原理是什么</h4></li></ol><p>负载均衡 Load Balance）是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。负载均衡，其核心就是网络流量分发，分很多维度。</p><p>负载均衡（Load Balance）通常是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p><p>负载均衡是建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p><p>下面通过一个例子详细介绍:</p><ul><li>没有负载均衡 web 架构</li></ul><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/66.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>在这里用户是直连到 web 服务器，如果这个服务器宕机了，那么用户自然也就没办法访问了。另外，如果同时有很多用户试图访问服务器，超过了其能处理的极限，就会出现加载速度缓慢或根本无法连接的情况。</p><p>而通过在后端引入一个负载均衡器和至少一个额外的 web 服务器，可以缓解这个故障。通常情况下，所有的后端服务器会保证提供相同的内容，以便用户无论哪个服务器响应，都能收到一致的内容。</p><ul><li>有负载均衡 web 架构</li></ul><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/67.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>用户访问负载均衡器，再由负载均衡器将请求转发给后端服务器。在这种情况下，单点故障现在转移到负载均衡器上了。这里又可以通过引入第二个负载均衡器来缓解。</p><p>那么负载均衡器的工作方式是什么样的呢，负载均衡器又可以处理什么样的请求？</p><p>负载均衡器的管理员能主要为下面四种主要类型的请求设置转发规则:</p><ul><li>HTTP (七层)</li><li>HTTPS (七层)</li><li>TCP (四层)</li><li>UDP (四层)</li></ul><p>负载均衡器如何选择要转发的后端服务器？</p><p>负载均衡器一般根据两个因素来决定要将请求转发到哪个服务器。首先，确保所选择的服务器能够对请求做出响应，然后根据预先配置的规则从健康服务器池（healthy pool）中进行选择。</p><p>因为，负载均衡器应当只选择能正常做出响应的后端服务器，因此就需要有一种判断后端服务器是否健康的方法。为了监视后台服务器的运行状况，运行状态检查服务会定期尝试使用转发规则定义的协议和端口去连接后端服务器。</p><p>如果服务器无法通过健康检查，就会从池中剔除，保证流量不会被转发到该服务器，直到其再次通过健康检查为止。</p><ul><li>负载均衡算法</li></ul><p>负载均衡算法决定了后端的哪些健康服务器会被选中。 其中常用的算法包括：</p><ol><li>Round Robin（轮询）：为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。</li><li>Least Connections（最小连接）：优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。</li><li>Source：根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。</li></ol><p>如果你的应用需要处理状态而要求用户能连接到和之前相同的服务器。可以通过 Source 算法基于客户端的 IP 信息创建关联，或者使用粘性会话（sticky sessions）。</p><p>除此之外，想要解决负载均衡器的单点故障问题，可以将第二个负载均衡器连接到第一个上，从而形成一个集群。</p><ol start=\"6\"><li><h4 id=\"互斥锁和读写锁和死锁问题是怎么解决\"><a class=\"anchor\" href=\"#互斥锁和读写锁和死锁问题是怎么解决\">#</a> 互斥锁和读写锁和死锁问题是怎么解决</h4></li></ol><ul><li>互斥锁</li></ul><p>互斥锁就是互斥变量 mutex，用来锁住临界区的.</p><p>条件锁就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行；读写锁，也类似，用于缓冲区等临界资源能互斥访问的。</p><ul><li>读写锁</li></ul><p>通常有些公共数据修改的机会很少，但其读的机会很多。并且在读的过程中会伴随着查找，给这种代码加锁会降低我们的程序效率。读写锁可以解决这个问题。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/61.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>注意：写独占，读共享，写锁优先级高</p><ul><li>死锁</li></ul><p>一般情况下，如果同一个线程先后两次调用 <code>lock</code> ，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。</p><p>另外一种情况是：若线程 A 获得了锁 1，线程 B 获得了锁 2，这时线程 A 调用 lock 试图获得锁 2，结果是需要挂起等待线程 B 释放锁 2，而这时线程 B 也调用 lock 试图获得锁 1，结果是需要挂起等待线程 A 释放锁 1，于是线程 A 和 B 都永远处于挂起状态了。</p><p>死锁产生的四个必要条件:</p><ol><li>互斥条件：一个资源每次只能被一个进程使用.</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><p>a. 预防死锁</p><p>可以把资源一次性分配：(破坏请求和保持条件).</p><p>然后剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）.</p><p>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）.</p><p>b. 避免死锁</p><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前预先计算资源分配的安全性。<br>若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。</p><p>c. 检测死锁</p><p>首先为每个进程和每个资源指定一个唯一的号码，然后建立资源分配表和进程等待表.</p><p>d. 解除死锁</p><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有.</p><p>e. 剥夺资源</p><p>从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态.</p><p>f. 撤消进程</p><p>可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态。消除为止。所谓代价是指优先级、运行代价、进程的重要性和价值等。</p><ol start=\"7\"><li><h4 id=\"etcd的raft一致性算法原理\"><a class=\"anchor\" href=\"#etcd的raft一致性算法原理\">#</a> Etcd 的 Raft 一致性算法原理</h4></li></ol><p>Etcd 中的 Raft 一致性算法原理：</p><p>Raft 将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）.</p><ol><li>Leader：接受客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后告诉 Follower 提交日志。</li><li>Follower：接受并持久化 Leader 同步的日志，在 Leader 告之日志可以提交之后，提交日志。</li><li>Candidate：Leader 选举过程中的临时角色。</li></ol><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/146.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>Raft 要求系统在任意时刻最多只有一个 Leader，正常工作期间只有 Leader 和 Followers。</p><p>Raft 算法角色状态转换如下：</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/147.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>Follower 只响应其他服务器的请求。如果 Follower 超时没有收到 Leader 的消息，它会成为一个 Candidate 并且开始一次 Leader 选举。收到大多数服务器投票的 Candidate 会成为新的 Leader。Leader 在宕机之前会一直保持 Leader 的状态。</p><p>Raft 算法将时间分为一个个的任期（term），每一个 term 的开始都是 Leader 选举。在成功选举 Leader 之后，Leader 会在整个 term 内管理整个集群。如果 Leader 选举失败，该 term 就会因为没有 Leader 而结束。</p><p>Leader 选举:</p><p>Raft 使用心跳（heartbeat）触发 Leader 选举。当服务器启动时，初始化为 Follower。Leader 向所有 Followers 周期性发送 heartbeat。如果 Follower 在选举超时时间内没有收到 Leader 的 heartbeat，就会等待一段随机的时间后发起一次 Leader 选举。</p><p>Follower 将其当前 term 加一然后转换为 Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC （RPC 细节参见八、Raft 算法总结）。</p><p>结果有以下三种情况:</p><p>1. 赢得了多数的选票，成功选举为 Leader；<br>2. 收到了 Leader 的消息，表示有其它服务器已经抢先当选了 Leader；<br>3. 没有服务器赢得多数的选票，Leader 选举失败，等待选举时.</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/148.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>Raft 日志同步保证如下两点：</p><ol><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li><li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li></ol><p>Leader 通过强制 Followers 复制它的日志来处理日志的不一致，Followers 上的不一致的日志会被 Leader 的日志覆盖。Leader 为了使 Followers 的日志同自己的一致，Leader 需要找到 Followers 同它的日志一致的地方，然后覆盖 Followers 在该位置之后的条目。</p><p>Leader 会从后往前试，每次 AppendEntries 失败后尝试前一个日志条目，直到成功找到每个 Follower 的日志一致位点，然后向后逐条覆盖 Followers 在该位置之后的条目。</p><p>Raft 增加了如下两条限制以保证安全性：</p><ol><li><p>拥有最新的已提交的 log entry 的 Follower 才有资格成为 Leader。<br>这个保证是在 RequestVote RPC 中做的，Candidate 在发送 RequestVote RPC 时，要带上自己的最后一条日志的 term 和 log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条 log entry 的 term 更大，则 term 大的更新，如果 term 一样大，则 log index 更大的更新。</p></li><li><p>Leader 只能推进 commit index 来提交当前 term 的已经复制到大多数服务器上的日志，旧 term 日志的提交要等到提交当前 term 的日志来间接提交（log index 小于 commit index 的日志被间接提交）。</p></li></ol><p>日志压缩:</p><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft 采用对整个系统进行 snapshot 来解决，snapshot 之前的日志都可以丢弃。</p><p>每个副本独立的对自己的系统状态进行 snapshot，并且只能对已经提交的日志记录进行 snapshot。</p><p>做 snapshot 既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次 snapshot。<br>做一次 snapshot 可能耗时过长，会影响正常日志同步。可以通过使用 copy-on-write 技术避免 snapshot 过程影响正常日志同步.</p><ol start=\"8\"><li><h4 id=\"git的merge跟rebase的区别\"><a class=\"anchor\" href=\"#git的merge跟rebase的区别\">#</a> Git 的 merge 跟 rebase 的区别</h4></li></ol><p>在使用 git 进行版本管理的项目中，当完成一个特性的开发并将其合并到 master 分支时，我们有两种方式： <code>git merge</code> 和 <code>git rebase</code> 。</p><p>通常，我们对 <code>git merge</code> 使用的较多，而对于 <code>git rebase</code> 使用的较少，其实 <code>git rebase</code> 也是极其强大的一种方法。</p><ul><li>git merge<br><code>git merge</code> 的使用方法很简单，假如你想将分支 feature 合并到分支 master，那么只需执行如下两步即可：</li></ul><p>将分支切换到 master 上去： <code>git checkout master</code> 将分支 feature 合并到当前分支（即 master 分支）上： <code>git merge feature</code> .</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/107.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p><code>git merge</code> 有如下特点：</p><p><code>git merge</code> 只处理一次冲突，引入了一次合并的历史记录，合并后的所有 commit 会按照提交时间从旧到新排列所有的过程信息更多，可能会提高之后查找问题的难度</p><p>因此 <code>git merge</code> 提交的信息过多可能会影响查找问题的难度，在一个大型项目中，单纯依靠 <code>git merge</code> 方法进行合并，会保存所有的提交过程的信息：引出分支，合并分支，在分支上再引出新的分支等等，类似这样的操作一多，提交历史信息就会显得杂乱，这时如果有问题需要查找就会比较困难了。</p><ul><li>git rebase</li></ul><p><code>git rebase</code> 的目的也是将一个分支的更改并入到另外一个分支中去。但是 <code>git rebase</code> 会把你的所有分支信息衍合成一条信息，减少中间不必要的历史记录.</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/108.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p><code>git rebase</code> 特点:</p><ul><li><code>git rebase</code> 会改变当前分支从 master 上拉出分支的位置.</li><li>没有多余的合并历史的记录，且合并后的 commit 顺序不一定按照 commit 的提交时间排列.</li><li>可能会多次解决同一个地方的冲突（有 squash 来解决）.</li><li>更清爽一些，master 分支上每个 commit 点都是相对独立完整的功能单元.</li></ul><p>因此，当需要保留详细的合并信息的时候建议使用 git merge，特别是需要将分支合并进入 master 分支时；当发现自己修改某个功能时，频繁进行了 <code>git commit</code> 提交时，发现其实过多的提交信息没有必要时，可以尝试 <code>git rebase</code> 。</p><ol start=\"9\"><li><h4 id=\"如何对一个20gb的文件进行排序\"><a class=\"anchor\" href=\"#如何对一个20gb的文件进行排序\">#</a> 如何对一个 20GB 的文件进行排序</h4></li></ol><p>内存肯定没有 20GB 大，所以不可能采用传统排序法。但是可以将文件分成许多块，每块 xMB, 针对每个块各自进行排序，存回文件系统。然后将这些块逐一合并，最终得到全部排好序的文件。</p><p>外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。比如，要对 900MB 的数据进行排序，但机器上只有 100 MB 的可用内存时，外归并排序按如下方法操作：</p><p>读入 100 MB 的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。</p><p>将排序完成的数据写入磁盘。</p><p>重复步骤 1 和 2 直到所有的数据都存入了不同的 100 MB 的块（临时文件）中。在这个例子中，有 900 MB 数据，单个临时文件大小为 100 MB，所以会产生 9 个临时文件。 读入每个临时文件（顺串）的前 10 MB（ = 100 MB / (9 块 + 1)）的数据放入内存中的输入缓冲区，最后的 10 MB 作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）</p><p>执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦 9 个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个 10M 数据，除非这个文件已读完。这是 “外归并排序” 能在主存外完成排序的关键步骤，因为 “归并算法”(merge algorithm) 对每一个大块只是顺序地做一轮访问 (进行归并)，每个大块不用完全载入主存。</p><ol start=\"10\"><li><h4 id=\"lvs原理是什么\"><a class=\"anchor\" href=\"#lvs原理是什么\">#</a> LVS 原理是什么</h4></li></ol><p>LVS 是 <code>Linux Virtual Server</code> 的简称，也就是 Linux 虚拟服务器。这是一个由章文嵩博士发起的一个开源项目，它的官方网站是<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saW51eHZpcnR1YWxzZXJ2ZXIub3JnLw==\"> LinuxVirtualServer</span> 现在 LVS 已经是 Linux 内核标准的一部分。<br>使用 LVS 可以达到的技术目标是：通过 LVS 达到的负载均衡技术和 Linux 操作系统实现一个高性能高可用的 Linux 服务器集群，它具有良好的可靠性、可扩展性和可操作性。<br>从而以低廉的成本实现最优的性能。LVS 是一个实现负载均衡集群的开源软件项目，LVS 架构从逻辑上可分为调度层、Server 集群层和共享存储。</p><p>LVS 的基本工作原理:</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/68.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ol><li>当用户向负载均衡调度器（Director Server）发起请求，调度器将请求发往至内核空间.</li><li>PREROUTING 链首先会接收到用户请求，判断目标 IP 确定是本机 IP，将数据包发往 INPUT 链.</li><li>IPVS 是工作在 INPUT 链上的，当用户请求到达 INPUT 时，IPVS 会将用户请求和自己已定义好的集群服务进行比对，如果用户请求的就是定义的集群服务，那么此时 IPVS 会强行修改数据包里的目标 IP 地址及端口，并将新的数据包发往 POSTROUTING 链.</li><li>POSTROUTING 链接收数据包后发现目标 IP 地址刚好是自己的后端服务器，那么此时通过选路，将数据包最终发送给后端的服务器.</li></ol><p>LVS 的由 2 部分程序组成，包括 Ipvs 和 Ipvsadm。</p><ul><li>Ipvs (ip virtual server)：一段代码工作在内核空间，叫 Ipvs，是真正生效实现调度的代码。</li><li>Ipvsadm：另外一段是工作在用户空间，叫 Ipvsadm，负责为 Ipvs 内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器 (Real Server)</li></ul><ol start=\"11\"><li><h4 id=\"为什么需要消息队列\"><a class=\"anchor\" href=\"#为什么需要消息队列\">#</a> 为什么需要消息队列</h4></li></ol><p>解耦，异步处理，削峰 / 限流.</p><ol start=\"12\"><li><h4 id=\"高并发系统的设计与实现\"><a class=\"anchor\" href=\"#高并发系统的设计与实现\">#</a> 高并发系统的设计与实现</h4></li><li><h4 id=\"kafka的文件存储机制\"><a class=\"anchor\" href=\"#kafka的文件存储机制\">#</a> Kafka 的文件存储机制</h4></li></ol><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;500&quot; align=&quot;center&quot; src=&quot;../images/175.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>Kafka 是最初由 Linkedin 公司开发，是一个分布式、分区的、多副本的、多订阅者，基于 zookeeper 协调的分布式日志系统 (也可以当做 MQ 系统)，常见可以用于 web/nginx 日志、访问日志，消息服务等。</p><p>一个商业化消息队列的性能好坏，其文件存储机制设计是衡量一个消息队列服务技术水平和最关键指标之一。</p><p>Kafka 中的名词解释如下：</p><ul><li>Broker：消息中间件处理结点，一个 Kafka 节点就是一个 broker，多个 broker 可以组成一个 Kafka 集群。</li><li>Topic：一类消息，例如 <code>page view</code> 日志、click 日志等都可以以 topic 的形式存在，Kafka 集群能够同时负责多个 topic 的分发。</li><li>Partition：topic 物理上的分组，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。</li><li>Segment：partition 物理上由多个 segment 组成，下面 2.2 和 2.3 有详细说明。</li><li>offset：每个 partition 都由一系列有序的、不可变的消息组成，这些消息被连续的追加到 partition 中。partition 中的每个消息都有一个连续的序列号叫做 offset, 用于 partition 唯一标识一条消息.</li></ul><p>Kafka 运行时很少有大量读磁盘的操作，主要是定期批量写磁盘操作，因此操作磁盘很高效。这跟 Kafka 文件存储中读写 message 的设计是息息相关的。Kafka 中读写 message 有如下特点:</p><p>写 message：</p><ul><li>消息从堆转入 <code>page cache</code> (即物理内存)。</li><li>由异步线程刷盘，消息从 page cache 刷入磁盘。</li></ul><p>读 message：</p><ul><li>消息直接从 page cache 转入 socket 发送出去。</li><li>当从 page cache 没有找到相应数据时，此时会产生磁盘 IO, 从磁 盘 Load 消息到 page cache, 然后直接从 socket 发出去。</li></ul><p>Kafka 高效文件存储设计特点：</p><p>Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</p><p>通过索引信息可以快速定位 message 和确定 response 的最大大小。 通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。 通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。</p><ol start=\"14\"><li><h4 id=\"kafka如何保证可靠性\"><a class=\"anchor\" href=\"#kafka如何保证可靠性\">#</a> Kafka 如何保证可靠性</h4></li></ol><p>在 Kafka 0.8.0 版本之前，Kafka 是没有副本的概念的，那时候人们只会用 Kafka 存储一些不重要的数据，因为没有副本，数据很可能会丢失。但是随着业务的发展，支持副本的功能越来越强烈，所以为了保证数据的可靠性，Kafka 从 0.8.0 版本开始引入了分区副本。也就是说每个分区可以人为的配置几个副本（比如创建主题的时候指定 replication-factor，也可以在 Broker 级别进行配置 default.replication.factor），一般会设置为 3。</p><p>Kafka 可以保证单个分区里的事件是有序的，分区可以在线（可用），也可以离线（不可用）。在众多的分区副本里面有一个副本是 Leader，其余的副本是 follower，所有的读写操作都是经过 Leader 进行的，同时 follower 会定期地去 leader 上复制数据。当 Leader 挂掉之后，其中一个 follower 会重新成为新的 Leader。通过分区副本，引入了数据冗余，同时也提供了 Kafka 的数据可靠性。</p><p>Kafka 的分区多副本架构是 Kafka 可靠性保证的核心，把消息写入多个副本可以使 Kafka 在发生崩溃时仍能保证消息的持久性。</p><ol start=\"15\"><li><h4 id=\"kafka是如何实现高吞吐率的\"><a class=\"anchor\" href=\"#kafka是如何实现高吞吐率的\">#</a> Kafka 是如何实现高吞吐率的</h4></li></ol><p>kafka 主要使用了以下几个方式实现了超高的吞吐率:</p><ul><li>顺序读写</li></ul><p>kafka 的消息是不断追加到文件中的，这个特性使 kafka 可以充分利用磁盘的顺序读写性能，顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写.</p><p>Kafka 官方给出了测试数据 (Raid-5，7200rpm)：</p><ul><li><p>顺序 <code>I/O</code> : 600MB/s.</p></li><li><p>随机 <code>I/O</code> : 100KB/s.</p></li><li><p>零拷贝</p></li></ul><p>我们可以先简单了解下文件系统的操作流程，例如一个程序要把文件内容发送到网络，这个程序是工作在用户空间，文件和网络 socket 属于硬件资源，两者之间有一个内核空间.</p><p>在操作系统内部，整个过程为：</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/172.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>在 Linux kernel2.2 之后出现了一种叫做 &quot;零拷贝 (zero-copy)&quot; 系统调用机制，就是跳过 “用户缓冲区” 的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到 “用户态缓冲区”，系统上下文切换减少为 2 次，可以提升一倍的性能。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/173.jpg&quot; /&gt;<br>&lt;/p&gt;</p><ul><li>文件分段</li></ul><p>kafka 的队列 topic 被分为了多个区 partition，每个 partition 又分为多个段 segment，所以一个队列中的消息实际上是保存在 N 多个片段文件中。</p><p>&lt;p align=&quot;center&quot;&gt;<br>&lt;img width=&quot;300&quot; align=&quot;center&quot; src=&quot;../images/174.jpg&quot; /&gt;<br>&lt;/p&gt;</p><p>通过分段的方式，每次文件操作都是对一个小文件的操作，非常轻便，同时也增加了并行处理能力。</p><ul><li>批量发送</li></ul><p>Kafka 允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去，比如可以指定缓存的消息达到某个量的时候就发出去，或者缓存了固定的时间后就发送出去，如 100 条消息就发送，或者每 5 秒发送一次，这种策略将大大减少服务端的 I/O 次数。</p><ul><li>数据压缩</li></ul><p>Kafka 还支持对消息集合进行压缩，Producer 可以通过 GZIP 或 Snappy 格式对消息集合进行压缩，压缩的好处就是减少传输的数据量，减轻对网络传输的压力。Producer 压缩之后，在 Consumer 需进行解压，虽然增加了 CPU 的工作，但在对大数据处理上，瓶颈在网络上而不是 CPU，所以这个成本很值得。</p><h4 id=\"分布式事务有哪几种\"><a class=\"anchor\" href=\"#分布式事务有哪几种\">#</a> 分布式事务有哪几种</h4><p>分布式事务就是指事务的发起者、资源及资源管理器和事务协调者分别位于分布式系统的不同节点之上。分布式事务是在分布式环境下，遵循 CAP 理论，在 CAP 三者中只能够三选二，那么分布式事务是那种的组合呢？</p><p>分布式事务是 CP+HA，其中 A 是没有完全符合，但是能够达到 Highly-Available，即高可用。</p><p>近些年分布式理论进一步发展，产生了 Paxos、Raft 等 CP 的协议，在这基础上，加上硬件稳定性升级，可以在保证 CP 的情况下，做到高可用。谷歌分布式锁 Chubby 的公开数据显示，集群能提供 99.99958％的平均可用性，一年也就 130s 的运行中断，已经能够满足非常严苛的应用要求。现在的 SQL 类数据库软件，都是走 CP+HA，只是 HA 会比谷歌的这个极致数据更低一些，但一般都能够达到 4 个 9</p><p>CP+HA 意味着不是 BASE，意味着你只要写入成功，那么接下来的读，能够读取到最新的结果，开发人员不用担心读取到的不是最新数据，在多副本读写上面，与单机是一致的。</p><p>分布式事务会部分遵循 ACID 规范：</p><ul><li>原子性：严格遵循</li><li>一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽</li><li>隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽</li><li>持久性：严格遵循</li></ul><p>因为事务过程中，不是一致的，但事务会最终完成，最终达到一致，所以我们把分布式事务称为 “最终一致”。</p><p>分布式事务目前主要有：可靠事件队列 (两阶段提交)，SAGA，TCC.</p><p>CAP 理论中：</p><ul><li><p>一致性（Consistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。一致性在分布式研究中是有严肃定义、有多种细分类型的概念，以后讨论分布式共识算法时，我们还会再提到一致性，那种面向副本复制的一致性与这里面向数据库状态的一致性严格来说并不完全等同，具体差别我们将在后续分布式共识算法中再作探讨。</p></li><li><p>可用性（Availability）：代表系统不间断地提供服务的能力，理解可用性要先理解与其密切相关两个指标：可靠性（Reliability）和可维护性（Serviceability）。可靠性使用平均无故障时间（Mean Time Between Failure，MTBF）来度量；可维护性使用平均可修复时间（Mean Time To Repair，MTTR）来度量。可用性衡量系统可以正常使用的时间与总时间之比，其表征为：A=MTBF/（MTBF+MTTR），即可用性是由可靠性和可维护性计算得出的比例值，譬如 99.9999% 可用，即代表平均年故障修复时间为 32 秒。</p></li><li><p>分区容忍性（Partition Tolerance）: 代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成 “网络分区” 时，系统仍能正确地提供服务的能力。</p></li></ul><p>由于 CAP 定理已有严格的证明，我们也不去探讨为何 CAP 不可兼得，而是直接分析如果舍弃 C、A、P 时所带来的不同影响。</p><ul><li><p>如果放弃分区容忍性（CA without P）, 意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的，这不是你想不想的问题，而是只要用到网络来共享数据，分区现象就会始终存在。在现实中，最容易找到放弃分区容忍性的例子便是传统的关系数据库集群，这样的集群虽然依然采用由网络连接的多个节点来协同工作，但数据却不是通过网络来实现共享的。以 Oracle 的 RAC 集群为例，它的每一个节点均有自己独立的 SGA、重做日志、回滚日志等部件，但各个节点是通过共享存储中的同一份数据文件和控制文件来获取数据的，通过共享磁盘的方式来避免出现网络分区。因而 Oracle RAC 虽然也是由多个实例组成的数据库，但它并不能称作是分布式数据库。</p></li><li><p>如果放弃可用性（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面 “全局事务” 中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中，除了 DTP 模型的分布式数据库事务外，著名的 HBase 也是属于 CP 系统，以 HBase 集群为例，假如某个 RegionServer 宕机了，这个 RegionServer 持有的所有键值范围都将离线，直到数据恢复过程完成为止，这个过程要消耗的时间是无法预先估计的。</p></li><li><p>如果放弃一致性（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，很多分布式系统可能就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，以 Redis 集群为例，如果某个 Redis 节点出现网络分区，那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务，但这时有可能出现请求分配到不同节点时返回给客户端的是不一致的数据。</p></li></ul><p>“选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择” 这个结论感到一丝无奈，“事务” 原本的目的就是获得 “一致性”，而在分布式环境中，“一致性” 却不得不成为通常被牺牲、被放弃的那一项属性。但无论如何，我们建设信息系统，终究还是要确保操作结果至少在最终交付的时候是正确的。为此，人们又重新给一致性下了定义，将前面我们在 CAP、ACID 中讨论的一致性称为 “强一致性”（Strong Consistency），有时也称为 “线性一致性”（Linearizability，通常是在讨论共识算法的场景中），而把牺牲了 C 的 AP 系统又要尽可能获得正确的结果的行为称为追求 “弱一致性”。</p><p>不过，如果单纯只说 “弱一致性” 那其实就是 “不保证一致性” 的意思…… 人类语言这东西真的是博大精深。在弱一致性里，人们又总结出了一种稍微强一点的特例，被称为 “最终一致性”（Eventual Consistency），它是指：如果数据在一段时间之内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果，有时候面向最终一致性的算法也被称为 “乐观复制算法”.</p><p>分布式事务目前主要有:</p><ul><li>可靠事件队列：</li></ul><p>最终一致性的概念是 eBay 的系统架构师 Dan Pritchett 在 2008 年在 ACM 发表的论文《Base: An Acid Alternative》中提出的，该论文总结了一种独立于 ACID 获得的强一致性之外的、使用 BASE 来达成一致性目的的途径。BASE 分别是基本可用性（Basically Available）、柔性事务（Soft State）和最终一致性（Eventually Consistent）的缩写。</p><p>BASE 这提法简直是把数据库科学家酷爱凑缩写的恶趣味发挥到淋漓尽致，不过有 ACID vs BASE 这个朗朗上口的梗，该论文的影响力的确传播得足够快。虽然调侃它是恶趣味，但这篇论文本身作为最终一致性的概念起源，并系统性地总结了一种针对分布式事务的技术手段，是非常有价值的。</p><p>靠着持续重试来保证可靠性的解决方案谈不上是 <code>Dan Pritchett</code> 的首创或者独创，它在计算机的其他领域中已被频繁使用，也有了专门的名字叫作 “最大努力交付”（Best-Effort Delivery），譬如 TCP 协议中未收到 ACK 应答自动重新发包的可靠性保障就属于最大努力交付。</p><p>而可靠事件队列还有一种更普通的形式，被称为 “最大努力一次提交”（Best-Effort 1PC），指的就是将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式（不限于消息系统）来促使同一个分布式事务中的其他关联业务全部完成。</p><ul><li>TCC 事务:</li></ul><p>TCC 是另一种常见的分布式事务机制，它是 “Try-Confirm-Cancel” 三个单词的缩写，是由数据库专家 Pat Helland 在 2007 年撰写的论文《Life beyond Distributed Transactions: An Apostate’s Opinion》中提出。</p><p>前面介绍的可靠消息队列虽然能保证最终的结果是相对可靠的，过程也足够简单（相对于 TCC 来说），但整个过程完全没有任何隔离性可言，有一些业务中隔离性是无关紧要的，但有一些业务中缺乏隔离性就会带来许多麻烦。譬如在本章的场景事例中，缺乏隔离性会带来的一个显而易见的问题便是 “超售”：完全有可能两个客户在短时间内都成功购买了同一件商品，而且他们各自购买的数量都不超过目前的库存，但他们购买的数量之和却超过了库存。如果这件事情处于刚性事务，且隔离级别足够的情况下是可以完全避免的，譬如，以上场景就需要 “可重复读”（Repeatable Read）的隔离级别，以保证后面提交的事务会因为无法获得锁而导致失败，但用可靠消息队列就无法保证这一点，这部分属于数据库本地事务方面的知识，可以参考前面的讲解。如果业务需要隔离，那架构师通常就应该重点考虑 TCC 方案，该方案天生适合用于需要强隔离性的分布式事务中。</p><p>在具体实现上，TCC 较为烦琐，它是一种业务侵入式较强的事务方案，要求业务处理过程必须拆分为 “预留业务资源” 和 “确认 / 释放消费资源” 两个子过程。如同 TCC 的名字所示，它分为以下三个阶段。</p><ul><li><p>Try：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</p></li><li><p>Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</p></li><li><p>Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</p></li><li><p>SAGA 事务:</p></li></ul><p>TCC 事务具有较强的隔离性，避免了 “超售” 的问题，而且其性能一般来说是本篇提及的几种柔性事务模式中最高的，但它仍不能满足所有的场景。TCC 的最主要限制是它的业务侵入性很强，这里并不是重复上一节提到的它需要开发编码配合所带来的工作量，而更多的是指它所要求的技术可控性上的约束。譬如，把我们的场景事例修改如下：由于中国网络支付日益盛行，现在用户和商家在书店系统中可以选择不再开设充值账号，至少不会强求一定要先从银行充值到系统中才能进行消费，允许直接在购物时通过 U 盾或扫码支付，在银行账号中划转货款。这个需求完全符合国内网络支付盛行的现状，却给系统的事务设计增加了额外的限制：如果用户、商家的账号余额由银行管理的话，其操作权限和数据结构就不可能再随心所欲的地自行定义，通常也就无法完成冻结款项、解冻、扣减这样的操作，因为银行一般不会配合你的操作。所以 TCC 中的第一步 Try 阶段往往无法施行。我们只能考虑采用另外一种柔性事务方案：SAGA 事务。SAGA 在英文中是 “长篇故事、长篇记叙、一长串事件” 的意思。</p><p>SAGA 事务模式的历史十分悠久，还早于分布式事务概念的提出。它源于 1987 年普林斯顿大学的 Hector Garcia-Molina 和 Kenneth Salem 在 ACM 发表的一篇论文《SAGAS》（这就是论文的全名）。文中提出了一种提升 “长时间事务”（Long Lived Transaction）运作效率的方法，大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。原本 SAGA 的目的是避免大事务长时间锁定数据库的资源，后来才发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。SAGA 由两部分操作组成。</p><p>大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti 等价。</p><p>为每一个子事务设计对应的补偿动作，命名为 C1，C2，…，Ci，…，Cn。Ti 与 Ci 必须满足以下条件：</p><ul><li>Ti 与 Ci 都具备幂等性。</li><li>Ti 与 Ci 满足交换律（Commutative），即先执行 Ti 还是先执行 Ci，其效果都是一样的。</li><li>Ci 必须能成功提交，即不考虑 Ci 本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。</li></ul><p>如果 T1 到 Tn 均成功提交，那事务顺利完成，否则，要采取以下两种恢复策略之一：</p><ul><li><p>正向恢复（Forward Recovery）：如果 Ti 事务提交失败，则一直对 Ti 进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。</p></li><li><p>反向恢复（Backward Recovery）：如果 Ti 事务提交失败，则一直执行 Ci 对 Ti 进行补偿，直至成功为止（最大努力交付）。这里要求 Ci 必须（在持续重试后）执行成功。反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。</p></li></ul><p>与 TCC 相比，SAGA 不需要为资源设计冻结状态和撤销冻结的操作，补偿操作往往要比冻结操作容易实现得多。譬如，前面提到的账号余额直接在银行维护的场景，从银行划转货款到 Fenix's Bookstore 系统中，这步是经由用户支付操作（扫码或 U 盾）来促使银行提供服务；如果后续业务操作失败，尽管我们无法要求银行撤销掉之前的用户转账操作，但是由 Fenix's Bookstore 系统将货款转回到用户账上作为补偿措施却是完全可行的。</p><p>SAGA 必须保证所有子事务都得以提交或者补偿，但 SAGA 系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为 SAGA Log）以保证系统恢复后可以追踪到子事务的执行情况，譬如执行至哪一步或者补偿至哪一步了。另外，尽管补偿操作通常比冻结 / 撤销容易实现，但保证正向、反向恢复过程的能严谨地进行也需要花费不少的工夫，譬如通过服务编排、可靠事件队列等方式完成，所以，SAGA 事务通常也不会直接靠裸编码来实现，一般也是在事务中间件的基础上完成，前面提到的 Seata 就同样支持 SAGA 事务模式。</p><p>基于数据补偿来代替回滚的思路，还可以应用在其他事务方案上，这些方案笔者就不开独立小节，放到这里一起来解释。举个具体例子，譬如阿里的 GTS（Global Transaction Service，Seata 由 GTS 开源而来）所提出的 “AT 事务模式” 就是这样的一种应用。</p><p>从整体上看是 AT 事务是参照了 XA 两段提交协议实现的，但针对 XA 2PC 的缺陷，即在准备阶段必须等待所有数据源都返回成功后，协调者才能统一发出 Commit 命令而导致的木桶效应（所有涉及的锁和资源都需要等待到最慢的事务完成后才能统一释放），设计了针对性的解决方案。大致的做法是在业务数据提交时自动拦截所有 SQL，将 SQL 对数据修改前、修改后的结果分别保存快照，生成行锁，通过本地事务一起提交到操作的数据源中，相当于自动记录了重做和回滚日志。如果分布式事务成功提交，那后续清理每个数据源中对应的日志数据即可；如果分布式事务需要回滚，就根据日志数据自动产生用于补偿的 “逆向 SQL”。基于这种补偿方式，分布式事务中所涉及的每一个数据源都可以单独提交，然后立刻释放锁和资源。这种异步提交的模式，相比起 2PC 极大地提升了系统的吞吐量水平。而代价就是大幅度地牺牲了隔离性，甚至直接影响到了原子性。因为在缺乏隔离性的前提下，以补偿代替回滚并不一定是总能成功的。譬如，当本地事务提交之后、分布式事务完成之前，该数据被补偿之前又被其他操作修改过，即出现了脏写（Dirty Write），这时候一旦出现分布式事务需要回滚，就不可能再通过自动的逆向 SQL 来实现补偿，只能由人工介入处理了。</p><p>通常来说，脏写是一定要避免的，所有传统关系数据库在最低的隔离级别上都仍然要加锁以避免脏写，因为脏写情况一旦发生，人工其实也很难进行有效处理。所以 GTS 增加了一个 “全局锁”（Global Lock）的机制来实现写隔离，要求本地事务提交之前，一定要先拿到针对修改记录的全局锁后才允许提交，没有获得全局锁之前就必须一直等待，这种设计以牺牲一定性能为代价，避免了有两个分布式事务中包含的本地事务修改了同一个数据，从而避免脏写。在读隔离方面，AT 事务默认的隔离级别是读未提交（Read Uncommitted），这意味着可能产生脏读（Dirty Read）。也可以采用全局锁的方案解决读隔离问题，但直接阻塞读取的话，代价就非常大了，一般不会这样做。由此可见，分布式事务中没有一揽子包治百病的解决办法，因地制宜地选用合适的事务处理方案才是唯一有效的做法。</p><h4 id=\"golang面试参考\"><a class=\"anchor\" href=\"#golang面试参考\">#</a> Golang 面试参考</h4><ul><li><span class=\"exturl\" data-url=\"aHR0cDovL21vcnNtYWNoaW5lLmRrL2dvLXNjaGVkdWxlcg==\">Golang 调度</span></li><li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kcmF2ZW5lc3MubWUvZ29sYW5nLw==\">Go 语言设计与实现</span></li></ul>",
            "tags": [
                "计算机科学",
                "Golang",
                "Golang"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/golang/golangGC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6/",
            "url": "http://oreki.world/computer-science/golang/golangGC%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6/",
            "title": "golangGC触发机制",
            "date_published": "2022-03-16T13:50:23.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"gc触发场景\"><a class=\"anchor\" href=\"#gc触发场景\">#</a> GC 触发场景</h3><ol><li>手动触发：开发者在业务代码中自行调用 runtime.GC 方法来触发 GC 行为。</li><li>系统触发：运行时自行根据内置的条件，检查、发现到，则进行 GC 处理，维护整个应用程序的可用性。</li></ol><h3 id=\"系统触发\"><a class=\"anchor\" href=\"#系统触发\">#</a> 系统触发</h3><p>Go 源码的 src/runtime/mgc.go 文件，明确标识了 GC 系统触发的三种场景，分别如下：</p><pre><code class=\"language-Go\">const ( \n     gcTriggerHeap gcTriggerKind = iota \n     gcTriggerTime \n     gcTriggerCycle \n) \n</code></pre><ol><li>gcTriggerHeap：当所分配的堆大小达到阈值 (由控制器计算的触发堆的大小) 时，将会触发。</li><li>gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。- 时间周期以 runtime.forcegcperiod 变量为准，默认 2 分钟。</li><li>gcTriggerCycle：如果没有开启 GC，则启动 GC。</li></ol><h3 id=\"gc管理手段\"><a class=\"anchor\" href=\"#gc管理手段\">#</a> GC 管理手段</h3><h4 id=\"引用计数法\"><a class=\"anchor\" href=\"#引用计数法\">#</a> 引用计数法</h4><p>根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。优点：简单直接，回收速度快。缺点：需要额外的空间存放计数，无法处理循环引用的情况；</p><h4 id=\"标记清除法\"><a class=\"anchor\" href=\"#标记清除法\">#</a> 标记清除法</h4><p>标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。优点：简单直接，速度快，适合可回收对象不多的场景。缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配；</p><h4 id=\"三色标记法\"><a class=\"anchor\" href=\"#三色标记法\">#</a> 三色标记法</h4><p>标记过程：</p><ol><li>起初所有的对象都是白色的；</li><li>从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；</li><li>从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；</li><li>重复步骤 3，直到待处理队列为空，此时白色对象即为不可达的 “垃圾”，回收白色对象；</li></ol><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象。<br>根对象包括：</p><ol><li>全局变量；程序在编译期就能确定的那些存在于程序整个生命周期的变量。</li><li>执行栈；每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。</li><li>寄存器；寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</li></ol><p>Go GC 需要 STW 的原因：<br>为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收。</p><p>三色标记最不希望发生的事：</p><ol><li>一个白色对象被黑色对象引用（条件一）</li><li>灰色对象与它之间的可达关系的白色对象遭到破坏（条件二）<br>（两个条件同时满足，对象丢失）</li></ol><p>强弱三色不变式：</p><ol><li>强三色不变式：不许黑色对象引用白色对象（破坏条件一）</li><li>弱三色不变式：黑色可以引用白色，白色对象存在其他灰色对象对他的引用，或者可达它的链路上游存在灰色对象（破坏条件二）</li></ol><h4 id=\"屏障机制\"><a class=\"anchor\" href=\"#屏障机制\">#</a> 屏障机制</h4><ol><li>插入写屏障，主要是黑色对象引入的灰白对象都会变成灰色 满足强三色不变式</li><li>删除写屏障，删除时候如果自身是灰色或者白色的时候就会变成灰色，可以保护灰色到白色的引用不会断 但是会丢失精度，要到下一次 gc 才能回收了</li></ol><h4 id=\"三色标记法混合写屏障机制\"><a class=\"anchor\" href=\"#三色标记法混合写屏障机制\">#</a> 三色标记法 + 混合写屏障机制</h4><p>由于栈空间不好弄钩子也就是不好放入屏障逻辑，所有会有 stw 一次停下来遍历所有栈空间，这个有点致命，所以出现了混合写屏障</p><ol><li>GC 开始将栈上的对象全部扫描并标记为黑色 (之后不再进行第二次重复扫描，无需 STW)，</li><li>GC 期间，任何在栈上创建的新对象，均为黑色。</li><li>被删除的对象标记为灰色。</li><li>被添加的对象标记为灰色</li></ol><p>这样就能全程无 stw 了</p>",
            "tags": [
                "计算机科学",
                "Golang",
                "Golang"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/miscellaneous/RPC/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEprotobuf%E6%B5%81%E7%A8%8B/",
            "url": "http://oreki.world/computer-science/miscellaneous/RPC/windows%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEprotobuf%E6%B5%81%E7%A8%8B/",
            "title": "windows下安装和配置protobuf流程",
            "date_published": "2021-08-09T09:47:26.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": []
        },
        {
            "id": "http://oreki.world/computer-science/golang/%E5%8F%8D%E5%B0%84/",
            "url": "http://oreki.world/computer-science/golang/%E5%8F%8D%E5%B0%84/",
            "title": "反射",
            "date_published": "2021-05-02T08:11:48.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": []
        },
        {
            "id": "http://oreki.world/kaoyan/data-struct/%E7%BA%BF%E6%80%A7%E8%A1%A8/",
            "url": "http://oreki.world/kaoyan/data-struct/%E7%BA%BF%E6%80%A7%E8%A1%A8/",
            "title": "线性表",
            "date_published": "2021-05-02T05:08:23.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": [
                "考研",
                "数据结构"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/python/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/",
            "url": "http://oreki.world/computer-science/python/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/",
            "title": "循环引用问题",
            "date_published": "2021-05-01T10:25:28.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": [
                "计算机科学",
                "Python"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/python/iterator-generator/",
            "url": "http://oreki.world/computer-science/python/iterator-generator/",
            "title": "iterator, generator",
            "date_published": "2021-05-01T10:03:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": []
        },
        {
            "id": "http://oreki.world/computer-science/python/Python-with%E8%AF%AD%E6%B3%95/",
            "url": "http://oreki.world/computer-science/python/Python-with%E8%AF%AD%E6%B3%95/",
            "title": "Python with语法",
            "date_published": "2021-05-01T09:56:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": []
        },
        {
            "id": "http://oreki.world/computer-science/python/Python%E5%85%83%E7%B1%BB/",
            "url": "http://oreki.world/computer-science/python/Python%E5%85%83%E7%B1%BB/",
            "title": "Python元类",
            "date_published": "2021-05-01T09:55:41.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": []
        },
        {
            "id": "http://oreki.world/computer-science/python/Mixin/",
            "url": "http://oreki.world/computer-science/python/Mixin/",
            "title": "Mixin",
            "date_published": "2021-05-01T09:55:27.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p><h3 id=\"mq的组成\"><a class=\"anchor\" href=\"#mq的组成\">#</a> mq 的组成</h3><p>用于接收、分配消息</p><ol><li>生产者 发送消息</li><li>消费者 接收消息</li><li>交换机 接收生产者发送的消息并转发</li></ol><p>用于存储生产者的消息</p><ol><li>消息 message</li><li>队列 queue</li></ol><p>消息推送通道</p><ol><li>信道 channel AMQP</li></ol><h3 id=\"为什么使用mq\"><a class=\"anchor\" href=\"#为什么使用mq\">#</a> 为什么使用 mq</h3><ol><li>异步通信：主流程只需要完成业务的核心功能；对于业务非核心功能，将消息放入到消息队列之中进行异步处理，减少请求的等待，提高系统的总体性能；</li><li>解耦：将业务逻辑和消息队列的处理逻辑分离，消息队列的处理逻辑可以被多个业务逻辑调用，提高系统的可扩展性；</li><li>削峰 / 限流：将所有请求都写到消息队列中，消费服务器按照自身能够处理的请求数从队列中拿到请求，防止请求并发过高将系统搞崩溃；</li></ol><h3 id=\"mq的缺点\"><a class=\"anchor\" href=\"#mq的缺点\">#</a> mq 的缺点</h3><ol><li>系统引用的外部依赖越多，越容易挂掉，如果 MQ 服务器挂掉，那么可能会导致整套系统崩溃。系统的可用性变低。</li><li>系统复杂度提高。</li><li>数据一致性问题，是否有重复消费。</li></ol><h3 id=\"mq有哪些消费模式\"><a class=\"anchor\" href=\"#mq有哪些消费模式\">#</a> mq 有哪些消费模式</h3><ol><li>推模式：注册一个消费者后，RabbitMQ 会在消息可用时，自动将消息进行推送给消费者。这种方式效率最高最及时。</li><li>拉模式：属于一种轮询模型，发送一次 get 请求，获得一个消息。如果此时 RabbitMQ 中没有消息，会获得一个表示空的回复。</li></ol><h3 id=\"exchange交换机类型\"><a class=\"anchor\" href=\"#exchange交换机类型\">#</a> Exchange 交换机类型</h3><ol><li>direct：消息传递给一个指定的队列，如果没有队列，则消息会被丢弃。</li><li>topic：消息传递给一个或多个队列，如果没有队列，则消息会被丢弃。</li><li>fanout：消息传递给一个或多个队列，无论没有队列，消息都会被传递。</li></ol>",
            "tags": []
        },
        {
            "id": "http://oreki.world/computer-science/python/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "url": "http://oreki.world/computer-science/python/%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/",
            "title": "装饰器的使用",
            "date_published": "2021-05-01T09:54:52.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p><a id=\"more\"></a></p>",
            "tags": [
                "计算机科学",
                "Python"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/golang/make%20&%20new/",
            "url": "http://oreki.world/computer-science/golang/make%20&%20new/",
            "title": "make & new",
            "date_published": "2021-05-01T09:54:17.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><p>new 和 make 都可以用来<strong>分配空间</strong>，初始化类型，但是它们确有不同。</p><h2 id=\"new\"><a class=\"anchor\" href=\"#new\">#</a> new</h2><p>new (T) 返回的是 T 的指针</p><p>new (int) 将分配的空间初始化为 int 的零值，也就是 0，并返回 int 的指针，这和直接声明指针并初始化的效果是相同的</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>p <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token comment\">// (*int)0xc000012088</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 0</span></pre></td></tr></table></figure><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">var</span> p <span class=\"token operator\">*</span><span class=\"token builtin\">int</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>i</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token comment\">// (*int)0xc000012088</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 0</span></pre></td></tr></table></figure><h2 id=\"make\"><a class=\"anchor\" href=\"#make\">#</a> make</h2><p>make 只能用于 slice，map，channel 三种类型，make (T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。</p><figure class=\"highlight go\"><figcaption data-lang=\"go\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>s <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token comment\">// [0, 0, 0]</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\tm <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%v\"</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span> <span class=\"token comment\">//map[]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\tc <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token comment\">//0xc000086060</span></pre></td></tr></table></figure><h2 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h2><p><code>make(T, args)</code> 函数的目的与 <code>new(T)</code> 不同。它仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是 T*）的一个初始化的（不是零值）的实例。</p><p>平时开发中，make 一般用来初始化 map、channel、切片。new 用来初始化对象或者 struct 返回它的指针。</p>",
            "tags": [
                "计算机科学",
                "Golang"
            ]
        },
        {
            "id": "http://oreki.world/kaoyan/internet/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "url": "http://oreki.world/kaoyan/internet/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "title": "408计算机网络-数据链路层",
            "date_published": "2021-04-15T15:30:38.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"功能\"><a class=\"anchor\" href=\"#功能\">#</a> 功能</h2><h3 id=\"数据链路层基本概念\"><a class=\"anchor\" href=\"#数据链路层基本概念\">#</a> 数据链路层基本概念</h3><p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p><p>结点：主机、路由器 &lt;br&gt;<br>链路：网络中两个结点之间的<strong>物理通道</strong>。链路的传输介质主要有双绞线、光纤和微波。分为有限链路和无线链路。&lt;br&gt;<br>数据链路：网络中两个结点之间的<strong>逻辑通道</strong>。把实现控制协议的硬件和软件加到链路上就构成数据链路。&lt;br&gt;<br>帧：链路层的协议数据单元。&lt;br&gt;</p><p>数据链路层在物理层提供服务的基础上<span class=\"red\">向网络层提供服务</span>。其最基本的服务是将源自网络层来的数据可靠的传输到相邻节点的目标机网络层。其主要作用是 &lt;font color=&quot;red&quot;&gt;[加强物理层传输原始比特流的功能]&lt;/font&gt;，将物理层提供的可能出错的物理连接改造成 &lt; font color=&quot;red&quot;&gt;[逻辑上无差错的数据链路]&lt;/font&gt;，使之对网络层表现为一条无差错的链路。*</p><p>功能一：为网络层提供服务。无确认无连接服务。有确认无连接服务。有确认面向连接服务。&lt;br&gt;<br>功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）。&lt;br&gt;<br>功能二：组帧。&lt;br&gt;<br>功能四：流量控制。&lt;br&gt;<br>功能五：差错控制。（帧错 / 位错）。</p><h3 id=\"封装成帧透明传输\"><a class=\"anchor\" href=\"#封装成帧透明传输\">#</a> 封装成帧 &amp; 透明传输</h3><h4 id=\"封装成帧\"><a class=\"anchor\" href=\"#封装成帧\">#</a> 封装成帧</h4><p>封装成帧就是在一段数据的首部和尾部添加一段数据，这段数据被称为帧定界符。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p><h4 id=\"透明传输\"><a class=\"anchor\" href=\"#透明传输\">#</a> 透明传输</h4><p>透明传输是指不管所传数据是什么样的比特组合，都应当能在链路上传送。</p><h4 id=\"组帧的四种方法\"><a class=\"anchor\" href=\"#组帧的四种方法\">#</a> 组帧的四种方法</h4><ol><li>字符计数法：帧首部使用一个记数字段（第一个字节，八位）来标明帧内字符数。</li><li>字符填充法：即在数据中心添加转义字符，防止内容中二进制字符与帧首部和尾部字符冲突。<ol><li>当传送的帧是文本文件时（文本文件的字符都是键盘上输入的，都是 ASCII 码）。不管从键盘上输入什么字符都可以放进帧内传送过去。（透明传输）</li><li>当传送的帧是由非 ASCII 码得文本文件组成时（二进制代码的程序或者图像）就要采用字符填充方法实现透明传输。</li></ol></li><li>零比特填充法：在发送端，扫描整个信息字段，<strong>只要有连续 5 个 1，就立即填入 1 个 0</strong>. 在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。<strong>发现连续 5 个 1 时，就把后面的 0 删除</strong>。</li><li>违规编码法：参考曼彻斯特编码，与它不同的是，违规编码法用高 - 高，低 - 低来定界帧的起始和结束。</li></ol><p>由于字节计数法中 Count 字段的脆弱性及字符填充法的复杂性和不兼容性。目前普遍使用的是<strong>零比特填充法</strong>和<strong>违规编码法</strong>。</p><h3 id=\"差错控制\"><a class=\"anchor\" href=\"#差错控制\">#</a> 差错控制</h3><h4 id=\"差错从何而来\"><a class=\"anchor\" href=\"#差错从何而来\">#</a> 差错从何而来</h4><ol><li>（全局性）由于线路本身电气特性所产生的<strong>随机噪声</strong> (热噪声)，是信道固有的，随机存在的。解决方法：提高信噪比来减少和避免干扰。(对传感器下手)</li><li>（局部性）外界特定的短暂原因所造成的的<strong>冲击噪声</strong>，是产生差错的原因。解决办法：通常利用编码技术来解决。</li></ol><h4 id=\"差错\"><a class=\"anchor\" href=\"#差错\">#</a> 差错</h4><ol><li>位错 -- 比特位出错，1 变 0,0 变 1.</li><li>帧错<ol><li>丢失</li><li>重复</li><li>失序</li></ol></li></ol><h4 id=\"差错控制-2\"><a class=\"anchor\" href=\"#差错控制-2\">#</a> 差错控制</h4><ol><li>检错编码<ol><li>奇偶校验码<ol><li>奇校验码：在 n-1 位的信息元之前加上一位的校验元，使 1 的个数为奇数</li></ol></li><li>循环冗余码 CRC：冗余码的生成以及接收端 CRC 检验都是硬件实现，处理很迅速，因此不会延误数据的传输。</li></ol></li><li>纠错编码<ol><li>海明码<ol><li>海明距离：两个合法编码的对应比特取值不同的比特数称为这两个码字的<strong>海明距离 (码距)</strong></li><li>一个有效编码集中，任意<strong>两个合法编码 (码字) 的海明距离的最小值</strong>称为该编码集的海明距离 (码距)</li><li>海明码纠错 d 位，需要码距为 2d+1 的编码方案；检错 d 位，只需要码距为 d+1。</li></ol></li></ol></li></ol><p>凡是接收端数据链路层接受的帧，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错。</p><p>可靠传输：数据链路层发送端发什么，接收端就收到什么<br>链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。</p><h3 id=\"数据链路层的流量控制\"><a class=\"anchor\" href=\"#数据链路层的流量控制\">#</a> 数据链路层的流量控制</h3><p><strong>较高的发送速度</strong>和<strong>较低的接受能力</strong>的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p>数据链路层的流量控制是<strong>点对点的</strong>，而传输层的流量控制是<strong>端到端的</strong>。</p><p>数据链路的流量控制手段：接收方收不下就不回复确认。</p><p>传输层流量控制手段：接收端给发送端一个窗口公告。</p><h3 id=\"流量控制方法\"><a class=\"anchor\" href=\"#流量控制方法\">#</a> 流量控制方法</h3><ol><li>停止等待协议 (特殊滑动窗口协议): 每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</li><li>滑动窗口协议<ol><li>后退 N 帧协议 (GBN)</li><li>选择重传协议 (SR)</li></ol></li></ol><p>停止 - 等待协议 ---&gt; 发送窗口大小 = 1，接受窗口大小 = 1<br>后退 N 帧协议 (GBN)---&gt; 发送窗口大小 &gt; 1, 接受窗口大小 = 1<br>选择重传协议 (SR)---&gt; 发送窗口大小 &gt; 1, 接受窗口大小 &gt; 1</p><p>可靠传输：发送端发啥，接收端接啥<br>流量控制：控制发送速率，使接收方由足够的缓冲空间来接受每一个帧</p><p>滑动窗口解决</p><ol><li>流量控制 (收不下就不给确认，想发也不发不了)</li><li>可靠传输 (发送方自动重传)</li></ol><h3 id=\"停止-等待协议\"><a class=\"anchor\" href=\"#停止-等待协议\">#</a> 停止 - 等待协议</h3><p>特点:</p><ol><li>简单</li><li>信道利用率太低<ol><li>信道利用率：发送方在一个发送周期内，有效地发送数据所需要的时间占整个发送周期的比率。</li><li>信道利用率 =(L/C)/T。</li><li>T: 发送周期，从开始发送数据，到收到第一个确认帧为止</li><li>L：T 内发送 L 比特数据</li><li>C：发送方数据传速率</li></ol></li></ol><p>信道吞吐率 = 信道利用率 * 发送方发送速率</p><h3 id=\"后退n帧协议\"><a class=\"anchor\" href=\"#后退n帧协议\">#</a> 后退 N 帧协议</h3><p>发送窗口：发送方维持一组持续的允许发送的帧的序号<br>接受窗口：接收方维持一组连续的允许接受帧的序号</p><p>GBN 发送方必须响应的三件事</p><ol><li>上层的调用</li><li>收到一个 ack: GBN 协议中，对 n 号帧的确认采用 **&lt;font color=&quot;red&quot;&gt;[累计确认]**&lt;/font &gt; 的方式，标明接收方已经收到 N 号帧和他之前的全部帧</li><li>超时事件</li></ol><p>GBN 接收方需要做的事</p><ol><li>如果正确收到 N 号帧，并且按序，那么接收方为 n 帧发送一个 ACK，并且将该帧中的数据部分交付给上层</li><li>其余情况都丢弃帧，并为最近按序接受的帧重新发送 ack。接收方无需缓存任何失序帧，只需维护一个信息：expectedseqnum（下一个按序接收的帧序号）</li></ol><h4 id=\"滑动窗口长度\"><a class=\"anchor\" href=\"#滑动窗口长度\">#</a> 滑动窗口长度</h4><p>若采用 n 个比特对帧编号，那么发送窗口的尺寸 Wt 应满足 1 《 Wt 《 2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p><h4 id=\"gbn协议重点\"><a class=\"anchor\" href=\"#gbn协议重点\">#</a> GBN 协议重点</h4><ol><li>累积确认 (偶尔捎带确认)</li><li>接收方只按顺序接受帧，不按序无情丢弃</li><li>确认序列号最大、按序到达的帧</li><li>发送窗口最大为 2^n-1， 接收窗口大小为 1</li></ol><h4 id=\"gbn协议性能分析\"><a class=\"anchor\" href=\"#gbn协议性能分析\">#</a> GBN 协议性能分析</h4><ol><li>因连续发送数据帧而提高了信道利用率</li><li>在重传时必须把原来已经正确传送的数据帧重传，使传送效率降低</li></ol><h3 id=\"选择重传协议\"><a class=\"anchor\" href=\"#选择重传协议\">#</a> 选择重传协议</h3><h4 id=\"sr协议重点\"><a class=\"anchor\" href=\"#sr协议重点\">#</a> SR 协议重点</h4><ol><li>对数据帧逐一确认，收一个确认一个</li><li>只重传出错帧</li><li>接收方有缓存</li><li>最大发送窗口和接收窗口为 2^(n-1)</li></ol><h3 id=\"信道划分介质访问控制\"><a class=\"anchor\" href=\"#信道划分介质访问控制\">#</a> 信道划分介质访问控制</h3><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的<strong>通信隔离开</strong>，把 **&lt;font color=&quot;red&quot;&gt;[时域和频域资源]&lt;/font&gt;** 合理地分配给网络上的设备。</p><p>多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或者终端设备 **&lt;font color=&quot;red&quot;&gt;[共享信道资源]&lt;/font&gt;**，提高信道利用率。</p><p>共享信道：把一条广播信道，逻辑上分成几条用于两个节点之间通信的互不干扰的子信道，<strong>&lt;font color=&quot;red&quot;&gt;[实际上就是把广播信道转变为点对点信道]。&lt;/font&gt;</strong></p><p>传输数据使用的两种链路</p><ol><li>点对点链路：<ol><li>两个相邻节点通过一个链路相连，没有第三者。</li><li>应用：PPP 协议，常用于广域网</li></ol></li><li>广播室链路<ol><li>所有主机共享通信介质</li><li>应用：早起的总线以太网、无线局域网，常用于局域网</li><li>典型拓扑结构：总线型、星型 (逻辑总线型)</li></ol></li></ol><h4 id=\"介质访问控制\"><a class=\"anchor\" href=\"#介质访问控制\">#</a> 介质访问控制</h4><p>采用一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。</p><ol><li>静态划分信道<ol><li>频分多路复用 FDM</li><li>时分多路复用 TDM</li><li>波分多路复用 WDM</li><li>码分多路复用 CDM</li></ol></li><li>动态分配信道<ol><li>轮询访问介质访问控制<ol><li>令牌传递协议</li></ol></li><li>随机访问介质访问控制<ol><li>ALOHA 协议</li><li>CSMA 协议</li><li>CSMA/CD 协议</li><li>CSMA/CA 协议</li></ol></li></ol></li></ol><p><strong>信道划分介质访问控制 (MAC) 协议</strong>：</p><ol><li>基于多路复用技术划分资源。</li><li>网络负载重：共享信道效率高，且公平。</li><li>网络负载轻：共享信道效率低。</li></ol><p><strong>随机访问 MAC 协议 (冲突)</strong>:</p><ol><li>用户根据意愿<strong>随机</strong>发送消息，发送消息时可独占信道带宽。</li><li>网络负载重：产生冲突开销。</li><li>网络负载轻：共享信道效率高，单个结点可利用信道全部带宽。</li></ol><p><strong>轮询访问 MAC 协议 / 轮流协议 / 轮转访问 MAC 协议</strong>：</p><ol><li>既要<strong>不产生冲突</strong>，又要发送时<strong>占全部带宽</strong>。</li></ol><h4 id=\"频分多路复用fdm\"><a class=\"anchor\" href=\"#频分多路复用fdm\">#</a> 频分多路复用 FDM</h4><ol><li>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽 (频率带宽) 资源</strong>。</li><li>充分利用传输介质带宽，系统<strong>效率较高</strong>：由于技术比较成熟，实现也比较<strong>容易</strong>。</li></ol><h4 id=\"时分多路复用tdm\"><a class=\"anchor\" href=\"#时分多路复用tdm\">#</a> 时分多路复用 TDM</h4><ol><li>将时间划分为一段段等长的时分复用帧 (<strong>TDM 帧</strong>)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙，所有用户轮流占用信道。</li><li><strong>&lt;font color=&quot;red&quot;&gt;[TDM 帧是在物理层传送的比特流所划分的帧，标志一个周期]&lt;/font&gt;</strong>。</li></ol><p>时分多路复用 -- 并发<br>频分多路复用 -- 并行</p><h4 id=\"改进的时分复用-统计时分复用stdm\"><a class=\"anchor\" href=\"#改进的时分复用-统计时分复用stdm\">#</a> 改进的时分复用 -- 统计时分复用 STDM</h4><h4 id=\"波分多路复用wdm\"><a class=\"anchor\" href=\"#波分多路复用wdm\">#</a> 波分多路复用 WDM</h4><p>波分多路复用就是 **&lt;font color=&quot;red&quot;&gt;[光的频分多路复用]&lt;/font&gt;**</p><h4 id=\"码分多路复用cdm\"><a class=\"anchor\" href=\"#码分多路复用cdm\">#</a> 码分多路复用 CDM</h4><p>码分多址 (CDMA) 是码分复用的一种方式</p><h4 id=\"aloha协议-font-colorred不听就说font\"><a class=\"anchor\" href=\"#aloha协议-font-colorred不听就说font\">#</a> ALOHA 协议 ---<strong>&lt;font color=&quot;red&quot;&gt; 不听就说 &lt;/font&gt;</strong></h4><p>纯 ALOHA 协议：不监听信道、不按时间槽发送，随机重发。(想发就发)</p><p>时隙 ALOHA 协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。(控制想发就发的随意性)</p><ol><li>纯 ALOHA 协议比时隙 ALOHA 吞吐量更低，效率更低</li><li>纯 ALOHA 协议想发就发，时隙 ALOHA 只有在时间片段开始时才能发。</li></ol><h4 id=\"csma协议载波监听多路访问协议-font-colorred先听再说font\"><a class=\"anchor\" href=\"#csma协议载波监听多路访问协议-font-colorred先听再说font\">#</a> CSMA 协议 (载波监听多路访问协议)---<strong>&lt;font color=&quot;red&quot;&gt; 先听再说 &lt;/font&gt;</strong></h4><ol><li>CS: 载波监听 / 监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。</li><li>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li>协议思想：发送帧之前，<strong>监听</strong>信道。</li><li>如何监听：当几个站同时在总线上发数据时，总线上的信号<strong>电压摆动值</strong>会增大。当一个站检测到的信号电压摆动值超过一定门限时，就认为总线上至少有两个站同时在发送数据，表面产生了碰撞，即发生了冲突。</li><li>监听结果：<ol><li>信道空闲：发送完整帧</li><li>信道忙：推迟发送</li></ol></li></ol><h5 id=\"1-坚持csma\"><a class=\"anchor\" href=\"#1-坚持csma\">#</a> 1 - 坚持 CSMA</h5><p>坚持指的是对于监听信道忙之后的坚持。</p><p>1 - 坚持 CSMA 思想：如果一个主机要发送消息，那么它先监听信道。</p><ol><li>空闲则直接传输，不必等待</li><li>忙则一直监听，直到空闲马上传输</li><li>如果有冲突 (一段时间内未收到肯定回复)，则等待一个随机长的时间再监听，重复上述过程。<br>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。&lt;br&gt;<br>缺点：如果有两个或者两个以上的站点有数据要发送，冲突就不可避免。</li></ol><h5 id=\"非坚持csma\"><a class=\"anchor\" href=\"#非坚持csma\">#</a> 非坚持 CSMA</h5><p>非坚持指的是对于监听信道忙之后就不继续监听。</p><p>非坚持 CSMA 思想：如果一个主机要发送消息，那么它先监听信道。</p><ol><li>空闲则直接传输，不必等待</li><li>忙则等待一个随机的时间之后再进行监听<br>优点：采用随机的重发延迟时间可以减少冲突发送的可能。&lt;br&gt;<br>缺点：可能存在大家都在延迟等待的过程中，使得媒体仍可能处于空闲状态，媒体使用率降低。</li></ol><h5 id=\"p-坚持csma\"><a class=\"anchor\" href=\"#p-坚持csma\">#</a> p - 坚持 CSMA</h5><p>p - 坚持指的是对于监听信道空闲的处理</p><p>p - 坚持 CSMA 思想：</p><ol><li>如果一个主机要发送消息，那么它先监听信道</li><li>空闲则以 p 概率直接传输，不必等待；概率 1-p 等待到下一个时间槽再传输。</li><li>忙则持续监听直到信道空闲在以 p 概率发送。</li><li>若冲突则等到下一个时间槽开始再监听并重复上述过程。<br>优点：既能像非坚持算法那样减少冲突，又能像 1 - 坚持算法那样减少媒体空闲时间的这种方案。&lt;br&gt;<br>缺点：发送冲突后还是要坚持把数据帧发送完，造成了浪费。</li></ol><h4 id=\"csmacd协议载波监听多点接入碰撞检测协议-font-colorred先听再说边听边说font\"><a class=\"anchor\" href=\"#csmacd协议载波监听多点接入碰撞检测协议-font-colorred先听再说边听边说font\">#</a> CSMA/CD 协议 (载波监听多点接入 / 碰撞检测协议)---<strong>&lt;font color=&quot;red&quot;&gt; 先听再说，边听边说 &lt;/font&gt;</strong></h4><ol><li>CS: 载波监听 / 监听，每一个站在<strong>发送数据之前</strong>及<strong>发送数据时</strong>要检测一下总线上是否有其他计算机在发送数据。</li><li>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。</li><li>CD：碰撞检测 (冲突检测)，&quot;<strong>&lt;font color=&quot;red&quot;&gt;[边发送边监听]</strong>&lt;/font&gt;&quot;, 适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</li></ol><h5 id=\"先听后发为什么还会冲突\"><a class=\"anchor\" href=\"#先听后发为什么还会冲突\">#</a> 先听后发为什么还会冲突？</h5><p>因为电磁波在总线上总是以有限的速率传播。</p><h5 id=\"如何确定碰撞后的重传时机\"><a class=\"anchor\" href=\"#如何确定碰撞后的重传时机\">#</a> 如何确定碰撞后的重传时机</h5><p><strong>截断二进制指数规避算法</strong></p><ol><li>确定基本推迟时间为争用期 2τ</li><li>定义参数 k，它等于重传次数，但 k 不超过 10，即 k=min [重传次数，10]。当重传次数不超过 10 次时，k 等于重传次数；当重传次数大于 10 时，k 就不在增大而一直等于 10。</li><li>从离散的整数集合 [0,1,,2^k-1] 中随机抽取一个数 r，重传所需退避时间就是 r 倍的基本退避时间，即 2rτ。</li><li>当重传达 &lt;font color=&quot;red&quot;&gt;<strong>[16 次]</strong>&lt;/font&gt; 仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。</li></ol><p>若连续多次产生冲突，就标明可能有 &lt;font color=&quot;red&quot;&gt;<strong>[较多的站参与争用]</strong>&lt;/font&gt; 信道。使用此算法可使重传需要推迟的平均时间随重传次数的增大而增大，因而减小发送碰撞的概率，有利于整个系统的稳定。</p><h5 id=\"最小帧长\"><a class=\"anchor\" href=\"#最小帧长\">#</a> 最小帧长</h5><p>帧的传输时延至少要两倍于信号在总线中的传播时延</p><p>最小帧长 = 总线传播时延 * 数据传输速率 * 2 = 2τ * 数据传输速率</p><p><strong>以太网规定最短帧长为 64B，凡是长度小于 64B 的都是由于冲突而异常终止的无效帧。</strong></p><h4 id=\"csmaca协议载波监听多点接入碰撞避免协议-font-colorred先听再说font\"><a class=\"anchor\" href=\"#csmaca协议载波监听多点接入碰撞避免协议-font-colorred先听再说font\">#</a> CSMA/CA 协议 (载波监听多点接入 / 碰撞避免协议)---<strong>&lt;font color=&quot;red&quot;&gt; 先听再说 &lt;/font&gt;</strong></h4><ol><li>发送数据前，先检测信道是否空闲。</li><li>空闲则发出<strong> RTS</strong>，RTS 包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</li><li>接收端收到 RTS 后，则响应<strong> CTS</strong></li><li>发送端收到 CTS 后，开始发送数据帧 (同时预约信道：发送方告知其他站点自己要传多久数据)</li><li>接收端收到数据帧后，将用 CRC 来检验数据是否正确，正确则响应 ACK 帧。</li><li>发送方收到 ACK 就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止 (采用二进制指数退避算法来确定随机的推迟时间)。</li></ol><h4 id=\"csmacd与csmaca\"><a class=\"anchor\" href=\"#csmacd与csmaca\">#</a> CSMA/CD 与 CSMA/CA</h4><p>相同点：</p><ol><li>CSMA/CD 与 CSMA/CA 机制都从属于 CSMA 的思路，其核心是 **&lt;font color=&quot;red&quot;&gt;[先听后说]&lt;/font&gt;**。换言之，两个在接入信道之前都须要进行监听。当发现信道空闲后，才能进行接入。<br>不同点：</li><li>传输介质不同: CSMA/CD 用于总线式以太网 (有线)，而 CSMA/CA 用于无线局域网 (无线)。</li><li>载波检测方式不同：因传输介质不同，CSMA/CD 与 CSMA/CA 的检测方式不用。CSMA/CD 通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压会随着发生变化；而 CSMA/CA 采用能量检测 (ED)、载波检测 (CS) 和能量载波混合检测三种检测信道空闲的方式。</li><li>CSMA/CD 检测冲突，CSMA/CA 避免冲突，二者出现冲突后都会进行<strong>有上限的重传</strong>。</li></ol><h4 id=\"轮询协议\"><a class=\"anchor\" href=\"#轮询协议\">#</a> 轮询协议</h4><p>主节点轮流<strong>邀请</strong>从属节点发送数据。</p><h4 id=\"令牌传递协议\"><a class=\"anchor\" href=\"#令牌传递协议\">#</a> 令牌传递协议</h4><ol><li>令牌：一个特殊格式的<strong> MAC</strong> 控制帧，不含任何信息。控制信道的使用，确保同一时刻只有一个结点独占信道。</li><li>每个节点都可以在一定的时间内 (令牌持有时间) 获得发送数据的权利，并不是无限制地持有令牌。</li><li>应用于令牌环网 (<strong>物理星型拓扑、逻辑环型拓扑</strong>)。</li><li>令牌传送方式的网络常用于<strong>负载较重、通信量较大</strong>的网络中。</li></ol><h3 id=\"局域网\"><a class=\"anchor\" href=\"#局域网\">#</a> 局域网</h3><p>在<strong>某一区域内</strong>由多台计算机互连组成的计算机组，使用<strong>广播信道</strong></p><h4 id=\"局域网介质访问控制方法\"><a class=\"anchor\" href=\"#局域网介质访问控制方法\">#</a> 局域网介质访问控制方法</h4><ol><li>CSMA/CD 常用于<strong>总线型局域网</strong>，也用于树形网络</li><li>令牌总线，常用于<strong>总线型局域网</strong>，也用于树形网络</li><li>令牌环， 用于<strong>环型局域网</strong>，比如令牌环网</li></ol><h4 id=\"局域网的分类\"><a class=\"anchor\" href=\"#局域网的分类\">#</a> 局域网的分类</h4><ol><li>以太网 (IEEE802.3)</li><li>令牌环网 (IEEE802.5)</li><li>FDDI 网 (IEEE802.8)</li><li>ATM 网</li><li>无线局域网 (IEEE802.11)</li></ol><h4 id=\"mac子层和llc子层\"><a class=\"anchor\" href=\"#mac子层和llc子层\">#</a> MAC 子层和 LLC 子层</h4><p>IEEE802 标准所描述的局域网参考模型只对应 OSI 参考模型的<strong>数据链路层与物理层</strong>，它将数据链路层划分为<strong>逻辑链路层 LLC 子层</strong>和<strong>介质访问控制 MAC 子层</strong>。</p><ol><li>LLC 负责识别网络层协议，然后对他们进行封装。</li><li>MAC 子层的主要功能包括<strong>数据帧的封装 / 卸装</strong>，<strong>帧的寻址和识别</strong>，<strong>帧的接受与发送</strong>，链路的管理，帧的差错控制等。MAC 子层的存在屏蔽了不同物理链路种类的差异性。</li></ol><h4 id=\"以太网\"><a class=\"anchor\" href=\"#以太网\">#</a> 以太网</h4><p>指由 Xerox 公司创建并由 Xerox、Intel 和 DEC 公司联合开发的 &lt;font color=&quot;red&quot;&gt;<strong> 基带总线局域网规范</strong> &lt;/font&gt;，是当今现有局域网采用的最通用的通信协议标准。以太网络使用<strong> CSMA/CD</strong> 技术。</p><ol><li>造价低廉</li><li>是应用最广泛的局域网技术</li><li>比令牌环网、ATM 网便宜、简单</li><li>满足网络速率要求：10Mb/s-10Gb/s</li></ol><p>以太网标准：</p><ol><li>DIX Ethernet V2: 第一个局域网产品 (以太网) 规约。</li><li>IEEE802.3：IEEE802 委员会 802.3 工作组制定的第一个 IEEE 的以太网标准。(帧格式有一丢丢改动)</li></ol><h5 id=\"以太网提供无连接-不可靠的服务\"><a class=\"anchor\" href=\"#以太网提供无连接-不可靠的服务\">#</a> 以太网提供无连接、不可靠的服务</h5><ol><li>无连接：发送方和接收方之间无<strong>握手过程</strong></li><li>不可靠：不对发送方的数据帧<strong>编号</strong>，接收方不向发送方进行<strong>确认</strong>，差错帧直接丢弃，差错纠正由高层负责。</li></ol><p>&lt;font color=&quot;red&quot;&gt;<strong> 以太网只实现无差错接收，不实现可靠传输。</strong>&lt;/font&gt;</p><h5 id=\"以太网传输介质与拓扑结构的发展\"><a class=\"anchor\" href=\"#以太网传输介质与拓扑结构的发展\">#</a> 以太网传输介质与拓扑结构的发展</h5><p>以太网拓扑：逻辑上总线型，物理上星型。</p><h5 id=\"10bast-t以太网\"><a class=\"anchor\" href=\"#10bast-t以太网\">#</a> 10BAST-T 以太网</h5><ol><li>10BAST-T 是传送<strong>基带信号</strong>的双绞线以太网，T 表示采用双绞线，现 10BAST-T 采用的是<strong>无屏蔽双绞线</strong> (UTP), 传输速率是<strong> 10Mb</strong>/s。</li><li>物理上采用星型拓扑，逻辑上总线型拓扑，每段双绞线最长为 100M。</li><li>采用曼彻斯特编码。</li><li>采用 CSMA/CD 介质访问控制。</li></ol><h5 id=\"高速以太网\"><a class=\"anchor\" href=\"#高速以太网\">#</a> 高速以太网</h5><p>速度<strong>大于 100Mb/s</strong> 的以太网称为高速以太网。</p><ol><li><p>100BAST-T 以太网:</p><ol><li>在<strong>双绞线</strong>上传送<strong> 100Mb/s 基带信号</strong>的<strong>星型</strong>拓扑以太网，仍使用 IEEE802.3 的 CSMA/CD 协议。</li><li>支持全双工和半双工，可在全双工方式下工作而无冲突。</li></ol></li><li><p>吉比特以太网</p><ol><li>在<strong>光纤或者双绞线</strong>上传送<strong> 1Gb/s 信号</strong></li><li>支持全双工和半双工，可在全双工方式下工作而无冲突</li></ol></li><li><p>10 吉比特</p><ol><li>10 吉比特以太网在<strong>光纤</strong>上传送<strong> 10Gb/s 信号</strong>。</li></ol></li></ol><h5 id=\"以太网mac帧\"><a class=\"anchor\" href=\"#以太网mac帧\">#</a> 以太网 MAC 帧</h5><p>最常用的 MAC 帧是<strong>以太网 V2</strong> 的格式。</p><p>以太网 V2 与 IEEE802.3 的区别：</p><ol><li>第三个字段是长度 / 类型</li><li>当长度 / 类型字段值小于 0x600 时，数据字段必须装入 LLC 子层。</li></ol><h4 id=\"适配器和mac地址\"><a class=\"anchor\" href=\"#适配器和mac地址\">#</a> 适配器和 MAC 地址</h4><ol><li>计算机与外界有局域网的连接是通过<strong>通信适配器</strong>的。</li><li>在局域网中，硬件地址又称为物理地址，或<strong> MAC 地址</strong>（实际上是标识符）。</li><li>MAC 地址：每个适配器有一个全球唯一的 48 位二进制地址，前 24 位代表厂家 (由 IEEE 规定)，后 24 位厂家自己指定。常用 6 个十六进制数表示。</li></ol><h4 id=\"ieee-80211\"><a class=\"anchor\" href=\"#ieee-80211\">#</a> IEEE 802.11</h4><p>IEEE 802.11 是<strong>无线局域网</strong>通用的标准，它是由 IEEE 所定义的无线网络通信的标准。</p><h3 id=\"广域网\"><a class=\"anchor\" href=\"#广域网\">#</a> 广域网</h3><p>使用<strong>分组交换技术</strong>。</p><h4 id=\"ppp协议\"><a class=\"anchor\" href=\"#ppp协议\">#</a> PPP 协议</h4><p>点对点协议，目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都用 PPP 协议。</p><ol><li>font color=&quot;red&quot;&gt;<strong> 只支持全双工链路。</strong>&lt;/font&gt;</li></ol><p>ppp 协议应满足的要求：</p><ol><li>简单：对于链路层的帧，无需纠错，无需序号，无需流量控制</li><li>封装成帧</li><li>透明传输</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ol><p>PPP 协议无需满足的要求：</p><ol><li>纠错</li><li>流量控制</li><li>序号</li><li>不支持多点线路</li></ol><p>PPP 协议组成部分</p><ol><li>一个将 IP 数据报封装到串行链路 (同步串行 / 异步串行) 的方法</li><li>链路控制协议 LCP：建立并维护数据链路连接。(<strong>身份验证</strong>)</li><li>网络控制协议 NCP：PPP 可支持多种网络层协议，每个不同的网络层协议都要一个相应地 NCP 来配置，为网络层协议建立和配置逻辑连接。</li></ol><h4 id=\"hdlc协议\"><a class=\"anchor\" href=\"#hdlc协议\">#</a> HDLC 协议</h4><p>高级数据链路控制协议，是一个在同步网上传输数据、<strong>面向比特</strong>的数据链路层协议。</p><ol><li>&lt;font color=&quot;red&quot;&gt;<strong> 采用全双工通信。</strong>&lt;/font&gt;</li><li>所有帧采用<strong> CRC 检验</strong>，对信息帧进行顺序<strong>编号</strong>，可防止漏收或重份，传输可靠性高。</li></ol><h5 id=\"hdlc的站\"><a class=\"anchor\" href=\"#hdlc的站\">#</a> HDLC 的站</h5><ol><li>主站</li><li>从站</li><li>复合站</li></ol><p>三种数据操作方式</p><ol><li>正常响应方式</li><li>异步平衡方式</li><li>异步响应方式</li></ol><p>HDLC 帧的类型：</p><ol><li>信息帧，用来传输数据信息</li><li>监督帧，用来流量控制盒差错控制</li><li>无编号帧，用来提供对链路的建立、拆除等多种控制功能。</li></ol><h4 id=\"ppp协议和hdlc协议\"><a class=\"anchor\" href=\"#ppp协议和hdlc协议\">#</a> PPP 协议和 HDLC 协议</h4><p>相同点：</p><ol><li>只支持全双工链路</li><li>都可以实现透明传输</li><li>都可以实现差错检测，但不纠正差错</li></ol><p>不同点：</p><ol><li>PPP 协议面向字节，HDLC 面向比特</li><li>PPP 协议不可靠，HDLC 协议可靠</li><li>PPP 协议无序号和确认机制，HDLC 协议有编号和确认机制</li><li>PPP 协议有 2B 的协议字段，HDLC 无</li></ol><h3 id=\"链路层设备\"><a class=\"anchor\" href=\"#链路层设备\">#</a> 链路层设备</h3><h4 id=\"网桥\"><a class=\"anchor\" href=\"#网桥\">#</a> 网桥</h4><p>网桥根据<strong> MAC 帧的目的地址</strong>对帧进行<strong>转发</strong>和<strong>过滤</strong>。</p><p>网桥优点：</p><ol><li>过滤通信量，增大吞吐量</li><li>扩大了物理范围</li><li>提高可靠性</li><li>可互连不同物理层、不同 MAC 子层和不同速率的以太网。</li></ol><h4 id=\"透明网桥源路由网桥\"><a class=\"anchor\" href=\"#透明网桥源路由网桥\">#</a> 透明网桥 &amp; 源路由网桥</h4><ol><li>透明网桥：指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备 -- 自学习。</li><li>源路由网桥：在发送帧时，把详细的最佳路由信息 (路由最少 / 时间最短) 放在帧的首部中。方法：源站以广播方式向欲通信的目的站发送一个<strong>发现帧</strong>。</li></ol><h4 id=\"多接口网桥-以太网交换机\"><a class=\"anchor\" href=\"#多接口网桥-以太网交换机\">#</a> 多接口网桥 -- 以太网交换机</h4><p>独占媒体带宽</p><ol><li><p>直通式交换机</p><ol><li>查完目的地址 (6B) 就立刻转发。</li><li>延迟小，可靠性低，无法支持具有不同速率的端口的交换。</li></ol></li><li><p>存储转发式交换机 (常用)</p><ol><li>将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃。</li><li><strong>延迟大，可靠性高</strong>，可以支持具有不同速率的端口的交换。</li></ol></li></ol><h2 id=\"应用\"><a class=\"anchor\" href=\"#应用\">#</a> 应用</h2>",
            "tags": [
                "考研",
                "计算机网络",
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://oreki.world/kaoyan/system/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "http://oreki.world/kaoyan/system/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "计算机操作系统概述",
            "date_published": "2021-04-12T16:01:14.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"操作系统的概念\"><a class=\"anchor\" href=\"#操作系统的概念\">#</a> 操作系统的概念</h2><ol><li>** 操作系统是系统资源的管理者。** 控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境。它是计算机系统中最基本的系统软件。</li><li><strong>操作系统向上层提供方便易用的服务。</strong></li><li><strong>最接近硬件的一层软件。</strong></li></ol><p>操作系统提供的功能：</p><ol><li>设备管理</li><li>存储器管理</li><li>处理机 (CPU) 管理</li><li>文件管理</li></ol><p>操作系统向上层提供的易用的服务:</p><ol><li>GUI: 图形化用户接口</li><li>命令接口<ol><li>联机命令接口 (交互式命令接口)</li><li>脱机命令接口 (批处理命令接口)</li></ol></li><li>程序接口：可以再程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。有一系列的系统调用组成。</li></ol><h3 id=\"操作系统的功能和目标\"><a class=\"anchor\" href=\"#操作系统的功能和目标\">#</a> 操作系统的功能和目标</h3><p>需要实现<strong>对硬件机器的拓展</strong>。&lt;br&gt;<br>没有任何软件支持的计算机称为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强，使用更方便的机器。&lt;br&gt;<br>通常把覆盖了软件的机器称为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>.</p><p>操作系统对硬件机器的扩展：&lt;br&gt;<br>将 CPU、内存、显示器、键盘灯硬件合理地组合起来，让各种硬件能够相互协调配合，实现更复杂的功能。</p>",
            "tags": [
                "考研",
                "操作系统",
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://oreki.world/kaoyan/computer-composition/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "url": "http://oreki.world/kaoyan/computer-composition/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/",
            "title": "408计算机组成原理-计算机系统概述",
            "date_published": "2021-03-30T15:52:58.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"什么是计算机系统\"><a class=\"anchor\" href=\"#什么是计算机系统\">#</a> 什么是计算机系统</h2><p>计算机系统 = 硬件 + 软件</p><h3 id=\"软件\"><a class=\"anchor\" href=\"#软件\">#</a> 软件</h3><ol><li>系统软件：用来管理整个计算机系统<ol><li>操作系统</li><li>数据库管理系统</li><li>标准程序库</li><li>网络软件</li><li>语言处理程序</li><li>服务程序</li></ol></li><li>应用软件：按任务需要编制的各种程序</li></ol><h2 id=\"11-计算机发展历程\"><a class=\"anchor\" href=\"#11-计算机发展历程\">#</a> 1.1 计算机发展历程</h2><h3 id=\"计算机的四代变化\"><a class=\"anchor\" href=\"#计算机的四代变化\">#</a> 计算机的四代变化</h3><ol><li>1946-1957 电子管时代（语言：机器语言，内存：磁鼓、汞延迟线，外存：穿孔卡片、纸带）</li><li>1958-1964 晶体管时代（语言：面向过程的 FORTRAN，内存：磁芯存储器，外存：磁带，有了操作系统的雏形）</li><li>1965-1971 中小规模集成电路时代（高级语言迅速发展，有了分时操作系统，内存：半导体存储器，外存：磁带、磁盘）</li><li>1972 至今 超大规模集成电路时代（出现了微处理器 (cpu)，微型计算机）</li></ol><h3 id=\"计算机元件的更新换代\"><a class=\"anchor\" href=\"#计算机元件的更新换代\">#</a> 计算机元件的更新换代</h3><ol><li>摩尔定律。当价格不变时，集成电路上的晶体管数目约隔 18 个月便会增加一倍，性能也提升一倍。18 个月后同样的钱买到的 CPU，后者性能是前者的两倍。</li><li>半导体存储器发展。1970 年第一个半导体存储器由仙童半导体公司生产。半导体存储器到现在经历了 11 代发展。</li><li>微处理器。处理器中的 32 位，64 位是指计算机进行一次整数运算所能处理的二进制数据的位数。</li></ol><h3 id=\"计算机的分类和发展方向\"><a class=\"anchor\" href=\"#计算机的分类和发展方向\">#</a> 计算机的分类和发展方向</h3><p>两极分化：<br>一极是微信计算机向更微型化、网络化、高性能、多用途方向发展。&lt;br&gt;<br>另一极是巨型化向更巨型化、超高速、并行处理、智能化方向发展。</p><h3 id=\"冯诺依曼计算机的特点\"><a class=\"anchor\" href=\"#冯诺依曼计算机的特点\">#</a> 冯诺依曼计算机的特点</h3><ol><li>计算机由五大部件组成：运算器、储存器、控制器、输入设备、输出设备</li><li>指令和数据以同等地位存于存储器，并可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令有操作码和地址码组成<br>5 . 指令在存储器内按顺序存放（<strong>存储程序</strong>）.exe 文件执行时先按顺序存放到存储器中，然后存储器一条条执行</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li></ol><p>现代计算机：&lt;font color=&quot;red&quot;&gt;<strong> 以存储器为核心</strong> &lt;/font&gt;。CPU = 运算器 + 控制器。</p><p>在计算机系统中，<strong>软件和硬件在逻辑上是 &lt;font color=&quot;red&quot;&gt; 等效 &lt;/font &gt; 的</strong>。</p><h3 id=\"存储器\"><a class=\"anchor\" href=\"#存储器\">#</a> 存储器</h3><p>计算机的存储部件，用来存放数据和程序</p><p>存储器分为主存储器 (内存) 和辅存储器 (外存)。CPU 能够直接访问主存，辅存的信息比如调入主存，cpu 才能访问。</p><p>主存储器构成：</p><ol><li>存储体：用来存放数据，由一系列存储元件构成，用来存放二进制 0 或 1，数据在存储体内按地址存储。<ol><li>存储单元：每个存储单元存放一串二进制代码</li><li>存储字 (word)：存储单元中二进制代码的组合</li><li>存储字长：存储单元中二进制代码的位数</li><li>即存储二进制的电子元件，每个存储元件可存 1bt</li></ol></li><li>地址寄存器 (MAR) 存放访存地址，用于寻址，其位数对应存储单元的个数，如 MAR 有 10 位，则有 2^10=1024 个单元，为 1k</li><li>数据寄存器 (MDR) 用于暂存从存储体中读或写的信息，其位数代表存储字长。</li></ol><p>MAR 与 MDR 虽然是存储器的一部分，但在现代 CPU 中是存在于 CPU 中，高速缓存 (Cache) 也存在 CPU 中</p><h3 id=\"运算器\"><a class=\"anchor\" href=\"#运算器\">#</a> 运算器</h3><p>用于实现算术运算 (加减乘除)、逻辑运算 (与或非)。</p><p>基本组成</p><ol><li>ACC: 累加器，用来存放操作数，或运算结果</li><li>MQ：乘商寄存器，在乘、除运算时，用来存放操作数和运算结果</li><li>X：通用的操作数寄存器，用来存放操作数。</li><li>ALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算。</li></ol><h3 id=\"控制器\"><a class=\"anchor\" href=\"#控制器\">#</a> 控制器</h3><p>基本组成</p><ol><li>CU：控制单元，分析指令，给出控制信号</li><li>IR：指令寄存器，存放当前执行指令</li><li>PC：程序计数器，存放下一条指令地址，有自动加 1 功能</li></ol><p>完成一条指令：取指令 (PC--&gt;IR)---&gt; 分析指令 (CU)----&gt; 执行 (CU)</p><p><strong>CPU 区分指令和数据的依据: &lt;font color=&quot;red&quot;&gt; 指令周期的不同阶段 &lt;/font&gt;</strong></p><h3 id=\"计算机系统的层次结构\"><a class=\"anchor\" href=\"#计算机系统的层次结构\">#</a> 计算机系统的层次结构</h3><p>虚拟机器 M4 (高级机器语言：用编译程序翻译成汇编语言程序)---&gt; 虚拟机器 M3 (汇编语言机器：用汇编程序翻译成机器语言程序)--&gt; 虚拟机器 M2 (操作系统机器：向上提供 &quot;广义指令&quot;(系统调用))---&gt; 传统机器 M1 (用机器语言的机器：执行二进制机器指令)---&gt; 微程序机器 M0 (微指令系统：由硬件直接执行微指令)</p><p>M4,M3,M2 属于软件层次，M1,M0 属于硬件层次</p><p>计算机系统层次，<strong>&lt;font color=&quot;red&quot;&gt; 下层是上层的基础，上层是下层的扩展 &lt;/font&gt;</strong></p><p>编译程序：将高级语言编写的源程序<strong>全部语句一次全部翻译成机器语言程序</strong>，而后再执行机器语言程序 (只需要翻译一次)<br>解释程序：将源程序的一条语句翻译成对于机器语言的语句，并立即执行。紧接着再翻译下一句。(每次执行都要翻译)</p><h3 id=\"计算机工作的过程\"><a class=\"anchor\" href=\"#计算机工作的过程\">#</a> 计算机工作的过程</h3><ol><li>把程序和数据装入主存储器</li><li>将源程序换为可执行文件</li><li>从可执行文件的首地址开始逐条执行指令</li></ol><h3 id=\"什么是存储程序原理\"><a class=\"anchor\" href=\"#什么是存储程序原理\">#</a> 什么是存储程序原理</h3><p>存储程序是指将指令以代码的形式事先输入计算机主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p><h2 id=\"13-计算机的主要性能指标\"><a class=\"anchor\" href=\"#13-计算机的主要性能指标\">#</a> 1.3 计算机的主要性能指标</h2><h3 id=\"存储器的性能指标\"><a class=\"anchor\" href=\"#存储器的性能指标\">#</a> 存储器的性能指标</h3><p>MAR 位数反应存储单元的个数，MDR 位数 = 存储字长 = 每个存储单元的大小。<br>总容量 = 存储单元个数 x 存储字长 bit = 存储单元个 = 数存储字长 x 存储字长 / 8 Byte</p><h3 id=\"cpu的性能指标\"><a class=\"anchor\" href=\"#cpu的性能指标\">#</a> CPU 的性能指标</h3><ol><li>CPU 主频: CPU 内数字脉冲信号震荡的频率。每秒内 CPU 数字脉冲信号震荡的次数 (单位：HZ)。CPU 主频 = 1 / CPU 时钟周期。</li><li>CPU 时钟周期：每个 CPU 脉冲的时间 (单位：微妙、纳秒)。</li><li>CPI：执行一条指令所需要的时钟周期数。</li><li>IPS: 每秒执行多少条指令。IPS= 主频 / 平均 CPI<ol><li>MIPS，即每秒执行百万条指令。</li></ol></li><li>FLOPS：每秒执行多少次浮点运算。<ol><li>MFLOPS</li><li>GFLOPS</li><li>TFLOPS<br>&lt;font color=&quot;red&quot;&gt;<strong> 执行一条指令的耗时 = CPI * CPU 时钟周期</strong> &lt;/font&gt;<br>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 * CPI)/ 主频</li></ol></li></ol><h3 id=\"系统整体性能的指标\"><a class=\"anchor\" href=\"#系统整体性能的指标\">#</a> 系统整体性能的指标</h3><h4 id=\"数据通路带宽\"><a class=\"anchor\" href=\"#数据通路带宽\">#</a> 数据通路带宽</h4><p>数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p><h4 id=\"吞吐量\"><a class=\"anchor\" href=\"#吞吐量\">#</a> 吞吐量</h4><p>指系统在单位时间内处理请求的数量。</p><h4 id=\"响应时间\"><a class=\"anchor\" href=\"#响应时间\">#</a> 响应时间</h4><p>指从用户向计算机发送一个请求，该系统对该请求作出响应并获得所需结果的等待时间。</p><h4 id=\"基准程序跑分软件\"><a class=\"anchor\" href=\"#基准程序跑分软件\">#</a> 基准程序 (跑分软件)</h4><p>是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。</p><h3 id=\"机器字长\"><a class=\"anchor\" href=\"#机器字长\">#</a> 机器字长</h3><p>指计算机进行一次整数运算所能处理的二进制数据的位数。机器字长一般等于内部寄存器的大小。</p><h2 id=\"思考问题\"><a class=\"anchor\" href=\"#思考问题\">#</a> 思考问题</h2><h3 id=\"主频高的cpu一定比主频低的cpu快吗\"><a class=\"anchor\" href=\"#主频高的cpu一定比主频低的cpu快吗\">#</a> 主频高的 CPU 一定比主频低的 CPU 快吗？</h3><p>不一定。还要看 CPI 和指令系统。</p>",
            "tags": [
                "考研",
                "计算机组成",
                "计算机组成",
                "考研"
            ]
        },
        {
            "id": "http://oreki.world/kaoyan/internet/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/",
            "url": "http://oreki.world/kaoyan/internet/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/",
            "title": "408计算机网络-物理层",
            "date_published": "2021-03-28T11:17:07.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h2 id=\"通信基础\"><a class=\"anchor\" href=\"#通信基础\">#</a> 通信基础</h2><h3 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h3><p>物理层解决如何 &lt;font color=Red&gt;<strong> 在各种计算机的传输媒体上传输数据比特流</strong> &lt;/font&gt;，而不是指 &lt; font color=Red&gt;<strong> 具体的传输媒体</strong> &lt;/font&gt;。</p><p>物理层主要任务：确定与传输媒体接口有关的一些特性 ——&gt; 定义标准</p><ol><li>机械特性。定义物理连接的特性，规定物理连接时采用的规格，接口形状，引线数目，引脚数量和排列情况。</li><li>电气特性。规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。</li><li>功能特性。指明某条线上出现的某一电平表示何种意义，接口部件的信号线用途。</li><li>规程特性。定义各条物理线路的工作规程和时序关系。</li></ol><h4 id=\"数据通信相关术语\"><a class=\"anchor\" href=\"#数据通信相关术语\">#</a> 数据通信相关术语</h4><ol><li>数据 data：传送信息的实体，通常是有意义的符号序列。数据通信指在不同计算机之间传输表示信息的二进制数 0、1 序列的过程。</li><li>信号：数据的电气 / 电磁的表现，是数据在传输过程中的存在形式。<ol><li>数字信号 / 离散信号：代表消息的参数的取值是离散的。</li><li>模拟信号 / 连续信号：代表消息的参数的取值是连续的。</li></ol></li><li>信源：产生和发送数据的源头。</li><li>信宿：接受数据的终点。</li><li>信道：信号的传输媒介。<ol><li>按传输信号分：模拟信道 (传送模拟信号) 数字信号 (传送数字信号)</li><li>按传输介质分：无线信道 有线信道</li></ol></li></ol><h4 id=\"三种通信方式\"><a class=\"anchor\" href=\"#三种通信方式\">#</a> 三种通信方式</h4><ol><li>单工</li><li>半双工</li><li>全双工</li></ol><h4 id=\"数据传输方式\"><a class=\"anchor\" href=\"#数据传输方式\">#</a> 数据传输方式</h4><ol><li>串行传输 -- 将表示一个字符的 8 位二进制数按由低位到高位的顺序依次发送</li><li>并行传输 -- 将一个字符的 8 位二进制数同时通过 8 条信道发送</li></ol><h4 id=\"同步传输异步传输\"><a class=\"anchor\" href=\"#同步传输异步传输\">#</a> 同步传输 &amp; 异步传输</h4><ol><li>同步传输 --&gt; 在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。在传输数据时，需先送出一个或者多个同步字符，再送出整批的数据。</li><li>异步传输</li></ol><h4 id=\"码元\"><a class=\"anchor\" href=\"#码元\">#</a> 码元</h4><p>是指用一个固定时长的信号波形（数字脉冲）。是数字信号中数字信号的计量单位。当码元的离散状态由 M 个时，此时码元为 M 进制码元。1 码元可以携带多个比特的信息量。<br>K 进制码元 ---4 进制码元 ——&gt; 码元的离散状态由 4 个 ——&gt;4 种高低不同的信号波形 00、01、10、11</p><h4 id=\"速率\"><a class=\"anchor\" href=\"#速率\">#</a> 速率</h4><p>也叫数据率，指数据的传输速率。可以用码元传输速率和信息传输速率表示。</p><ol><li>码元传输速率：表示单位时间内数字通信系统所传输的码元个数</li></ol><h4 id=\"带宽\"><a class=\"anchor\" href=\"#带宽\">#</a> 带宽</h4><ol><li>在模拟信号系统中，高频与低频之间的差值就是系统的通频带宽，单位是 HZ</li><li>在数字设备中，表示单位时间内从网络的某一点到另一点所能通过的最高数据率 / 单位时间内通过链路的数量，单位是比特每秒</li></ol><h3 id=\"两个公式只有在这两个公式这带宽才用hz\"><a class=\"anchor\" href=\"#两个公式只有在这两个公式这带宽才用hz\">#</a> 两个公式（只有在这两个公式这带宽才用 HZ）</h3><h4 id=\"失真\"><a class=\"anchor\" href=\"#失真\">#</a> 失真</h4><p>影响失真程度的因素：</p><ol><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ol><p>失真的一种现象 -- 码间串扰 &lt;br&gt;<br>接收端接收到的信号波形失去了码元之间清晰界限的现象</p><h4 id=\"奈氏准则奈奎斯特定理\"><a class=\"anchor\" href=\"#奈氏准则奈奎斯特定理\">#</a> 奈氏准则（奈奎斯特定理）</h4><p>在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰。极限码元传输速率为 2WBaud，W 是信道带宽，单位是 HZ。&lt;br&gt;<br>奈氏准则求极限数据率，理想低通信道下的极限数据传速率 = 2Wlog2V</p><p>根据奈氏准则得出结论：</p><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限。就会出现严重的码间串扰问题，是接收端对码元的完全正确识别成为不可能。</li><li>信道的频带越宽，就可以用更高的速率进行码元的有效传输</li><li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量。这就需要采用多元制的调制方法。</li></ol><h4 id=\"香农定理\"><a class=\"anchor\" href=\"#香农定理\">#</a> 香农定理</h4><p>在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。&lt;br&gt;<br>如果题目中给出的信噪比带有单位 dB，则需要先求 S/N：&lt;br&gt;<br>信噪比 (dB) = 10log10 (S/N) &lt;br&gt;<br>信道的极限数据传输速率 = Wlog2 (1+S/N)&lt;br&gt;</p><p>根据香农定理得出结论:</p><ol><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了</li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</li></ol><h3 id=\"数据交换方式\"><a class=\"anchor\" href=\"#数据交换方式\">#</a> 数据交换方式</h3><h4 id=\"电路交换\"><a class=\"anchor\" href=\"#电路交换\">#</a> 电路交换</h4><p>电路交换原理：在数据传输期间，源节点与目的节点之间有一条由中间节点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持 &lt;br&gt;<br>电路交换的阶段：建立连接 (呼叫 / 电路建立) --&gt; 通信 (数据传输) --&gt; 释放连接 (拆除电路)&lt;br&gt;<br>特点：独占资源。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况。&lt;br&gt;</p><h4 id=\"报文交换\"><a class=\"anchor\" href=\"#报文交换\">#</a> 报文交换</h4><p>报文：是网络中交换与传输的数据单元，即站点一次性要送的数据块。&lt;br&gt;<br>报文交换的原理：无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发的方式。&lt;br&gt;</p><h4 id=\"分组交换\"><a class=\"anchor\" href=\"#分组交换\">#</a> 分组交换</h4><p>分组：大多数计算机网络都不能连续地传送任意长的数据，所以实际上网络系统把数据分割成小块，然后逐块地发送，这种小块称作分组 (packet)&lt;br&gt;<br>分组交换原理：分组交换与报文交换工作方式相同，都采用存储转发。形式上差别，分组交换网中要限制所传输的数据单位的长度，一般选 128B。&lt;br&gt;</p><ol><li>数据报方式<ol><li>数据报方式为网络层提供无连接服务。发送方可随时发送分组，网络中的节点可随时接收分组。(无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径)</li><li>同一报文的不同分组达到目的结点时可能发生乱序、重复与丢失。</li><li>每个分组在传输过程中都必须携带源地址和目的地址，以及分组号</li><li>分组在交换结点存储转发时，需要排队等候处理，这会带来一定的时延。当通过交换结点的通信量较大或网络发送拥塞时，这种时延会大大增加，交换结点还可能根绝情况丢弃部分分组。</li><li>网络具有冗余路径，当某一交换结点或一段链路出现故障时，可相应地更新转发表，寻找另一条路径转发分组，对故障的适应能力强，适用于突发性通信，不适于长报文，会话式通信。</li></ol></li><li>虚电路方式<br>虚电路将数据报方式和电路交换方式结合。<br>一条源主机到目的主机类似于电路的路径 (逻辑连接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表。<ol><li>虚电路方式为网络层提供连接服务。源节点和目的结点之间建立一条逻辑连接，而非实际物理连接。(连接服务：首先为分组的传输确定传输路径，然后沿该路径传输系列分组，传输结束后拆除连接)</li><li>一次通信的所有分组都通过虚电路顺序传送，分组不需要携带源地址<br>目的地址等信息，同一报文的不同分组到达目的结点时不会乱序、重复和丢失。</li><li>分组通过虚电路上的每个节点时，节点只进行差错检测，不需要路由选择。</li><li>每个节点可能与多个节点之间建立虚电路，每条虚电路支持特定两个端系统间的数据传输，可以对两个数据端点的流量进行控制。两个端系统之间也可以有多条虚电路为不同的进程服务。</li><li>致命弱点：当网络中的某个节点或者某条链路出故障而彻底失效时，则所有经过该节点或者该链路的虚电路将遭到破坏</li></ol></li></ol><h2 id=\"编码与调制\"><a class=\"anchor\" href=\"#编码与调制\">#</a> 编码与调制</h2><ol><li>基带信号 --&gt; 将数字信号 1 和 0 直接用两种不同的电压表示，再送到数字信道上去传输 (基带传输)</li><li>宽带信号 --&gt; 将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输 (宽带传输)</li></ol><p>再传输距离较近时，计算机网络采用基带传输方式。在距离较远时，计算机网络采用宽带传输方式。</p><p>数字数据 --（数字发送器）-&gt; 数字信号 编码 &lt;br&gt;<br>数字数据 --（调制器）-&gt; 模拟信号 调制 &lt;br&gt;</p><p>模拟数据 --（PCM 编码器）-&gt; 数字信号 编码 &lt;br&gt;<br>模拟数据 --（放大器调制器）-&gt; 模拟信号 调制 &lt;br&gt;</p><p>数字数据编码为数字信号</p><ol><li>非归零编码 (NRZ)</li><li>曼彻斯特编码 --&gt; 一个码元中信号变化 2 次</li><li>差分曼彻斯特编码</li><li>归零编码 (RZ)</li><li>反向不归零编码 (NRZI)</li><li>4B/5B 编码</li></ol><p>数字数据调制为模拟信号</p><p>模拟数据编码为数字信号</p><h2 id=\"传输介质设备\"><a class=\"anchor\" href=\"#传输介质设备\">#</a> 传输介质 &amp; 设备</h2><h3 id=\"传输介质\"><a class=\"anchor\" href=\"#传输介质\">#</a> 传输介质</h3><h4 id=\"导向传输介质\"><a class=\"anchor\" href=\"#导向传输介质\">#</a> 导向传输介质</h4><p>电磁被导向沿着固体媒介 (铜线 / 光纤) 传播。&lt;br&gt;</p><ol><li><p>双绞线。最古老，最常用的传输介质，由两根采用一定规则并排绞合的、相互绝缘的铜导线组成。</p><ol><li>屏蔽双绞线 (STP)</li><li>非屏蔽双绞线 (UTP)</li></ol></li><li><p>同轴电缆</p><ol><li>基带同轴电缆，传送基带数字信号</li><li>宽带同轴电缆，传送宽带信号</li></ol></li><li><p>光纤</p><ol><li><p>多模光纤<br>定义：有多种传输光信号模式的光纤<br>光源：发光二极管<br>易失真，适合近距离传输</p></li><li><p>单模光纤<br>定义：一种在横向模式直接传输光信号的光纤<br>光源：定向性很好的激光二极管<br>特点：衰耗小，适合远距离传输</p></li></ol><p>光纤的特点：&lt;br&gt;</p><ol><li>传输损耗小</li><li>抗雷电和电磁干扰性能好</li><li>保密性好，不易被窃听和截取数据</li><li>体积小、重量轻</li></ol></li></ol><h4 id=\"非导向传输介质\"><a class=\"anchor\" href=\"#非导向传输介质\">#</a> 非导向传输介质</h4><p>自由空间，介质可以是空气、真空、海水等。</p><ol><li><p>无线电波：信号向所有方向传播。较强穿透能力，可传远距离，广泛用于通信领域。</p></li><li><p>微波：信号固定方向传播。微波通信频率较高、频段范围宽，因此数据率很高。</p><ol><li>地面微波接力通信</li><li>卫星通信</li></ol></li><li><p>红外线、激光：信号固定方向传播。把要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再在空气中传播。</p></li></ol><h3 id=\"物理层设备\"><a class=\"anchor\" href=\"#物理层设备\">#</a> 物理层设备</h3><h4 id=\"中继器\"><a class=\"anchor\" href=\"#中继器\">#</a> 中继器</h4><p>诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度失真，因此会导致接收错误。&lt;br&gt;<br>中继器的功能：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。&lt;br&gt;<br>中继器的两端：</p><ol><li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络互连。</li><li>两端可连接相同媒体，也可以连接不同媒体。</li><li>中继器两端的网段一定要是同一个协议，中继器不会存储转发。</li></ol><h4 id=\"集线器多口中继器\"><a class=\"anchor\" href=\"#集线器多口中继器\">#</a> 集线器 (多口中继器)</h4><p>集线器的功能：对信号进行再生放大转发，对衰减信号放大，接着转发到其他所有处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><ol><li>集线器不能分割冲突域</li><li>连在集线器上的工作主机平分带宽</li></ol>",
            "tags": [
                "考研",
                "计算机网络",
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://oreki.world/kaoyan/internet/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB/",
            "url": "http://oreki.world/kaoyan/internet/408%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB/",
            "title": "408计算机网络-计算机网络体系",
            "date_published": "2021-03-28T11:16:54.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"计算机网络\"><a class=\"anchor\" href=\"#计算机网络\">#</a> 计算机网络</h3><p>是一个将分散的、具有独立功能的计算机系统，通过通信设备和线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p><p>计算机网络是互连得、自治的计算机集合</p><ol><li>互连 - 通过通信链路互联互通</li><li>自治 - 无主从关系</li></ol><p>计算机网络的功能</p><ol><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li></ol><h3 id=\"计算机网络的发展\"><a class=\"anchor\" href=\"#计算机网络的发展\">#</a> 计算机网络的发展</h3><h4 id=\"第一阶段\"><a class=\"anchor\" href=\"#第一阶段\">#</a> 第一阶段</h4><p>ARPAnet 阿帕网 --&gt; internet (interconnected netword) 互联网 --&gt; Internet 因特网</p><ol><li>网络把许多的计算机连接在一起</li><li>互联网把许多的网络连接在一起</li><li>因特网是世界上最大的互联网</li></ol><h4 id=\"第二阶段-三级结构\"><a class=\"anchor\" href=\"#第二阶段-三级结构\">#</a> 第二阶段 - 三级结构</h4><h4 id=\"第三阶段-多层次isp结构\"><a class=\"anchor\" href=\"#第三阶段-多层次isp结构\">#</a> 第三阶段 - 多层次 ISP 结构</h4><h3 id=\"计算机网络的组成\"><a class=\"anchor\" href=\"#计算机网络的组成\">#</a> 计算机网络的组成</h3><p>组成部分：硬件、软件、协议（一系列规则和约定的集合）</p><p>工作方式</p><ol><li>边缘部分</li><li>核心部分</li></ol><p>功能组成<br>数据通信和资源共享</p><ol><li>通信子网：实现数据通信</li><li>资源子网：实现资源共享 / 数据处理</li></ol><h3 id=\"计算机网络的分类\"><a class=\"anchor\" href=\"#计算机网络的分类\">#</a> 计算机网络的分类</h3><p>按范围分布</p><ol><li>广域网 WAN--&gt; 交换技术</li><li>城域网 MAN</li><li>局域网 LAN--&gt; 广播技术</li><li>个人区域网 PAN</li></ol><p>按使用者分</p><ol><li>公用网</li><li>专用网</li></ol><p>按交换技术分</p><ol><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol><p>按拓扑结构分</p><ol><li>总线型</li><li>星型</li><li>环型</li><li>网状型 -- 常用于广域网</li></ol><p>按传输技术分</p><ol><li>广播式网络 -- 共享公共通信信道</li><li>点对点网络 -- 使用分组存储转发和路由选择机制</li></ol><h3 id=\"计算机网络的标准化工作\"><a class=\"anchor\" href=\"#计算机网络的标准化工作\">#</a> 计算机网络的标准化工作</h3><p>标准的分类</p><ol><li>法定标准：osi</li><li>事实标准: tcp/ip</li></ol><h3 id=\"标准化工作的相关组织\"><a class=\"anchor\" href=\"#标准化工作的相关组织\">#</a> 标准化工作的相关组织</h3><p>国际标准化组织 ISO-- 制定了 OSI 参考模型、HDLC 协议<br>国际电信联盟 ITU-- 制定通信规则<br>国际电气电子工程师协会 IEEE-- 学术机构、IEEE802 系列标准、5G<br>internet 工程任务组 IETF-- 负责因特网相关标准的制定</p><h3 id=\"计算机网络性能指标\"><a class=\"anchor\" href=\"#计算机网络性能指标\">#</a> 计算机网络性能指标</h3><h4 id=\"速率\"><a class=\"anchor\" href=\"#速率\">#</a> 速率</h4><p>即数据率或者称数据传输率或比特率</p><h4 id=\"比特\"><a class=\"anchor\" href=\"#比特\">#</a> 比特</h4><p>表现形式：1/0 单位：位</p><p>连接在计算机网络上的主机在数字信道上传送数据位数的速率单位是 b/s, kb/s, Mb/s, Gb/s, Tb/s</p><h4 id=\"存储容量\"><a class=\"anchor\" href=\"#存储容量\">#</a> 存储容量</h4><p>1Byte (字节)=8bit (比特)</p><h4 id=\"带宽\"><a class=\"anchor\" href=\"#带宽\">#</a> 带宽</h4><p>计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的 “最高数据率”。单位是 b/s, kb/s, Mb/s, Gb/s, Tb/s</p><h4 id=\"吞吐量\"><a class=\"anchor\" href=\"#吞吐量\">#</a> 吞吐量</h4><p>表示在单位时间内通过某个网络 (或信道、接口) 的数据量。单位是 b/s, kb/s, Mb/s 等<br>吞吐量受网络的带宽限制</p><h4 id=\"时延\"><a class=\"anchor\" href=\"#时延\">#</a> 时延</h4><p>指数据从网络的一端传送到另一端所需的时间。也叫延迟，单位是 s</p><ol><li>发送时延：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。发送时延 = 数据长度 / 信道带宽</li><li>传播时延：取决于电磁波传播速度和链路长度。传播时延 = 信道长度 / 电磁波在信道上的传播速率</li><li>排队时延</li><li>处理时延</li></ol><p>时延带宽积<br>时延带宽积 = 传播时延 * 带宽<br>以比特位单位的链路长度，即 “某段链路现在有多少比特”</p><h4 id=\"往返使用rtt\"><a class=\"anchor\" href=\"#往返使用rtt\">#</a> 往返使用 RTT</h4><p>从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延。<br>RTT 越大，在收到确认之前，可以发送的数据越多。&lt;br&gt;<br>RTT 包括</p><ol><li>往返传播时延 = 传播时延 * 2</li><li>末端处理时间</li></ol><p>利用率</p><ol><li>信道利用率：有数据通过的时间 /（有 + 无）数据通过时间</li><li>网络利用率：信道利用率加权平均值</li></ol><h3 id=\"综合概念\"><a class=\"anchor\" href=\"#综合概念\">#</a> 综合概念</h3><ol><li>网络体系结构是从功能上描述计算机网络结构 &lt;br&gt;</li><li>计算机网络体系结构简称网络体系结构是分层结构 &lt;br&gt;</li><li>每层遵循某个网络以完成本层功能 &lt;br&gt;</li><li>计算机网络体系结构是计算机网络的各层及其协议的集合 &lt;br&gt;</li><li>第 N 层在向 N+1 层提供服务时，此服务不仅包含第 N 层本身的功能，还包含由下层服务提供的功能 &lt;br&gt;</li><li>仅仅在相邻层有接口，且所提供的服务的具体实现细节对上一层完全屏蔽 &lt;br&gt;</li><li>体系结构是抽象的，而实现是指能运行的一些软件和硬件 &lt;br&gt;</li></ol><p>协议与服务有何区别？</p><ol><li>协议是水平的，即协议是控制两个对等实体之间通信的规则。服务是垂直的。即服务室由下层通过层间接口向上层提供。</li><li></li></ol>",
            "tags": [
                "考研",
                "计算机网络",
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/miscellaneous/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/",
            "url": "http://oreki.world/computer-science/miscellaneous/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/",
            "title": "进程线程协程",
            "date_published": "2020-10-24T08:54:17.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"进程\"><a class=\"anchor\" href=\"#进程\">#</a> 进程</h3><p>操作系统提供的抽象概念，是系统进行资源分配和调度的基本单位。也可以说是实体，程序的实体。程序本身是没有生命周期的，它只是存在磁盘上的一些指令，程序一旦运行就是进程。</p><ol><li>每一个进程都有自己的地址空间，一般情况下，包括文本区域、数据区域和堆栈。文本区域存储代码、数据区域分配内存、堆栈区域存储调用的指令和本地变量。</li><li>进程是一个 “执行中的程序”。</li></ol><h3 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h3><p>轻量级进程，是程序执行流的最小单元。是程序的实际执行者。</p><ol><li>线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</li><li>一个进程里面有多个线程</li><li>每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</li><li>线程拥有自己的栈空间。</li></ol><p>线程也有就绪、阻塞和运行三种基本状态。</p><ol><li>就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；</li><li>运行状态是指线程占有处理机正在运行；</li><li>阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。</li></ol><h3 id=\"协程\"><a class=\"anchor\" href=\"#协程\">#</a> 协程</h3><p>需要讲回线程<br>线程有两种类型</p><ol><li>一种是由内核来管理和调度。</li><li>另外一种线程，他的调度是由程序员自己写程序来管理的，对内核来说不可见。这种线程叫做『用户空间线程』。</li></ol><p>协程可以理解就是一种用户空间线程。</p><ol><li>协同，因为是由程序员自己写的调度策略，其通过协作而不是抢占来进行切换</li><li>在用户态完成创建，切换和销毁</li></ol>",
            "tags": [
                "计算机科学",
                "开发&系统&运维",
                "操作系统"
            ]
        },
        {
            "id": "http://oreki.world/computer-science/python/pyqt/PyQt%E7%9A%84Led%E6%8E%A7%E4%BB%B6%E6%98%BE%E7%A4%BA%E5%BA%93/",
            "url": "http://oreki.world/computer-science/python/pyqt/PyQt%E7%9A%84Led%E6%8E%A7%E4%BB%B6%E6%98%BE%E7%A4%BA%E5%BA%93/",
            "title": "PyQt的Led控件显示库",
            "date_published": "2020-10-16T06:30:09.000Z",
            "content_html": "<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><h3 id=\"控件说明\"><a class=\"anchor\" href=\"#控件说明\">#</a> 控件说明</h3><p>在 Github 上，偶然发现了一个基于 PyQt5 的第三方 Led 指示灯控件库，使用起来非常方便，控件外观也比较漂亮，更难能可贵的是作者源代码写得比较简洁，仅仅才约 200 行左右，可以作为一个在 PyQt 中写自定义控件方法的非常好的学习例子。这个控件具有以下特点：</p><ol><li>提供了 3 种外形可供选择，分别为：'capsule', 'circle', 'rectangle' 等</li><li>提供了 7 种颜色可供选择，分别为：'blue', 'green', 'orange', 'purple', 'red', 'yellow' 等</li></ol><h3 id=\"安装使用\"><a class=\"anchor\" href=\"#安装使用\">#</a> 安装使用</h3><figure class=\"highlight powershell\"><figcaption data-lang=\"PowerShell\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pip install pyqt<span class=\"token operator\">-</span>led</pre></td></tr></table></figure><p>在代码中使用时，只需使用以下语句导入该库的 LED 类即可：</p><figure class=\"highlight powershell\"><figcaption data-lang=\"PowerShell\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> pyqt_led import led</pre></td></tr></table></figure><p>在该库中，提供了几个主要的方法函数，包括 set_on_color、set_off_color、set_shape、turn_on、turn_off 等函数，分别设置 Led 的开 / 关颜色、形状及设置开、关状态等。</p><h3 id=\"使用案例\"><a class=\"anchor\" href=\"#使用案例\">#</a> 使用案例</h3><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> sys</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> PyQt5<span class=\"token punctuation\">.</span>QtWidgets <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">from</span> PyQt5<span class=\"token punctuation\">.</span>QtGui <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">from</span> PyQt5<span class=\"token punctuation\">.</span>QtCore <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">from</span> pyqt_led <span class=\"token keyword\">import</span> Led</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span><span class=\"token punctuation\">(</span>QWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> parent<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        QWidget<span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> parent<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_shape <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'capsule'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'circle'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'rectangle'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_color <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'green'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'orange'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'purple'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                                <span class=\"token string\">'yellow'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_layout <span class=\"token operator\">=</span> QGridLayout<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_create_leds<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_arrange_leds<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        self<span class=\"token punctuation\">.</span>resize<span class=\"token punctuation\">(</span><span class=\"token number\">400</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        self<span class=\"token punctuation\">.</span>setWindowTitle<span class=\"token punctuation\">(</span><span class=\"token string\">'pyqt-led Demo'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">keyPressEvent</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">if</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> Qt<span class=\"token punctuation\">.</span>Key_Escape<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            self<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">_create_leds</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">for</span> s <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>_shape<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>_color<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token keyword\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'self._&#123;&#125;_&#123;&#125; = Led(self, on_color=Led.&#123;&#125;, shape=Led.&#123;&#125;, build=\"debug\")'</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                     <span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                <span class=\"token keyword\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'self._&#123;&#125;_&#123;&#125;.setFocusPolicy(Qt.NoFocus)'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                <span class=\"token keyword\">exec</span><span class=\"token punctuation\">(</span><span class=\"token string\">'self._&#123;&#125;_&#123;&#125;.turn_on(True)'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">_arrange_leds</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">for</span> r <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            <span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                <span class=\"token keyword\">exec</span><span class=\"token punctuation\">(</span>'self<span class=\"token punctuation\">.</span>_layout<span class=\"token punctuation\">.</span>addWidget<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>_<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>_<span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> \\</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                      Qt<span class=\"token punctuation\">.</span>AlignCenter<span class=\"token punctuation\">)</span>'</pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                     <span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>_shape<span class=\"token punctuation\">[</span>r<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>_color<span class=\"token punctuation\">[</span>c<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>app <span class=\"token operator\">=</span> QApplication<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>demo <span class=\"token operator\">=</span> Demo<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>demo<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>sys<span class=\"token punctuation\">.</span>exit<span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">.</span>exec_<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>运行这个程序后，即可出现本文开头所示的在一个窗口上显示了不同形状、不同颜色的 Led 的窗口。默认运行时显示的为全亮状态，当设置为全灭状态时，如下图所示：</p><p>在代码中，Led 类实例化时，其构造函数原型如下所示：</p><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Led<span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">,</span> on_color<span class=\"token operator\">=</span>green<span class=\"token punctuation\">,</span> off_color<span class=\"token operator\">=</span>black<span class=\"token punctuation\">,</span> shape<span class=\"token operator\">=</span>rectangle<span class=\"token punctuation\">,</span> build<span class=\"token operator\">=</span><span class=\"token string\">'release'</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>可传入父窗口、初始的亮颜色、灭颜色、形状及状态参数。</p><p>对于需要在程序开发中使用指示灯的情况，如显示各种程序的运行状态等，应该说这是一个比较实用的库了。当然，由于源代码比较简单，你也可以在其基础上进一步修改订制，比如添加其它形状、颜色等选项设置，以满足自己的项目使用要求。</p>",
            "tags": [
                "计算机科学",
                "Python",
                "PyQt",
                "Python"
            ]
        }
    ]
}